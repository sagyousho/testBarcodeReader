/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/H_barcodeReader.js":
/*!********************************!*\
  !*** ./src/H_barcodeReader.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"H_BarCodeReader\": () => (/* binding */ H_BarCodeReader)\n/* harmony export */ });\n/* harmony import */ var _quagga_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quagga.min */ \"./src/quagga.min.js\");\n/* harmony import */ var _quagga_min__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_quagga_min__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Libs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Libs */ \"./src/Libs.js\");\n// import { Quagga } from \"quagga\";\r\n\r\n// import { HumanResourcesAPI } from \"./HumanResourcesAPI\";\r\n\r\n\r\nclass H_BarCodeReader {\r\n\r\n  /**\r\n   * 初期設定\r\n   * @param {object} setting\r\n   */\r\n  constructor(setting) {\r\n    this.setting = setting;\r\n    this.logicalProcessors = navigator.hardwareConcurrency; //処理を行う論理CPU数設定(default:PCスペックの最大数)\r\n\r\n    //inputStream\r\n    this.type = setting.inputStream.type; //スキャン方式(default:\"LiveStream\")\r\n    this.target = document.getElementById(setting.inputStream.target); //カメラ映像を表示するHTML要素設定(default:barord-scan-area)\r\n    this.decodeBarCodeRate = setting.inputStream.decodeBarCodeRate; //(default:3)\r\n    this.successTimeout = setting.inputStream.successTimeout; //検出が成功したときの遅延時間(default:500)\r\n    this.codeRepetition = setting.inputStream.codeRepetition; //コードの繰り返しを受け入れ可否(default:true)\r\n    this.tryVertical = setting.inputStream.tryVertical; //垂直のバーコードの読み取り(defaulut:true)\r\n    this.frameRate = setting.inputStream.frameRate; //フレームレート(default:15)\r\n    this.width = setting.inputStream.width; //横幅(default:)\r\n    this.height = setting.inputStream.height; //縦幅(default:)\r\n    this.facingMode = setting.inputStream.facingMode; //バックカメラの利用を設定(フロントカメラは\"user\")(default:environment(バックカメラ))\r\n    this.frequency = setting.inputStream.frequency; //スキャン精度 1秒あたりの最大スキャン回数(default:10)\r\n    // スキャンしない範囲設定\r\n    this.top = setting.inputStream.area.top;\r\n    this.right = setting.inputStream.area.right;\r\n    this.left = setting.inputStream.area.left;\r\n    this.bottom = setting.inputStream.area.bottom;\r\n\r\n    //decoder\r\n    this.readers = setting.decoder.readers; //バーコード方式(default:\"code_128_reader\")\r\n    this.multiple = setting.decoder.multiple; //複数検知(default:false)\r\n\r\n    //locate\r\n    this.locate = setting.locate; //バーコードの位置を特定する機能(default:true)\r\n    this.halfSample = setting.locate.halfSample; //バーコードの位置を特定する機能(default:true)\r\n    this.patchSize = setting.locate.patchSize; //バーコード読み取りサイズ(default:\"medium\")\r\n\r\n    //extra\r\n    this.codeCheckCount = setting.codeCheckCount; //スキャンしたコードのチェック回数(default:3)\r\n    this.scanBoxLineColor = setting.scanBoxLineColor; //バーコード検知の枠の色(default:\"green\")\r\n    this.scanBoxLineWidth = setting.scanBoxLineWidth; //バーコード検知の枠の幅(default:2)\r\n    this.successBoxLineColor = setting.successBoxLineColor; //バーコード読取り時の枠の色(default:\"yellow\")\r\n    this.successBoxLineWidth = setting.successBoxLineWidth; //バーコード読取り時の枠の幅(default:2)\r\n    this.successLineColor = setting.successLineColor; //バーコード検出完了時の色(default:\"red\")\r\n    this.successLineWidth = setting.successLineWidth; //バーコード検出完了時の幅(default:3)\r\n    this.successAudioSource = setting.successAudioSource; //検出完了時の音声path(default:3)\r\n    this.scanTimeOut = setting.scanTimeOut; //\"自動停止時間(秒設定)\"\r\n    this.checkCount = setting.checkCount; //\"検知判定回数\"\r\n\r\n  }\r\n\r\n\r\n  /**\r\n   * バーコードスキャンスタート\r\n   */\r\n  startScanner() {\r\n    // console.log(this.setting);\r\n    const scanTimeOut = this.scanTimeOut;\r\n    const scanBoxLineColor = this.scanBoxLineColor;\r\n    const scanBoxLineWidth = this.scanBoxLineWidth;\r\n    const successBoxLineColor = this.successBoxLineColor;\r\n    const successBoxLineWidth = this.successBoxLineWidth;\r\n    const successLineColor = this.successLineColor;\r\n    const successLineWidth = this.successLineWidth;\r\n    const codeCheckCount = this.codeCheckCount;\r\n    // const resourcesAPI = new HumanResourcesAPI(this.setting);\r\n    const libs = new _Libs__WEBPACK_IMPORTED_MODULE_1__.Libs();\r\n    let decodedValue;\r\n    const date = new Date();\r\n    const now = date.getFullYear() + '-' + date.getMonth() + '-' + date.getDate();\r\n    const messageElem = document.getElementById(\"result-message\");\r\n\r\n    // 設定初期化;\r\n    _quagga_min__WEBPACK_IMPORTED_MODULE_0__.init(\r\n      {\r\n        numOfWorkers: this.logicalProcessors,\r\n        inputStream: {\r\n          type: this.type,\r\n          target: this.target,\r\n          frequency: this.frequency,\r\n          area: {\r\n            top: this.top,\r\n            right: this.right,\r\n            left: this.left,\r\n            bottom: this.bottom \r\n          },\r\n          constraints: {\r\n            decodeBarCodeRate: this.decodeBarCodeRate,\r\n            successTimeout: this.successTimeout,\r\n            codeRepetition: this.codeRepetition,\r\n            tryVertical: this.tryVertical,\r\n            frameRate: this.frameRate,\r\n            width: this.width,\r\n            height: this.height,\r\n            facingMode: this.facingMode,\r\n          },\r\n        },\r\n        decoder: {\r\n          multiple: this.multiple,\r\n          readers: [ this.readers ],\r\n        },\r\n        locate: this.locate,\r\n        locater: {\r\n          halfSample: this.halfSample,\r\n          patchSize: this.patchSize,\r\n        },\r\n      },\r\n      function (err) {\r\n        if (err) {\r\n          console.error(err);\r\n          return;\r\n        }\r\n\r\n        //バーコード読み取りスタート\r\n        console.log(\"Initialization finished. Ready to start\");\r\n        _quagga_min__WEBPACK_IMPORTED_MODULE_0__.start();\r\n\r\n        //一定時間バーコードを読み取りしないと停止\r\n        let count = 0\r\n        let interval = setInterval(() => {\r\n          if (count >= scanTimeOut) {\r\n            count = 0;\r\n            _quagga_min__WEBPACK_IMPORTED_MODULE_0__.stop();\r\n            clearInterval(interval);\r\n          }\r\n          if (decodedValue) {\r\n            count = 0;\r\n            decodedValue = null;\r\n          }\r\n          count++;\r\n        }, 1000)\r\n        \r\n        \r\n      }\r\n    );\r\n\r\n\r\n    _quagga_min__WEBPACK_IMPORTED_MODULE_0__.onProcessed(function (result) {\r\n      var drawingCtx = _quagga_min__WEBPACK_IMPORTED_MODULE_0__.canvas.ctx.overlay,\r\n        drawingCanvas = _quagga_min__WEBPACK_IMPORTED_MODULE_0__.canvas.dom.overlay;\r\n    // 検知時の処理\r\n      if (result) {\r\n        if (result.boxes) {\r\n          drawingCtx.clearRect(\r\n            0,\r\n            0,\r\n            parseInt(drawingCanvas.getAttribute(\"width\")),\r\n            parseInt(drawingCanvas.getAttribute(\"height\"))\r\n          );\r\n          result.boxes\r\n            .filter(function (box) {\r\n              return box !== result.box;\r\n            })\r\n            .forEach(function (box) {\r\n              _quagga_min__WEBPACK_IMPORTED_MODULE_0__.ImageDebug.drawPath(\r\n                box,\r\n                {\r\n                  x: 0,\r\n                  y: 1,\r\n                },\r\n                drawingCtx,\r\n                {\r\n                  color: scanBoxLineColor,\r\n                  lineWidth: scanBoxLineWidth,\r\n                }\r\n              );\r\n            });\r\n        }\r\n\r\n        // 検知完了時の処理\r\n        if (result.box) {\r\n          _quagga_min__WEBPACK_IMPORTED_MODULE_0__.ImageDebug.drawPath(\r\n            result.box,\r\n            {\r\n              x: 0,\r\n              y: 1,\r\n            },\r\n            drawingCtx,\r\n            {\r\n              // color: \"#00F\",\r\n              color: successBoxLineColor,\r\n              lineWidth: successBoxLineWidth,\r\n            }\r\n          );\r\n        }\r\n\r\n        if (result.codeResult && result.codeResult.code) {\r\n          _quagga_min__WEBPACK_IMPORTED_MODULE_0__.ImageDebug.drawPath(\r\n            result.line,\r\n            {\r\n              x: \"x\",\r\n              y: \"y\",\r\n            },\r\n            drawingCtx,\r\n            {\r\n              color: successLineColor,\r\n              lineWidth: successLineWidth,\r\n            }\r\n          );\r\n        }\r\n      }\r\n    });\r\n\r\n    //barcode read call back\r\n    let scanResults = [];\r\n    let resultBuffer = [];\r\n\r\n    _quagga_min__WEBPACK_IMPORTED_MODULE_0__.onDetected(function (result) {\r\n\r\n      let isErr = false;\r\n      result.codeResult.decodedCodes.find((data) => {\r\n        if (data.error) {\r\n          if (parseFloat(data.error) > 0.19) {\r\n            isErr = true;\r\n          }\r\n        }\r\n      });\r\n      if (isErr) return;\r\n\r\n      // エラー率の中央値が0.1以上なら除外\r\n      const errors = result.codeResult.decodedCodes.filter((_) => _.error !== undefined).map((_) => _.error);\r\n      // 中央値を取得\r\n      const median = function() {\r\n        errors.sort((a, b) => a - b);\r\n        const half = Math.floor(errors.length / 2);\r\n        if (errors.length % 2 === 1)\r\n            return errors[half]\r\n        return (errors[half - 1] + errors[half]) / 2.0\r\n      }\r\n\r\n      if (median > 0.1) {\r\n        return;\r\n      }\r\n\r\n    // 3回連続で同じ値だった場合のみ採用\r\n      scanResults.push(result.codeResult.code)\r\n      if (scanResults.length < codeCheckCount) {\r\n        return;\r\n      }\r\n\r\n      if (scanResults[0] !== scanResults[1]) {\r\n        scanResults.shift();\r\n        return;\r\n      }\r\n\r\n      \r\n      // 複数回目は前回と値が違う時だけ発火\r\n      if (resultBuffer.length > 0) {\r\n        if (resultBuffer.slice(-1)[0] === result.codeResult.code) {\r\n          return;\r\n        }\r\n      }\r\n      \r\n      resultBuffer.push(result.codeResult.code);\r\n\r\n      //読み取り成功時の処理\r\n      decodedValue = result.codeResult.code; //バーコード\r\n      console.log(decodedValue);\r\n      // messageElem.textcontent = decodedValue;\r\n      document.getElementById('result-message').textContent = decodedValue;\r\n      libs.countTextRemove(messageElem, 5);\r\n      // セッションストレージの存在確認\r\n      // let comeInData = now + '_in_' + decodedValue;\r\n      // let comeOutData = now + '_out_' + decodedValue;\r\n      // if (!sessionStorage.getItem(comeInData)) {\r\n      //   let comeOutTime = sessionStorage.getItem(comeOutData);\r\n      //   // console.log(\"comeInTime:\" + comeInTime);\r\n      //   let diffSecond = libs.getDiffTime(comeOutTime);\r\n      //   if (diffSecond > 60) {\r\n      //     sessionStorage.setItem(comeInData, libs.getNowTime());\r\n      //     console.log(\"in_comeinTime:\" + sessionStorage.getItem(comeInData));\r\n      //     resourcesAPI.api('POST', { barcode: decodedValue, date: now }, 'in');\r\n      //   } else {\r\n      //       messageElem.textcontent = \"短時間での連続読み取りを検出しました\"\r\n      //     libs.countTextRemove(messageElem, 5);\r\n      //     }\r\n      // } else {\r\n      //   if (sessionStorage.getItem(comeOutData)) {\r\n      //     sessionStorage.removeItem(comeOutData);\r\n      //   } else {\r\n      //     let comeInTime = sessionStorage.getItem(comeInData);\r\n      //     // console.log(\"comeInTime:\" + comeInTime);\r\n      //     let diffSecond = libs.getDiffTime(comeInTime);\r\n      //     // console.log(\"diffsecond:\" + diffSecond);\r\n      //     if (diffSecond > 60) {\r\n      //       sessionStorage.removeItem(comeInData);\r\n      //       resourcesAPI.api('PUT', { barcode: decodedValue, date: now }, 'out');\r\n      //       sessionStorage.setItem(comeOutData, libs.getNowTime());\r\n      //     } else {\r\n      //       messageElem.textcontent = \"短時間での連続読み取りを検出しました\"\r\n      //       libs.countTextRemove(messageElem, 5);\r\n      //     }\r\n      //   }\r\n      // }\r\n    });\r\n  }\r\n}\r\n\r\n\r\n\r\ndocument.getElementById(\"camera-stop\").addEventListener('click', () => {\r\n  _quagga_min__WEBPACK_IMPORTED_MODULE_0__.stop();\r\n})\r\n\r\n\r\n\n\n//# sourceURL=webpack://test/./src/H_barcodeReader.js?");

/***/ }),

/***/ "./src/Libs.js":
/*!*********************!*\
  !*** ./src/Libs.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Libs\": () => (/* binding */ Libs)\n/* harmony export */ });\nclass Libs\r\n{\r\n  createToken()\r\n  {\r\n    const N = 32;\r\n    return btoa(String.fromCharCode(...crypto.getRandomValues(new Uint8Array(N)))).substring(0,N)\r\n  }\r\n\r\n  getNowTime()\r\n  {\r\n    const date = new Date();\r\n    return date.getTime();\r\n  }\r\n  \r\n\r\n  /**\r\n   * 時間の比較計算\r\n   * @param {date} oldTime:現在日時と比較したい時間 \r\n   * @returns {int}\r\n   */\r\n  getDiffTime(oldTime)\r\n  {\r\n    const date = new Date();\r\n    const nowTime = date.getTime();\r\n    const diffTime = nowTime - oldTime;\r\n    return Math.floor(diffTime / (1000));\r\n  }\r\n\r\n  /**\r\n   * \r\n   * @param {HTMLElement} elem \r\n   * @param {int} min \r\n   */\r\n  countTextRemove(elem, min)\r\n  {\r\n    let count = min * 1000;\r\n    setTimeout(() => {\r\n      elem.textContent = \"\";\r\n    }, count);\r\n  }\r\n}\n\n//# sourceURL=webpack://test/./src/Libs.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _H_barcodeReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./H_barcodeReader */ \"./src/H_barcodeReader.js\");\n\r\n\r\n\r\n// window.addEventListener(\"DOMContentLoaded\", () => {\r\ndocument.getElementById('camera-start').addEventListener('click', () => {\r\n  try {\r\n    var settingData = __webpack_require__(/*! ../dist/setting.json */ \"./dist/setting.json\");\r\n    console.log(settingData);\r\n    const HBarCodeReader = new _H_barcodeReader__WEBPACK_IMPORTED_MODULE_0__.H_BarCodeReader(settingData);\r\n    HBarCodeReader.startScanner();\r\n  } catch (e) {\r\n    console.log(e); //例外処理\r\n    // 設定ファイルの読み込みに失敗した場合、以下の設定にする\r\n    alert(\"エラー：\" + e.message)\r\n}\r\n});\r\n\n\n//# sourceURL=webpack://test/./src/index.js?");

/***/ }),

/***/ "./src/quagga.min.js":
/*!***************************!*\
  !*** ./src/quagga.min.js ***!
  \***************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\r\n\tif(true)\r\n\t\tmodule.exports = factory();\r\n\telse {}\r\n})(window, function() {\r\nreturn /******/ (function(modules) { // webpackBootstrap\r\n/******/ \t// The module cache\r\n/******/ \tvar installedModules = {};\r\n/******/\r\n/******/ \t// The require function\r\n/******/ \tfunction __nested_webpack_require_552__(moduleId) {\r\n/******/\r\n/******/ \t\t// Check if module is in cache\r\n/******/ \t\tif(installedModules[moduleId]) {\r\n/******/ \t\t\treturn installedModules[moduleId].exports;\r\n/******/ \t\t}\r\n/******/ \t\t// Create a new module (and put it into the cache)\r\n/******/ \t\tvar module = installedModules[moduleId] = {\r\n/******/ \t\t\ti: moduleId,\r\n/******/ \t\t\tl: false,\r\n/******/ \t\t\texports: {}\r\n/******/ \t\t};\r\n/******/\r\n/******/ \t\t// Execute the module function\r\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_552__);\r\n/******/\r\n/******/ \t\t// Flag the module as loaded\r\n/******/ \t\tmodule.l = true;\r\n/******/\r\n/******/ \t\t// Return the exports of the module\r\n/******/ \t\treturn module.exports;\r\n/******/ \t}\r\n/******/\r\n/******/\r\n/******/ \t// expose the modules object (__webpack_modules__)\r\n/******/ \t__nested_webpack_require_552__.m = modules;\r\n/******/\r\n/******/ \t// expose the module cache\r\n/******/ \t__nested_webpack_require_552__.c = installedModules;\r\n/******/\r\n/******/ \t// define getter function for harmony exports\r\n/******/ \t__nested_webpack_require_552__.d = function(exports, name, getter) {\r\n/******/ \t\tif(!__nested_webpack_require_552__.o(exports, name)) {\r\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\r\n/******/ \t\t}\r\n/******/ \t};\r\n/******/\r\n/******/ \t// define __esModule on exports\r\n/******/ \t__nested_webpack_require_552__.r = function(exports) {\r\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\r\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\r\n/******/ \t\t}\r\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\r\n/******/ \t};\r\n/******/\r\n/******/ \t// create a fake namespace object\r\n/******/ \t// mode & 1: value is a module id, require it\r\n/******/ \t// mode & 2: merge all properties of value into the ns\r\n/******/ \t// mode & 4: return value when already ns object\r\n/******/ \t// mode & 8|1: behave like require\r\n/******/ \t__nested_webpack_require_552__.t = function(value, mode) {\r\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_552__(value);\r\n/******/ \t\tif(mode & 8) return value;\r\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\r\n/******/ \t\tvar ns = Object.create(null);\r\n/******/ \t\t__nested_webpack_require_552__.r(ns);\r\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\r\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_552__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\r\n/******/ \t\treturn ns;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\r\n/******/ \t__nested_webpack_require_552__.n = function(module) {\r\n/******/ \t\tvar getter = module && module.__esModule ?\r\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\r\n/******/ \t\t\tfunction getModuleExports() { return module; };\r\n/******/ \t\t__nested_webpack_require_552__.d(getter, 'a', getter);\r\n/******/ \t\treturn getter;\r\n/******/ \t};\r\n/******/\r\n/******/ \t// Object.prototype.hasOwnProperty.call\r\n/******/ \t__nested_webpack_require_552__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\r\n/******/\r\n/******/ \t// __webpack_public_path__\r\n/******/ \t__nested_webpack_require_552__.p = \"/\";\r\n/******/\r\n/******/\r\n/******/ \t// Load entry module and return exports\r\n/******/ \treturn __nested_webpack_require_552__(__nested_webpack_require_552__.s = 89);\r\n/******/ })\r\n/************************************************************************/\r\n/******/ ([\r\n/* 0 */\r\n/***/ (function(module, exports) {\r\n\r\nfunction _defineProperty(obj, key, value) {\r\n  if (key in obj) {\r\n    Object.defineProperty(obj, key, {\r\n      value: value,\r\n      enumerable: true,\r\n      configurable: true,\r\n      writable: true\r\n    });\r\n  } else {\r\n    obj[key] = value;\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 1 */\r\n/***/ (function(module, exports) {\r\n\r\nfunction _assertThisInitialized(self) {\r\n  if (self === void 0) {\r\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\r\n  }\r\n\r\n  return self;\r\n}\r\n\r\nmodule.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 2 */\r\n/***/ (function(module, exports) {\r\n\r\nfunction _getPrototypeOf(o) {\r\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\r\n    return o.__proto__ || Object.getPrototypeOf(o);\r\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n  return _getPrototypeOf(o);\r\n}\r\n\r\nmodule.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 3 */\r\n/***/ (function(module, exports) {\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n  if (!(instance instanceof Constructor)) {\r\n    throw new TypeError(\"Cannot call a class as a function\");\r\n  }\r\n}\r\n\r\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 4 */\r\n/***/ (function(module, exports) {\r\n\r\nfunction _defineProperties(target, props) {\r\n  for (var i = 0; i < props.length; i++) {\r\n    var descriptor = props[i];\r\n    descriptor.enumerable = descriptor.enumerable || false;\r\n    descriptor.configurable = true;\r\n    if (\"value\" in descriptor) descriptor.writable = true;\r\n    Object.defineProperty(target, descriptor.key, descriptor);\r\n  }\r\n}\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) {\r\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n  if (staticProps) _defineProperties(Constructor, staticProps);\r\n  Object.defineProperty(Constructor, \"prototype\", {\r\n    writable: false\r\n  });\r\n  return Constructor;\r\n}\r\n\r\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 5 */\r\n/***/ (function(module, exports, __nested_webpack_require_6579__) {\r\n\r\nvar _typeof = __nested_webpack_require_6579__(20)[\"default\"];\r\n\r\nvar assertThisInitialized = __nested_webpack_require_6579__(1);\r\n\r\nfunction _possibleConstructorReturn(self, call) {\r\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\r\n    return call;\r\n  } else if (call !== void 0) {\r\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\r\n  }\r\n\r\n  return assertThisInitialized(self);\r\n}\r\n\r\nmodule.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 6 */\r\n/***/ (function(module, exports, __nested_webpack_require_7208__) {\r\n\r\nvar setPrototypeOf = __nested_webpack_require_7208__(41);\r\n\r\nfunction _inherits(subClass, superClass) {\r\n  if (typeof superClass !== \"function\" && superClass !== null) {\r\n    throw new TypeError(\"Super expression must either be null or a function\");\r\n  }\r\n\r\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\r\n    constructor: {\r\n      value: subClass,\r\n      writable: true,\r\n      configurable: true\r\n    }\r\n  });\r\n  Object.defineProperty(subClass, \"prototype\", {\r\n    writable: false\r\n  });\r\n  if (superClass) setPrototypeOf(subClass, superClass);\r\n}\r\n\r\nmodule.exports = _inherits, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 7 */\r\n/***/ (function(module, exports, __nested_webpack_require_7965__) {\r\n\r\nmodule.exports = {\r\n  EPSILON: __nested_webpack_require_7965__(62),\r\n  create: __nested_webpack_require_7965__(63),\r\n  clone: __nested_webpack_require_7965__(156),\r\n  fromValues: __nested_webpack_require_7965__(157),\r\n  copy: __nested_webpack_require_7965__(158),\r\n  set: __nested_webpack_require_7965__(159),\r\n  equals: __nested_webpack_require_7965__(160),\r\n  exactEquals: __nested_webpack_require_7965__(161),\r\n  add: __nested_webpack_require_7965__(162),\r\n  subtract: __nested_webpack_require_7965__(64),\r\n  sub: __nested_webpack_require_7965__(163),\r\n  multiply: __nested_webpack_require_7965__(65),\r\n  mul: __nested_webpack_require_7965__(164),\r\n  divide: __nested_webpack_require_7965__(66),\r\n  div: __nested_webpack_require_7965__(165),\r\n  inverse: __nested_webpack_require_7965__(166),\r\n  min: __nested_webpack_require_7965__(167),\r\n  max: __nested_webpack_require_7965__(168),\r\n  rotate: __nested_webpack_require_7965__(169),\r\n  floor: __nested_webpack_require_7965__(170),\r\n  ceil: __nested_webpack_require_7965__(171),\r\n  round: __nested_webpack_require_7965__(172),\r\n  scale: __nested_webpack_require_7965__(173),\r\n  scaleAndAdd: __nested_webpack_require_7965__(174),\r\n  distance: __nested_webpack_require_7965__(67),\r\n  dist: __nested_webpack_require_7965__(175),\r\n  squaredDistance: __nested_webpack_require_7965__(68),\r\n  sqrDist: __nested_webpack_require_7965__(176),\r\n  length: __nested_webpack_require_7965__(69),\r\n  len: __nested_webpack_require_7965__(177),\r\n  squaredLength: __nested_webpack_require_7965__(70),\r\n  sqrLen: __nested_webpack_require_7965__(178),\r\n  negate: __nested_webpack_require_7965__(179),\r\n  normalize: __nested_webpack_require_7965__(180),\r\n  dot: __nested_webpack_require_7965__(181),\r\n  cross: __nested_webpack_require_7965__(182),\r\n  lerp: __nested_webpack_require_7965__(183),\r\n  random: __nested_webpack_require_7965__(184),\r\n  transformMat2: __nested_webpack_require_7965__(185),\r\n  transformMat2d: __nested_webpack_require_7965__(186),\r\n  transformMat3: __nested_webpack_require_7965__(187),\r\n  transformMat4: __nested_webpack_require_7965__(188),\r\n  forEach: __nested_webpack_require_7965__(189),\r\n  limit: __nested_webpack_require_7965__(190)\r\n};\r\n\r\n/***/ }),\r\n/* 8 */\r\n/***/ (function(module, exports, __nested_webpack_require_9719__) {\r\n\r\nmodule.exports = __nested_webpack_require_9719__(224);\r\n\r\n/***/ }),\r\n/* 9 */\r\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_9856__) {\r\n\r\n\"use strict\";\r\n\r\n// EXPORTS\r\n__nested_webpack_require_9856__.d(__webpack_exports__, \"h\", function() { return /* binding */ imageRef; });\r\n__nested_webpack_require_9856__.d(__webpack_exports__, \"i\", function() { return /* binding */ otsuThreshold; });\r\n__nested_webpack_require_9856__.d(__webpack_exports__, \"b\", function() { return /* binding */ cv_utils_cluster; });\r\n__nested_webpack_require_9856__.d(__webpack_exports__, \"j\", function() { return /* binding */ topGeneric; });\r\n__nested_webpack_require_9856__.d(__webpack_exports__, \"e\", function() { return /* binding */ grayAndHalfSampleFromCanvasData; });\r\n__nested_webpack_require_9856__.d(__webpack_exports__, \"c\", function() { return /* binding */ computeGray; });\r\n__nested_webpack_require_9856__.d(__webpack_exports__, \"f\", function() { return /* binding */ halfSample; });\r\n__nested_webpack_require_9856__.d(__webpack_exports__, \"g\", function() { return /* binding */ hsv2rgb; });\r\n__nested_webpack_require_9856__.d(__webpack_exports__, \"a\", function() { return /* binding */ calculatePatchSize; });\r\n__nested_webpack_require_9856__.d(__webpack_exports__, \"d\", function() { return /* binding */ computeImageArea; });\r\n\r\n// UNUSED EXPORTS: computeIntegralImage2, computeIntegralImage, thresholdImage, computeHistogram, sharpenLine, determineOtsuThreshold, computeBinaryImage, Tracer, DILATE, ERODE, dilate, erode, subtract, bitwiseOr, countNonZero, grayArrayFromImage, grayArrayFromContext, loadImageArray, _computeDivisors, _parseCSSDimensionValues, _dimensionsConverters\r\n\r\n// EXTERNAL MODULE: ./node_modules/gl-vec2/index.js\r\nvar gl_vec2 = __nested_webpack_require_9856__(7);\r\n\r\n// EXTERNAL MODULE: ./node_modules/gl-vec3/index.js\r\nvar gl_vec3 = __nested_webpack_require_9856__(84);\r\n\r\n// CONCATENATED MODULE: ./src/common/cluster.js\r\n// TODO: cluster.js and cv_utils.js are pretty tightly intertwined, making for a complex conversion\r\n// into typescript. be warned. :-)\r\n\r\nvar vec2 = {\r\n  clone: gl_vec2[\"clone\"],\r\n  dot: gl_vec2[\"dot\"]\r\n};\r\n/**\r\n * Creates a cluster for grouping similar orientations of datapoints\r\n */\r\n\r\n/* harmony default export */ var cluster = ({\r\n  create: function create(point, threshold) {\r\n    var points = [];\r\n    var center = {\r\n      rad: 0,\r\n      vec: vec2.clone([0, 0])\r\n    };\r\n    var pointMap = {};\r\n\r\n    function _add(pointToAdd) {\r\n      pointMap[pointToAdd.id] = pointToAdd;\r\n      points.push(pointToAdd);\r\n    }\r\n\r\n    function updateCenter() {\r\n      var i;\r\n      var sum = 0;\r\n\r\n      for (i = 0; i < points.length; i++) {\r\n        sum += points[i].rad;\r\n      }\r\n\r\n      center.rad = sum / points.length;\r\n      center.vec = vec2.clone([Math.cos(center.rad), Math.sin(center.rad)]);\r\n    }\r\n\r\n    function init() {\r\n      _add(point);\r\n\r\n      updateCenter();\r\n    }\r\n\r\n    init();\r\n    return {\r\n      add: function add(pointToAdd) {\r\n        if (!pointMap[pointToAdd.id]) {\r\n          _add(pointToAdd);\r\n\r\n          updateCenter();\r\n        }\r\n      },\r\n      fits: function fits(otherPoint) {\r\n        // check cosine similarity to center-angle\r\n        var similarity = Math.abs(vec2.dot(otherPoint.point.vec, center.vec));\r\n\r\n        if (similarity > threshold) {\r\n          return true;\r\n        }\r\n\r\n        return false;\r\n      },\r\n      getPoints: function getPoints() {\r\n        return points;\r\n      },\r\n      getCenter: function getCenter() {\r\n        return center;\r\n      }\r\n    };\r\n  },\r\n  createPoint: function createPoint(newPoint, id, property) {\r\n    return {\r\n      rad: newPoint[property],\r\n      point: newPoint,\r\n      id: id\r\n    };\r\n  }\r\n});\r\n// EXTERNAL MODULE: ./src/common/array_helper.ts\r\nvar array_helper = __nested_webpack_require_9856__(11);\r\n\r\n// CONCATENATED MODULE: ./src/common/cv_utils.js\r\n/* eslint-disable no-mixed-operators */\r\n\r\n/* eslint-disable no-bitwise */\r\n\r\n\r\n\r\n\r\nvar cv_utils_vec2 = {\r\n  clone: gl_vec2[\"clone\"]\r\n};\r\nvar vec3 = {\r\n  clone: gl_vec3[\"clone\"]\r\n};\r\n/**\r\n * @param x x-coordinate\r\n * @param y y-coordinate\r\n * @return ImageReference {x,y} Coordinate\r\n */\r\n\r\nfunction imageRef(x, y) {\r\n  var that = {\r\n    x: x,\r\n    y: y,\r\n    toVec2: function toVec2() {\r\n      return cv_utils_vec2.clone([this.x, this.y]);\r\n    },\r\n    toVec3: function toVec3() {\r\n      return vec3.clone([this.x, this.y, 1]);\r\n    },\r\n    round: function round() {\r\n      this.x = this.x > 0.0 ? Math.floor(this.x + 0.5) : Math.floor(this.x - 0.5);\r\n      this.y = this.y > 0.0 ? Math.floor(this.y + 0.5) : Math.floor(this.y - 0.5);\r\n      return this;\r\n    }\r\n  };\r\n  return that;\r\n}\r\n/**\r\n * Computes an integral image of a given grayscale image.\r\n * @param imageDataContainer {ImageDataContainer} the image to be integrated\r\n */\r\n\r\nfunction computeIntegralImage2(imageWrapper, integralWrapper) {\r\n  var imageData = imageWrapper.data;\r\n  var width = imageWrapper.size.x;\r\n  var height = imageWrapper.size.y;\r\n  var integralImageData = integralWrapper.data;\r\n  var sum = 0;\r\n  var posA = 0;\r\n  var posB = 0;\r\n  var posC = 0;\r\n  var posD = 0;\r\n  var x;\r\n  var y; // sum up first column\r\n\r\n  posB = width;\r\n  sum = 0;\r\n\r\n  for (y = 1; y < height; y++) {\r\n    sum += imageData[posA];\r\n    integralImageData[posB] += sum;\r\n    posA += width;\r\n    posB += width;\r\n  }\r\n\r\n  posA = 0;\r\n  posB = 1;\r\n  sum = 0;\r\n\r\n  for (x = 1; x < width; x++) {\r\n    sum += imageData[posA];\r\n    integralImageData[posB] += sum;\r\n    posA++;\r\n    posB++;\r\n  }\r\n\r\n  for (y = 1; y < height; y++) {\r\n    posA = y * width + 1;\r\n    posB = (y - 1) * width + 1;\r\n    posC = y * width;\r\n    posD = (y - 1) * width;\r\n\r\n    for (x = 1; x < width; x++) {\r\n      integralImageData[posA] += imageData[posA] + integralImageData[posB] + integralImageData[posC] - integralImageData[posD];\r\n      posA++;\r\n      posB++;\r\n      posC++;\r\n      posD++;\r\n    }\r\n  }\r\n}\r\nfunction computeIntegralImage(imageWrapper, integralWrapper) {\r\n  var imageData = imageWrapper.data;\r\n  var width = imageWrapper.size.x;\r\n  var height = imageWrapper.size.y;\r\n  var integralImageData = integralWrapper.data;\r\n  var sum = 0; // sum up first row\r\n\r\n  for (var i = 0; i < width; i++) {\r\n    sum += imageData[i];\r\n    integralImageData[i] = sum;\r\n  }\r\n\r\n  for (var v = 1; v < height; v++) {\r\n    sum = 0;\r\n\r\n    for (var u = 0; u < width; u++) {\r\n      sum += imageData[v * width + u];\r\n      integralImageData[v * width + u] = sum + integralImageData[(v - 1) * width + u];\r\n    }\r\n  }\r\n}\r\nfunction thresholdImage(imageWrapper, threshold, targetWrapper) {\r\n  if (!targetWrapper) {\r\n    // eslint-disable-next-line no-param-reassign\r\n    targetWrapper = imageWrapper;\r\n  }\r\n\r\n  var imageData = imageWrapper.data;\r\n  var length = imageData.length;\r\n  var targetData = targetWrapper.data;\r\n\r\n  while (length--) {\r\n    targetData[length] = imageData[length] < threshold ? 1 : 0;\r\n  }\r\n}\r\nfunction computeHistogram(imageWrapper, bitsPerPixel) {\r\n  if (!bitsPerPixel) {\r\n    // eslint-disable-next-line no-param-reassign\r\n    bitsPerPixel = 8;\r\n  }\r\n\r\n  var imageData = imageWrapper.data;\r\n  var length = imageData.length;\r\n  var bitShift = 8 - bitsPerPixel;\r\n  var bucketCnt = 1 << bitsPerPixel;\r\n  var hist = new Int32Array(bucketCnt);\r\n\r\n  while (length--) {\r\n    hist[imageData[length] >> bitShift]++;\r\n  }\r\n\r\n  return hist;\r\n}\r\nfunction sharpenLine(line) {\r\n  var i;\r\n  var length = line.length;\r\n  var left = line[0];\r\n  var center = line[1];\r\n  var right;\r\n\r\n  for (i = 1; i < length - 1; i++) {\r\n    right = line[i + 1]; //  -1 4 -1 kernel\r\n    // eslint-disable-next-line no-param-reassign\r\n\r\n    line[i - 1] = center * 2 - left - right & 255;\r\n    left = center;\r\n    center = right;\r\n  }\r\n\r\n  return line;\r\n}\r\nfunction determineOtsuThreshold(imageWrapper) {\r\n  var bitsPerPixel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;\r\n  var hist;\r\n  var bitShift = 8 - bitsPerPixel;\r\n\r\n  function px(init, end) {\r\n    var sum = 0;\r\n\r\n    for (var i = init; i <= end; i++) {\r\n      sum += hist[i];\r\n    }\r\n\r\n    return sum;\r\n  }\r\n\r\n  function mx(init, end) {\r\n    var sum = 0;\r\n\r\n    for (var i = init; i <= end; i++) {\r\n      sum += i * hist[i];\r\n    }\r\n\r\n    return sum;\r\n  }\r\n\r\n  function determineThreshold() {\r\n    var vet = [0];\r\n    var p1;\r\n    var p2;\r\n    var p12;\r\n    var m1;\r\n    var m2;\r\n    var m12;\r\n    var max = (1 << bitsPerPixel) - 1;\r\n    hist = computeHistogram(imageWrapper, bitsPerPixel);\r\n\r\n    for (var k = 1; k < max; k++) {\r\n      p1 = px(0, k);\r\n      p2 = px(k + 1, max);\r\n      p12 = p1 * p2;\r\n\r\n      if (p12 === 0) {\r\n        p12 = 1;\r\n      }\r\n\r\n      m1 = mx(0, k) * p2;\r\n      m2 = mx(k + 1, max) * p1;\r\n      m12 = m1 - m2;\r\n      vet[k] = m12 * m12 / p12;\r\n    }\r\n\r\n    return array_helper[\"a\" /* default */].maxIndex(vet);\r\n  }\r\n\r\n  var threshold = determineThreshold();\r\n  return threshold << bitShift;\r\n}\r\nfunction otsuThreshold(imageWrapper, targetWrapper) {\r\n  var threshold = determineOtsuThreshold(imageWrapper);\r\n  thresholdImage(imageWrapper, threshold, targetWrapper);\r\n  return threshold;\r\n} // local thresholding\r\n\r\nfunction computeBinaryImage(imageWrapper, integralWrapper, targetWrapper) {\r\n  computeIntegralImage(imageWrapper, integralWrapper);\r\n\r\n  if (!targetWrapper) {\r\n    // eslint-disable-next-line no-param-reassign\r\n    targetWrapper = imageWrapper;\r\n  }\r\n\r\n  var imageData = imageWrapper.data;\r\n  var targetData = targetWrapper.data;\r\n  var width = imageWrapper.size.x;\r\n  var height = imageWrapper.size.y;\r\n  var integralImageData = integralWrapper.data;\r\n  var sum = 0;\r\n  var v;\r\n  var u;\r\n  var kernel = 3;\r\n  var A;\r\n  var B;\r\n  var C;\r\n  var D;\r\n  var avg;\r\n  var size = (kernel * 2 + 1) * (kernel * 2 + 1); // clear out top & bottom-border\r\n\r\n  for (v = 0; v <= kernel; v++) {\r\n    for (u = 0; u < width; u++) {\r\n      targetData[v * width + u] = 0;\r\n      targetData[(height - 1 - v) * width + u] = 0;\r\n    }\r\n  } // clear out left & right border\r\n\r\n\r\n  for (v = kernel; v < height - kernel; v++) {\r\n    for (u = 0; u <= kernel; u++) {\r\n      targetData[v * width + u] = 0;\r\n      targetData[v * width + (width - 1 - u)] = 0;\r\n    }\r\n  }\r\n\r\n  for (v = kernel + 1; v < height - kernel - 1; v++) {\r\n    for (u = kernel + 1; u < width - kernel; u++) {\r\n      A = integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];\r\n      B = integralImageData[(v - kernel - 1) * width + (u + kernel)];\r\n      C = integralImageData[(v + kernel) * width + (u - kernel - 1)];\r\n      D = integralImageData[(v + kernel) * width + (u + kernel)];\r\n      sum = D - C - B + A;\r\n      avg = sum / size;\r\n      targetData[v * width + u] = imageData[v * width + u] > avg + 5 ? 0 : 1;\r\n    }\r\n  }\r\n}\r\nfunction cv_utils_cluster(points, threshold, property) {\r\n  var i;\r\n  var k;\r\n  var thisCluster;\r\n  var point;\r\n  var clusters = [];\r\n\r\n  if (!property) {\r\n    // eslint-disable-next-line no-param-reassign\r\n    property = 'rad';\r\n  }\r\n\r\n  function addToCluster(newPoint) {\r\n    var found = false;\r\n\r\n    for (k = 0; k < clusters.length; k++) {\r\n      thisCluster = clusters[k];\r\n\r\n      if (thisCluster.fits(newPoint)) {\r\n        thisCluster.add(newPoint);\r\n        found = true;\r\n      }\r\n    }\r\n\r\n    return found;\r\n  } // iterate over each cloud\r\n\r\n\r\n  for (i = 0; i < points.length; i++) {\r\n    point = cluster.createPoint(points[i], i, property);\r\n\r\n    if (!addToCluster(point)) {\r\n      clusters.push(cluster.create(point, threshold));\r\n    }\r\n  }\r\n\r\n  return clusters;\r\n}\r\nvar Tracer = {\r\n  trace: function trace(points, vec) {\r\n    var iteration;\r\n    var maxIterations = 10;\r\n    var top = [];\r\n    var result = [];\r\n    var centerPos = 0;\r\n    var currentPos = 0;\r\n\r\n    function trace(idx, forward) {\r\n      var to;\r\n      var toIdx;\r\n      var predictedPos;\r\n      var thresholdX = 1;\r\n      var thresholdY = Math.abs(vec[1] / 10);\r\n      var found = false;\r\n\r\n      function match(pos, predicted) {\r\n        if (pos.x > predicted.x - thresholdX && pos.x < predicted.x + thresholdX && pos.y > predicted.y - thresholdY && pos.y < predicted.y + thresholdY) {\r\n          return true;\r\n        }\r\n\r\n        return false;\r\n      } // check if the next index is within the vec specifications\r\n      // if not, check as long as the threshold is met\r\n\r\n\r\n      var from = points[idx];\r\n\r\n      if (forward) {\r\n        predictedPos = {\r\n          x: from.x + vec[0],\r\n          y: from.y + vec[1]\r\n        };\r\n      } else {\r\n        predictedPos = {\r\n          x: from.x - vec[0],\r\n          y: from.y - vec[1]\r\n        };\r\n      }\r\n\r\n      toIdx = forward ? idx + 1 : idx - 1;\r\n      to = points[toIdx]; // eslint-disable-next-line no-cond-assign\r\n\r\n      while (to && (found = match(to, predictedPos)) !== true && Math.abs(to.y - from.y) < vec[1]) {\r\n        toIdx = forward ? toIdx + 1 : toIdx - 1;\r\n        to = points[toIdx];\r\n      }\r\n\r\n      return found ? toIdx : null;\r\n    }\r\n\r\n    for (iteration = 0; iteration < maxIterations; iteration++) {\r\n      // randomly select point to start with\r\n      centerPos = Math.floor(Math.random() * points.length); // trace forward\r\n\r\n      top = [];\r\n      currentPos = centerPos;\r\n      top.push(points[currentPos]); // eslint-disable-next-line no-cond-assign\r\n\r\n      while ((currentPos = trace(currentPos, true)) !== null) {\r\n        top.push(points[currentPos]);\r\n      }\r\n\r\n      if (centerPos > 0) {\r\n        currentPos = centerPos; // eslint-disable-next-line no-cond-assign\r\n\r\n        while ((currentPos = trace(currentPos, false)) !== null) {\r\n          top.push(points[currentPos]);\r\n        }\r\n      }\r\n\r\n      if (top.length > result.length) {\r\n        result = top;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n};\r\nvar DILATE = 1;\r\nvar ERODE = 2;\r\nfunction dilate(inImageWrapper, outImageWrapper) {\r\n  var v;\r\n  var u;\r\n  var inImageData = inImageWrapper.data;\r\n  var outImageData = outImageWrapper.data;\r\n  var height = inImageWrapper.size.y;\r\n  var width = inImageWrapper.size.x;\r\n  var sum;\r\n  var yStart1;\r\n  var yStart2;\r\n  var xStart1;\r\n  var xStart2;\r\n\r\n  for (v = 1; v < height - 1; v++) {\r\n    for (u = 1; u < width - 1; u++) {\r\n      yStart1 = v - 1;\r\n      yStart2 = v + 1;\r\n      xStart1 = u - 1;\r\n      xStart2 = u + 1;\r\n      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];\r\n      outImageData[v * width + u] = sum > 0 ? 1 : 0;\r\n    }\r\n  }\r\n}\r\nfunction erode(inImageWrapper, outImageWrapper) {\r\n  var v;\r\n  var u;\r\n  var inImageData = inImageWrapper.data;\r\n  var outImageData = outImageWrapper.data;\r\n  var height = inImageWrapper.size.y;\r\n  var width = inImageWrapper.size.x;\r\n  var sum;\r\n  var yStart1;\r\n  var yStart2;\r\n  var xStart1;\r\n  var xStart2;\r\n\r\n  for (v = 1; v < height - 1; v++) {\r\n    for (u = 1; u < width - 1; u++) {\r\n      yStart1 = v - 1;\r\n      yStart2 = v + 1;\r\n      xStart1 = u - 1;\r\n      xStart2 = u + 1;\r\n      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];\r\n      outImageData[v * width + u] = sum === 5 ? 1 : 0;\r\n    }\r\n  }\r\n}\r\nfunction subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {\r\n  if (!resultImageWrapper) {\r\n    // eslint-disable-next-line no-param-reassign\r\n    resultImageWrapper = aImageWrapper;\r\n  }\r\n\r\n  var length = aImageWrapper.data.length;\r\n  var aImageData = aImageWrapper.data;\r\n  var bImageData = bImageWrapper.data;\r\n  var cImageData = resultImageWrapper.data;\r\n\r\n  while (length--) {\r\n    cImageData[length] = aImageData[length] - bImageData[length];\r\n  }\r\n}\r\nfunction bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {\r\n  if (!resultImageWrapper) {\r\n    // eslint-disable-next-line no-param-reassign\r\n    resultImageWrapper = aImageWrapper;\r\n  }\r\n\r\n  var length = aImageWrapper.data.length;\r\n  var aImageData = aImageWrapper.data;\r\n  var bImageData = bImageWrapper.data;\r\n  var cImageData = resultImageWrapper.data;\r\n\r\n  while (length--) {\r\n    cImageData[length] = aImageData[length] || bImageData[length];\r\n  }\r\n}\r\nfunction countNonZero(imageWrapper) {\r\n  var length = imageWrapper.data.length;\r\n  var data = imageWrapper.data;\r\n  var sum = 0;\r\n\r\n  while (length--) {\r\n    sum += data[length];\r\n  }\r\n\r\n  return sum;\r\n}\r\nfunction topGeneric(list, top, scoreFunc) {\r\n  var i;\r\n  var minIdx = 0;\r\n  var min = 0;\r\n  var queue = [];\r\n  var score;\r\n  var hit;\r\n  var pos;\r\n\r\n  for (i = 0; i < top; i++) {\r\n    queue[i] = {\r\n      score: 0,\r\n      item: null\r\n    };\r\n  }\r\n\r\n  for (i = 0; i < list.length; i++) {\r\n    score = scoreFunc.apply(this, [list[i]]);\r\n\r\n    if (score > min) {\r\n      hit = queue[minIdx];\r\n      hit.score = score;\r\n      hit.item = list[i];\r\n      min = Number.MAX_VALUE;\r\n\r\n      for (pos = 0; pos < top; pos++) {\r\n        if (queue[pos].score < min) {\r\n          min = queue[pos].score;\r\n          minIdx = pos;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return queue;\r\n}\r\nfunction grayArrayFromImage(htmlImage, offsetX, ctx, array) {\r\n  ctx.drawImage(htmlImage, offsetX, 0, htmlImage.width, htmlImage.height);\r\n  var ctxData = ctx.getImageData(offsetX, 0, htmlImage.width, htmlImage.height).data;\r\n  computeGray(ctxData, array);\r\n}\r\nfunction grayArrayFromContext(ctx, size, offset, array) {\r\n  var ctxData = ctx.getImageData(offset.x, offset.y, size.x, size.y).data;\r\n  computeGray(ctxData, array);\r\n}\r\nfunction grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {\r\n  var topRowIdx = 0;\r\n  var bottomRowIdx = size.x;\r\n  var endIdx = Math.floor(canvasData.length / 4);\r\n  var outWidth = size.x / 2;\r\n  var outImgIdx = 0;\r\n  var inWidth = size.x;\r\n  var i;\r\n\r\n  while (bottomRowIdx < endIdx) {\r\n    for (i = 0; i < outWidth; i++) {\r\n      // eslint-disable-next-line no-param-reassign\r\n      outArray[outImgIdx] = (0.299 * canvasData[topRowIdx * 4 + 0] + 0.587 * canvasData[topRowIdx * 4 + 1] + 0.114 * canvasData[topRowIdx * 4 + 2] + (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(topRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) + (0.299 * canvasData[bottomRowIdx * 4 + 0] + 0.587 * canvasData[bottomRowIdx * 4 + 1] + 0.114 * canvasData[bottomRowIdx * 4 + 2]) + (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) / 4;\r\n      outImgIdx++;\r\n      topRowIdx += 2;\r\n      bottomRowIdx += 2;\r\n    }\r\n\r\n    topRowIdx += inWidth;\r\n    bottomRowIdx += inWidth;\r\n  }\r\n}\r\nfunction computeGray(imageData, outArray, config) {\r\n  var l = imageData.length / 4 | 0;\r\n  var singleChannel = config && config.singleChannel === true;\r\n\r\n  if (singleChannel) {\r\n    for (var i = 0; i < l; i++) {\r\n      // eslint-disable-next-line no-param-reassign\r\n      outArray[i] = imageData[i * 4 + 0];\r\n    }\r\n  } else {\r\n    for (var _i = 0; _i < l; _i++) {\r\n      // eslint-disable-next-line no-param-reassign\r\n      outArray[_i] = 0.299 * imageData[_i * 4 + 0] + 0.587 * imageData[_i * 4 + 1] + 0.114 * imageData[_i * 4 + 2];\r\n    }\r\n  }\r\n}\r\nfunction loadImageArray(src, callback) {\r\n  var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document && document.createElement('canvas');\r\n  var img = new Image();\r\n  img.callback = callback;\r\n\r\n  img.onload = function () {\r\n    // eslint-disable-next-line no-param-reassign\r\n    canvas.width = this.width; // eslint-disable-next-line no-param-reassign\r\n\r\n    canvas.height = this.height;\r\n    var ctx = canvas.getContext('2d');\r\n    ctx.drawImage(this, 0, 0);\r\n    var array = new Uint8Array(this.width * this.height);\r\n    ctx.drawImage(this, 0, 0);\r\n\r\n    var _ctx$getImageData = ctx.getImageData(0, 0, this.width, this.height),\r\n        data = _ctx$getImageData.data;\r\n\r\n    computeGray(data, array);\r\n    this.callback(array, {\r\n      x: this.width,\r\n      y: this.height\r\n    }, this);\r\n  };\r\n\r\n  img.src = src;\r\n}\r\n/**\r\n * @param inImg {ImageWrapper} input image to be sampled\r\n * @param outImg {ImageWrapper} to be stored in\r\n */\r\n\r\nfunction halfSample(inImgWrapper, outImgWrapper) {\r\n  var inImg = inImgWrapper.data;\r\n  var inWidth = inImgWrapper.size.x;\r\n  var outImg = outImgWrapper.data;\r\n  var topRowIdx = 0;\r\n  var bottomRowIdx = inWidth;\r\n  var endIdx = inImg.length;\r\n  var outWidth = inWidth / 2;\r\n  var outImgIdx = 0;\r\n\r\n  while (bottomRowIdx < endIdx) {\r\n    for (var i = 0; i < outWidth; i++) {\r\n      outImg[outImgIdx] = Math.floor((inImg[topRowIdx] + inImg[topRowIdx + 1] + inImg[bottomRowIdx] + inImg[bottomRowIdx + 1]) / 4);\r\n      outImgIdx++;\r\n      topRowIdx += 2;\r\n      bottomRowIdx += 2;\r\n    }\r\n\r\n    topRowIdx += inWidth;\r\n    bottomRowIdx += inWidth;\r\n  }\r\n}\r\nfunction hsv2rgb(hsv) {\r\n  var rgb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];\r\n  var h = hsv[0];\r\n  var s = hsv[1];\r\n  var v = hsv[2];\r\n  var c = v * s;\r\n  var x = c * (1 - Math.abs(h / 60 % 2 - 1));\r\n  var m = v - c;\r\n  var r = 0;\r\n  var g = 0;\r\n  var b = 0;\r\n\r\n  if (h < 60) {\r\n    r = c;\r\n    g = x;\r\n  } else if (h < 120) {\r\n    r = x;\r\n    g = c;\r\n  } else if (h < 180) {\r\n    g = c;\r\n    b = x;\r\n  } else if (h < 240) {\r\n    g = x;\r\n    b = c;\r\n  } else if (h < 300) {\r\n    r = x;\r\n    b = c;\r\n  } else if (h < 360) {\r\n    r = c;\r\n    b = x;\r\n  } // eslint-disable-next-line no-param-reassign\r\n\r\n\r\n  rgb[0] = (r + m) * 255 | 0; // eslint-disable-next-line no-param-reassign\r\n\r\n  rgb[1] = (g + m) * 255 | 0; // eslint-disable-next-line no-param-reassign\r\n\r\n  rgb[2] = (b + m) * 255 | 0;\r\n  return rgb;\r\n}\r\nfunction _computeDivisors(n) {\r\n  var largeDivisors = [];\r\n  var divisors = [];\r\n\r\n  for (var i = 1; i < Math.sqrt(n) + 1; i++) {\r\n    if (n % i === 0) {\r\n      divisors.push(i);\r\n\r\n      if (i !== n / i) {\r\n        largeDivisors.unshift(Math.floor(n / i));\r\n      }\r\n    }\r\n  }\r\n\r\n  return divisors.concat(largeDivisors);\r\n}\r\n\r\nfunction _computeIntersection(arr1, arr2) {\r\n  var i = 0;\r\n  var j = 0;\r\n  var result = [];\r\n\r\n  while (i < arr1.length && j < arr2.length) {\r\n    if (arr1[i] === arr2[j]) {\r\n      result.push(arr1[i]);\r\n      i++;\r\n      j++;\r\n    } else if (arr1[i] > arr2[j]) {\r\n      j++;\r\n    } else {\r\n      i++;\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction calculatePatchSize(patchSize, imgSize) {\r\n  var divisorsX = _computeDivisors(imgSize.x);\r\n\r\n  var divisorsY = _computeDivisors(imgSize.y);\r\n\r\n  var wideSide = Math.max(imgSize.x, imgSize.y);\r\n\r\n  var common = _computeIntersection(divisorsX, divisorsY);\r\n\r\n  var nrOfPatchesList = [8, 10, 15, 20, 32, 60, 80];\r\n  var nrOfPatchesMap = {\r\n    'x-small': 5,\r\n    small: 4,\r\n    medium: 3,\r\n    large: 2,\r\n    'x-large': 1\r\n  };\r\n  var nrOfPatchesIdx = nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium;\r\n  var nrOfPatches = nrOfPatchesList[nrOfPatchesIdx];\r\n  var desiredPatchSize = Math.floor(wideSide / nrOfPatches);\r\n  var optimalPatchSize;\r\n\r\n  function findPatchSizeForDivisors(divisors) {\r\n    var i = 0;\r\n    var found = divisors[Math.floor(divisors.length / 2)];\r\n\r\n    while (i < divisors.length - 1 && divisors[i] < desiredPatchSize) {\r\n      i++;\r\n    }\r\n\r\n    if (i > 0) {\r\n      if (Math.abs(divisors[i] - desiredPatchSize) > Math.abs(divisors[i - 1] - desiredPatchSize)) {\r\n        found = divisors[i - 1];\r\n      } else {\r\n        found = divisors[i];\r\n      }\r\n    }\r\n\r\n    if (desiredPatchSize / found < nrOfPatchesList[nrOfPatchesIdx + 1] / nrOfPatchesList[nrOfPatchesIdx] && desiredPatchSize / found > nrOfPatchesList[nrOfPatchesIdx - 1] / nrOfPatchesList[nrOfPatchesIdx]) {\r\n      return {\r\n        x: found,\r\n        y: found\r\n      };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  optimalPatchSize = findPatchSizeForDivisors(common);\r\n\r\n  if (!optimalPatchSize) {\r\n    optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(wideSide));\r\n\r\n    if (!optimalPatchSize) {\r\n      optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(desiredPatchSize * nrOfPatches));\r\n    }\r\n  }\r\n\r\n  return optimalPatchSize;\r\n}\r\nfunction _parseCSSDimensionValues(value) {\r\n  var dimension = {\r\n    value: parseFloat(value),\r\n    unit: value.indexOf('%') === value.length - 1 ? '%' : '%'\r\n  };\r\n  return dimension;\r\n}\r\nvar _dimensionsConverters = {\r\n  top: function top(dimension, context) {\r\n    return dimension.unit === '%' ? Math.floor(context.height * (dimension.value / 100)) : null;\r\n  },\r\n  right: function right(dimension, context) {\r\n    return dimension.unit === '%' ? Math.floor(context.width - context.width * (dimension.value / 100)) : null;\r\n  },\r\n  bottom: function bottom(dimension, context) {\r\n    return dimension.unit === '%' ? Math.floor(context.height - context.height * (dimension.value / 100)) : null;\r\n  },\r\n  left: function left(dimension, context) {\r\n    return dimension.unit === '%' ? Math.floor(context.width * (dimension.value / 100)) : null;\r\n  }\r\n};\r\nfunction computeImageArea(inputWidth, inputHeight, area) {\r\n  var context = {\r\n    width: inputWidth,\r\n    height: inputHeight\r\n  };\r\n  var parsedArea = Object.keys(area).reduce(function (result, key) {\r\n    var value = area[key];\r\n\r\n    var parsed = _parseCSSDimensionValues(value);\r\n\r\n    var calculated = _dimensionsConverters[key](parsed, context); // eslint-disable-next-line no-param-reassign\r\n\r\n\r\n    result[key] = calculated;\r\n    return result;\r\n  }, {});\r\n  return {\r\n    sx: parsedArea.left,\r\n    sy: parsedArea.top,\r\n    sw: parsedArea.right - parsedArea.left,\r\n    sh: parsedArea.bottom - parsedArea.top\r\n  };\r\n}\r\n\r\n/***/ }),\r\n/* 10 */\r\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\r\n\r\n\"use strict\";\r\n// TODO: XYPosition should be an XYObject, but that breaks XYDefinition, which breaks drawPath() below.\r\n// XYDefinition tells us which component of a given array or object is the \"X\" and which is the \"Y\".\r\n// Usually this is 0 for X and 1 for Y, but might be used as 'x' for x and 'y' for Y.\r\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\r\n  drawRect: function drawRect(pos, size, ctx, style) {\r\n    ctx.strokeStyle = style.color;\r\n    ctx.fillStyle = style.color;\r\n    ctx.lineWidth = style.lineWidth || 1;\r\n    ctx.beginPath();\r\n    ctx.strokeRect(pos.x, pos.y, size.x, size.y);\r\n  },\r\n  drawPath: function drawPath(path, def, ctx, style) {\r\n    ctx.strokeStyle = style.color;\r\n    ctx.fillStyle = style.color;\r\n    ctx.lineWidth = style.lineWidth;\r\n    ctx.beginPath();\r\n    ctx.moveTo(path[0][def.x], path[0][def.y]);\r\n\r\n    for (var j = 1; j < path.length; j++) {\r\n      ctx.lineTo(path[j][def.x], path[j][def.y]);\r\n    }\r\n\r\n    ctx.closePath();\r\n    ctx.stroke();\r\n  },\r\n  drawImage: function drawImage(imageData, size, ctx) {\r\n    var canvasData = ctx.getImageData(0, 0, size.x, size.y);\r\n    var data = canvasData.data;\r\n    var canvasDataPos = data.length;\r\n    var imageDataPos = imageData.length;\r\n\r\n    if (canvasDataPos / imageDataPos !== 4) {\r\n      return false;\r\n    }\r\n\r\n    while (imageDataPos--) {\r\n      var value = imageData[imageDataPos];\r\n      data[--canvasDataPos] = 255;\r\n      data[--canvasDataPos] = value;\r\n      data[--canvasDataPos] = value;\r\n      data[--canvasDataPos] = value;\r\n    }\r\n\r\n    ctx.putImageData(canvasData, 0, 0);\r\n    return true;\r\n  }\r\n});\r\n\r\n/***/ }),\r\n/* 11 */\r\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\r\n\r\n\"use strict\";\r\n/* eslint-disable no-param-reassign */\r\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\r\n  init: function init(arr, val) {\r\n    arr.fill(val);\r\n  },\r\n\r\n  /**\r\n   * Shuffles the content of an array\r\n   */\r\n  shuffle: function shuffle(arr) {\r\n    // Durstenfeld shuffle algorithm\r\n    // https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\n    for (var i = arr.length - 1; i > 0; i--) {\r\n      var j = Math.floor(Math.random() * (i + 1));\r\n      var _ref = [arr[j], arr[i]];\r\n      arr[i] = _ref[0];\r\n      arr[j] = _ref[1];\r\n    }\r\n  },\r\n  toPointList: function toPointList(arr) {\r\n    var rows = arr.reduce(function (p, n) {\r\n      var row = \"[\".concat(n.join(','), \"]\");\r\n      p.push(row);\r\n      return p;\r\n    }, []);\r\n    return \"[\".concat(rows.join(',\\r\\n'), \"]\");\r\n  },\r\n\r\n  /**\r\n   * returns the elements which's score is bigger than the threshold\r\n   */\r\n  // eslint-disable-next-line no-unused-vars\r\n  threshold: function threshold(arr, _threshold, scoreFunc) {\r\n    var queue = arr.reduce(function (prev, next) {\r\n      if (scoreFunc.apply(arr, [next]) >= _threshold) {\r\n        prev.push(next);\r\n      }\r\n\r\n      return prev;\r\n    }, []);\r\n    return queue;\r\n  },\r\n  maxIndex: function maxIndex(arr) {\r\n    var max = 0;\r\n\r\n    for (var i = 0; i < arr.length; i++) {\r\n      if (arr[i] > arr[max]) {\r\n        max = i;\r\n      }\r\n    }\r\n\r\n    return max;\r\n  },\r\n  max: function max(arr) {\r\n    var max = 0;\r\n\r\n    for (var i = 0; i < arr.length; i++) {\r\n      if (arr[i] > max) {\r\n        max = arr[i];\r\n      }\r\n    }\r\n\r\n    return max;\r\n  },\r\n  sum: function sum(arr) {\r\n    var length = arr.length;\r\n    var sum = 0;\r\n\r\n    while (length--) {\r\n      sum += arr[length];\r\n    }\r\n\r\n    return sum;\r\n  }\r\n});\r\n\r\n/***/ }),\r\n/* 12 */\r\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_38733__) {\r\n\r\n\"use strict\";\r\n/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_38733__(83);\r\n/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_38733__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);\r\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_38733__(3);\r\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_38733__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);\r\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_38733__(4);\r\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_38733__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);\r\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_38733__(0);\r\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_38733__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__);\r\n/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_38733__(7);\r\n/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__nested_webpack_require_38733__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_4__);\r\n/* harmony import */ var _array_helper__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_38733__(11);\r\n/* harmony import */ var _cv_utils__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_38733__(9);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar vec2 = {\r\n  clone: gl_vec2__WEBPACK_IMPORTED_MODULE_4__[\"clone\"]\r\n};\r\n\r\nfunction assertNumberPositive(val) {\r\n  if (val < 0) {\r\n    throw new Error(\"expected positive number, received \".concat(val));\r\n  }\r\n}\r\n\r\nvar ImageWrapper = /*#__PURE__*/function () {\r\n  // Represents a basic image combining the data and size. In addition, some methods for\r\n  // manipulation are contained within.\r\n  function ImageWrapper(size, data) {\r\n    var ArrayType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Uint8Array;\r\n    var initialize = arguments.length > 3 ? arguments[3] : undefined;\r\n\r\n    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, ImageWrapper);\r\n\r\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, \"data\", void 0);\r\n\r\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, \"size\", void 0);\r\n\r\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, \"indexMapping\", void 0);\r\n\r\n    if (!data) {\r\n      this.data = new ArrayType(size.x * size.y);\r\n\r\n      if (initialize) {\r\n        _array_helper__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].init(this.data, 0);\r\n      }\r\n    } else {\r\n      this.data = data;\r\n    }\r\n\r\n    this.size = size;\r\n  } // tests if a position is within the image, extended out by a border on each side\r\n\r\n\r\n  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(ImageWrapper, [{\r\n    key: \"inImageWithBorder\",\r\n    value: function inImageWithBorder(imgRef) {\r\n      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\r\n      assertNumberPositive(border); // TODO: code_128 starts failing miserably when i only allow imgRef to contain positive numbers.\r\n      // TODO: this doesn't make much sense to me, why does it go negative?  Tests are not affected by\r\n      // returning false, but the whole code_128 reader blows up when i throw on negative imgRef.\r\n      // assertNumberPositive(imgRef.x);\r\n      // assertNumberPositive(imgRef.y);\r\n\r\n      return imgRef.x >= 0 && imgRef.y >= 0 && imgRef.x < this.size.x + border * 2 && imgRef.y < this.size.y + border * 2;\r\n    } // Copy from THIS ImageWrapper to the new imageWrapper parameter, starting at from, stopping at\r\n    // end of new imageWrapper size.\r\n\r\n  }, {\r\n    key: \"subImageAsCopy\",\r\n    value: function subImageAsCopy(imageWrapper, from) {\r\n      assertNumberPositive(from.x);\r\n      assertNumberPositive(from.y);\r\n      var _imageWrapper$size = imageWrapper.size,\r\n          sizeX = _imageWrapper$size.x,\r\n          sizeY = _imageWrapper$size.y;\r\n\r\n      for (var x = 0; x < sizeX; x++) {\r\n        for (var y = 0; y < sizeY; y++) {\r\n          // eslint-disable-next-line no-param-reassign\r\n          imageWrapper.data[y * sizeX + x] = this.data[(from.y + y) * this.size.x + from.x + x];\r\n        }\r\n      }\r\n\r\n      return imageWrapper; // TODO: this function really probably should call into ImageWrapper somewhere to make\r\n      // sure that all of it's parameters are set properly, something like\r\n      // ImageWrapper.UpdateFrom()\r\n      // that might take a provided data and size, and make sure there's no invalid indexMapping\r\n      // hanging around, and such.\r\n    } // Retrieve a grayscale value at the given pixel position of the image\r\n\r\n  }, {\r\n    key: \"get\",\r\n    value: function get(x, y) {\r\n      return this.data[y * this.size.x + x];\r\n    } // Retrieve a grayscale value at the given pixel position of the image (safe, whatever that\r\n    // means)\r\n\r\n  }, {\r\n    key: \"getSafe\",\r\n    value: function getSafe(x, y) {\r\n      // cache indexMapping because if we're using it once, we'll probably need it a bunch more\r\n      // too\r\n      if (!this.indexMapping) {\r\n        this.indexMapping = {\r\n          x: [],\r\n          y: []\r\n        };\r\n\r\n        for (var i = 0; i < this.size.x; i++) {\r\n          this.indexMapping.x[i] = i;\r\n          this.indexMapping.x[i + this.size.x] = i;\r\n        }\r\n\r\n        for (var _i = 0; _i < this.size.y; _i++) {\r\n          this.indexMapping.y[_i] = _i;\r\n          this.indexMapping.y[_i + this.size.y] = _i;\r\n        }\r\n      }\r\n\r\n      return this.data[this.indexMapping.y[y + this.size.y] * this.size.x + this.indexMapping.x[x + this.size.x]];\r\n    } // Sets a given pixel position in the image to the given grayscale value\r\n\r\n  }, {\r\n    key: \"set\",\r\n    value: function set(x, y, value) {\r\n      this.data[y * this.size.x + x] = value;\r\n      delete this.indexMapping;\r\n      return this;\r\n    } // Sets the border of the image (1 pixel) to zero\r\n\r\n  }, {\r\n    key: \"zeroBorder\",\r\n    value: function zeroBorder() {\r\n      var _this$size = this.size,\r\n          width = _this$size.x,\r\n          height = _this$size.y;\r\n\r\n      for (var i = 0; i < width; i++) {\r\n        // eslint-disable-next-line no-multi-assign\r\n        this.data[i] = this.data[(height - 1) * width + i] = 0;\r\n      }\r\n\r\n      for (var _i2 = 1; _i2 < height - 1; _i2++) {\r\n        // eslint-disable-next-line no-multi-assign\r\n        this.data[_i2 * width] = this.data[_i2 * width + (width - 1)] = 0;\r\n      }\r\n\r\n      delete this.indexMapping;\r\n      return this;\r\n    } // TODO: this function is entirely too large for me to reason out right at this moment that i'm handling\r\n    // all the rest of it, so this is a verbatim copy of the javascript source, with only tweaks\r\n    // necessary to get it to run, no thought put into it yet.\r\n\r\n  }, {\r\n    key: \"moments\",\r\n    value: function moments(labelCount) {\r\n      var data = this.data;\r\n      var x;\r\n      var y;\r\n      var height = this.size.y;\r\n      var width = this.size.x;\r\n      var val;\r\n      var ysq;\r\n      var labelSum = [];\r\n      var i;\r\n      var label;\r\n      var mu11;\r\n      var mu02;\r\n      var mu20;\r\n      var x_;\r\n      var y_;\r\n      var tmp;\r\n      var result = [];\r\n      var PI = Math.PI;\r\n      var PI_4 = PI / 4;\r\n\r\n      if (labelCount <= 0) {\r\n        return result;\r\n      }\r\n\r\n      for (i = 0; i < labelCount; i++) {\r\n        labelSum[i] = {\r\n          m00: 0,\r\n          m01: 0,\r\n          m10: 0,\r\n          m11: 0,\r\n          m02: 0,\r\n          m20: 0,\r\n          theta: 0,\r\n          rad: 0\r\n        };\r\n      }\r\n\r\n      for (y = 0; y < height; y++) {\r\n        ysq = y * y;\r\n\r\n        for (x = 0; x < width; x++) {\r\n          val = data[y * width + x];\r\n\r\n          if (val > 0) {\r\n            label = labelSum[val - 1];\r\n            label.m00 += 1;\r\n            label.m01 += y;\r\n            label.m10 += x;\r\n            label.m11 += x * y;\r\n            label.m02 += ysq;\r\n            label.m20 += x * x;\r\n          }\r\n        }\r\n      }\r\n\r\n      for (i = 0; i < labelCount; i++) {\r\n        label = labelSum[i]; // eslint-disable-next-line no-restricted-globals\r\n\r\n        if (!isNaN(label.m00) && label.m00 !== 0) {\r\n          x_ = label.m10 / label.m00;\r\n          y_ = label.m01 / label.m00;\r\n          mu11 = label.m11 / label.m00 - x_ * y_;\r\n          mu02 = label.m02 / label.m00 - y_ * y_;\r\n          mu20 = label.m20 / label.m00 - x_ * x_;\r\n          tmp = (mu02 - mu20) / (2 * mu11);\r\n          tmp = 0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI; // eslint-disable-next-line no-mixed-operators\r\n\r\n          label.theta = (tmp * 180 / PI + 90) % 180 - 90;\r\n\r\n          if (label.theta < 0) {\r\n            label.theta += 180;\r\n          }\r\n\r\n          label.rad = tmp > PI ? tmp - PI : tmp;\r\n          label.vec = vec2.clone([Math.cos(tmp), Math.sin(tmp)]);\r\n          result.push(label);\r\n        }\r\n      }\r\n\r\n      return result;\r\n    } // return a Uint8ClampedArray containing this grayscale image converted to RGBA form\r\n\r\n  }, {\r\n    key: \"getAsRGBA\",\r\n    value: function getAsRGBA() {\r\n      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;\r\n      var ret = new Uint8ClampedArray(4 * this.size.x * this.size.y);\r\n\r\n      for (var y = 0; y < this.size.y; y++) {\r\n        for (var x = 0; x < this.size.x; x++) {\r\n          var pixel = y * this.size.x + x;\r\n          var current = this.get(x, y) * scale;\r\n          ret[pixel * 4 + 0] = current;\r\n          ret[pixel * 4 + 1] = current;\r\n          ret[pixel * 4 + 2] = current;\r\n          ret[pixel * 4 + 3] = 255;\r\n        }\r\n      }\r\n\r\n      return ret;\r\n    } // Display this ImageWrapper in a given Canvas element at the specified scale\r\n\r\n  }, {\r\n    key: \"show\",\r\n    value: function show(canvas) {\r\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;\r\n      var ctx = canvas.getContext('2d');\r\n\r\n      if (!ctx) {\r\n        throw new Error('Unable to get canvas context');\r\n      }\r\n\r\n      var frame = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n      var data = this.getAsRGBA(scale); // eslint-disable-next-line no-param-reassign\r\n\r\n      canvas.width = this.size.x; // eslint-disable-next-line no-param-reassign\r\n\r\n      canvas.height = this.size.y;\r\n      var newFrame = new ImageData(data, frame.width, frame.height);\r\n      ctx.putImageData(newFrame, 0, 0);\r\n    } // Displays a specified SubImage area in a given canvas. This differs drastically from\r\n    // creating a new SubImage and using it's show() method. Why? I don't have the answer to that\r\n    // yet.  I suspect the HSV/RGB operations involved here are making it significantly different,\r\n    // but until I can visualize these functions side by side, I'm just going to copy the existing\r\n    // implementation.\r\n\r\n  }, {\r\n    key: \"overlay\",\r\n    value: function overlay(canvas, inScale, from) {\r\n      var adjustedScale = inScale < 0 || inScale > 360 ? 360 : inScale;\r\n      var hsv = [0, 1, 1];\r\n      var rgb = [0, 0, 0];\r\n      var whiteRgb = [255, 255, 255];\r\n      var blackRgb = [0, 0, 0];\r\n      var result = [];\r\n      var ctx = canvas.getContext('2d');\r\n\r\n      if (!ctx) {\r\n        throw new Error('Unable to get canvas context');\r\n      }\r\n\r\n      var frame = ctx.getImageData(from.x, from.y, this.size.x, this.size.y);\r\n      var data = frame.data;\r\n      var length = this.data.length;\r\n\r\n      while (length--) {\r\n        hsv[0] = this.data[length] * adjustedScale; // eslint-disable-next-line no-nested-ternary\r\n\r\n        result = hsv[0] <= 0 ? whiteRgb : hsv[0] >= 360 ? blackRgb : Object(_cv_utils__WEBPACK_IMPORTED_MODULE_6__[/* hsv2rgb */ \"g\"])(hsv, rgb);\r\n        var pos = length * 4;\r\n        var _result = result;\r\n\r\n        var _result2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_result, 3);\r\n\r\n        data[pos] = _result2[0];\r\n        data[pos + 1] = _result2[1];\r\n        data[pos + 2] = _result2[2];\r\n        data[pos + 3] = 255;\r\n      }\r\n\r\n      ctx.putImageData(frame, from.x, from.y);\r\n    }\r\n  }]);\r\n\r\n  return ImageWrapper;\r\n}();\r\n\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (ImageWrapper);\r\n\r\n/***/ }),\r\n/* 13 */\r\n/***/ (function(module, exports) {\r\n\r\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\r\n  try {\r\n    var info = gen[key](arg);\r\n    var value = info.value;\r\n  } catch (error) {\r\n    reject(error);\r\n    return;\r\n  }\r\n\r\n  if (info.done) {\r\n    resolve(value);\r\n  } else {\r\n    Promise.resolve(value).then(_next, _throw);\r\n  }\r\n}\r\n\r\nfunction _asyncToGenerator(fn) {\r\n  return function () {\r\n    var self = this,\r\n        args = arguments;\r\n    return new Promise(function (resolve, reject) {\r\n      var gen = fn.apply(self, args);\r\n\r\n      function _next(value) {\r\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\r\n      }\r\n\r\n      function _throw(err) {\r\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\r\n      }\r\n\r\n      _next(undefined);\r\n    });\r\n  };\r\n}\r\n\r\nmodule.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 14 */\r\n/***/ (function(module, exports, __nested_webpack_require_52386__) {\r\n\r\nvar superPropBase = __nested_webpack_require_52386__(225);\r\n\r\nfunction _get() {\r\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\r\n    module.exports = _get = Reflect.get, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n  } else {\r\n    module.exports = _get = function _get(target, property, receiver) {\r\n      var base = superPropBase(target, property);\r\n      if (!base) return;\r\n      var desc = Object.getOwnPropertyDescriptor(base, property);\r\n\r\n      if (desc.get) {\r\n        return desc.get.call(arguments.length < 3 ? target : receiver);\r\n      }\r\n\r\n      return desc.value;\r\n    }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n  }\r\n\r\n  return _get.apply(this, arguments);\r\n}\r\n\r\nmodule.exports = _get, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 15 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * Checks if `value` is the\r\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\r\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\r\n * @example\r\n *\r\n * _.isObject({});\r\n * // => true\r\n *\r\n * _.isObject([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isObject(_.noop);\r\n * // => true\r\n *\r\n * _.isObject(null);\r\n * // => false\r\n */\r\nfunction isObject(value) {\r\n  var type = typeof value;\r\n  return value != null && (type == 'object' || type == 'function');\r\n}\r\n\r\nmodule.exports = isObject;\r\n\r\n/***/ }),\r\n/* 16 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * Checks if `value` is classified as an `Array` object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\r\n * @example\r\n *\r\n * _.isArray([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isArray(document.body.children);\r\n * // => false\r\n *\r\n * _.isArray('abc');\r\n * // => false\r\n *\r\n * _.isArray(_.noop);\r\n * // => false\r\n */\r\nvar isArray = Array.isArray;\r\nmodule.exports = isArray;\r\n\r\n/***/ }),\r\n/* 17 */\r\n/***/ (function(module, exports, __nested_webpack_require_54713__) {\r\n\r\nvar baseMerge = __nested_webpack_require_54713__(90),\r\n    createAssigner = __nested_webpack_require_54713__(145);\r\n/**\r\n * This method is like `_.assign` except that it recursively merges own and\r\n * inherited enumerable string keyed properties of source objects into the\r\n * destination object. Source properties that resolve to `undefined` are\r\n * skipped if a destination value exists. Array and plain object properties\r\n * are merged recursively. Other objects and value types are overridden by\r\n * assignment. Source objects are applied from left to right. Subsequent\r\n * sources overwrite property assignments of previous sources.\r\n *\r\n * **Note:** This method mutates `object`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.5.0\r\n * @category Object\r\n * @param {Object} object The destination object.\r\n * @param {...Object} [sources] The source objects.\r\n * @returns {Object} Returns `object`.\r\n * @example\r\n *\r\n * var object = {\r\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\r\n * };\r\n *\r\n * var other = {\r\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\r\n * };\r\n *\r\n * _.merge(object, other);\r\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\r\n */\r\n\r\n\r\nvar merge = createAssigner(function (object, source, srcIndex) {\r\n  baseMerge(object, source, srcIndex);\r\n});\r\nmodule.exports = merge;\r\n\r\n/***/ }),\r\n/* 18 */\r\n/***/ (function(module, exports, __nested_webpack_require_56051__) {\r\n\r\nvar freeGlobal = __nested_webpack_require_56051__(45);\r\n/** Detect free variable `self`. */\r\n\r\n\r\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\r\n/** Used as a reference to the global object. */\r\n\r\nvar root = freeGlobal || freeSelf || Function('return this')();\r\nmodule.exports = root;\r\n\r\n/***/ }),\r\n/* 19 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * Checks if `value` is object-like. A value is object-like if it's not `null`\r\n * and has a `typeof` result of \"object\".\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\r\n * @example\r\n *\r\n * _.isObjectLike({});\r\n * // => true\r\n *\r\n * _.isObjectLike([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isObjectLike(_.noop);\r\n * // => false\r\n *\r\n * _.isObjectLike(null);\r\n * // => false\r\n */\r\nfunction isObjectLike(value) {\r\n  return value != null && typeof value == 'object';\r\n}\r\n\r\nmodule.exports = isObjectLike;\r\n\r\n/***/ }),\r\n/* 20 */\r\n/***/ (function(module, exports) {\r\n\r\nfunction _typeof(obj) {\r\n  \"@babel/helpers - typeof\";\r\n\r\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\r\n    return typeof obj;\r\n  } : function (obj) {\r\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\r\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(obj);\r\n}\r\n\r\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 21 */\r\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\r\n\r\n\"use strict\";\r\n/**\r\n * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization\r\n */\r\nvar Tracer = {\r\n  searchDirections: [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]],\r\n  create: function create(imageWrapper, labelWrapper) {\r\n    var imageData = imageWrapper.data;\r\n    var labelData = labelWrapper.data;\r\n    var searchDirections = this.searchDirections;\r\n    var width = imageWrapper.size.x;\r\n    var pos;\r\n\r\n    function _trace(current, color, label, edgelabel) {\r\n      var i;\r\n      var y;\r\n      var x;\r\n\r\n      for (i = 0; i < 7; i++) {\r\n        y = current.cy + searchDirections[current.dir][0];\r\n        x = current.cx + searchDirections[current.dir][1];\r\n        pos = y * width + x;\r\n\r\n        if (imageData[pos] === color && (labelData[pos] === 0 || labelData[pos] === label)) {\r\n          labelData[pos] = label;\r\n          current.cy = y;\r\n          current.cx = x;\r\n          return true;\r\n        }\r\n\r\n        if (labelData[pos] === 0) {\r\n          labelData[pos] = edgelabel;\r\n        }\r\n\r\n        current.dir = (current.dir + 1) % 8;\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    function vertex2D(x, y, dir) {\r\n      return {\r\n        dir: dir,\r\n        x: x,\r\n        y: y,\r\n        next: null,\r\n        prev: null\r\n      };\r\n    }\r\n\r\n    function _contourTracing(sy, sx, label, color, edgelabel) {\r\n      var Fv = null;\r\n      var Cv;\r\n      var P;\r\n      var ldir;\r\n      var current = {\r\n        cx: sx,\r\n        cy: sy,\r\n        dir: 0\r\n      };\r\n\r\n      if (_trace(current, color, label, edgelabel)) {\r\n        Fv = vertex2D(sx, sy, current.dir);\r\n        Cv = Fv;\r\n        ldir = current.dir;\r\n        P = vertex2D(current.cx, current.cy, 0);\r\n        P.prev = Cv;\r\n        Cv.next = P;\r\n        P.next = null;\r\n        Cv = P;\r\n\r\n        do {\r\n          current.dir = (current.dir + 6) % 8;\r\n\r\n          _trace(current, color, label, edgelabel);\r\n\r\n          if (ldir !== current.dir) {\r\n            Cv.dir = current.dir;\r\n            P = vertex2D(current.cx, current.cy, 0);\r\n            P.prev = Cv;\r\n            Cv.next = P;\r\n            P.next = null;\r\n            Cv = P;\r\n          } else {\r\n            Cv.dir = ldir;\r\n            Cv.x = current.cx;\r\n            Cv.y = current.cy;\r\n          }\r\n\r\n          ldir = current.dir;\r\n        } while (current.cx !== sx || current.cy !== sy);\r\n\r\n        Fv.prev = Cv.prev;\r\n        Cv.prev.next = Fv;\r\n      }\r\n\r\n      return Fv;\r\n    }\r\n\r\n    return {\r\n      trace: function trace(current, color, label, edgelabel) {\r\n        return _trace(current, color, label, edgelabel);\r\n      },\r\n      contourTracing: function contourTracing(sy, sx, label, color, edgelabel) {\r\n        return _contourTracing(sy, sx, label, color, edgelabel);\r\n      }\r\n    };\r\n  }\r\n};\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (Tracer);\r\n\r\n/***/ }),\r\n/* 22 */\r\n/***/ (function(module, exports, __nested_webpack_require_60728__) {\r\n\r\nvar Symbol = __nested_webpack_require_60728__(27),\r\n    getRawTag = __nested_webpack_require_60728__(103),\r\n    objectToString = __nested_webpack_require_60728__(104);\r\n/** `Object#toString` result references. */\r\n\r\n\r\nvar nullTag = '[object Null]',\r\n    undefinedTag = '[object Undefined]';\r\n/** Built-in value references. */\r\n\r\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\r\n/**\r\n * The base implementation of `getTag` without fallbacks for buggy environments.\r\n *\r\n * @private\r\n * @param {*} value The value to query.\r\n * @returns {string} Returns the `toStringTag`.\r\n */\r\n\r\nfunction baseGetTag(value) {\r\n  if (value == null) {\r\n    return value === undefined ? undefinedTag : nullTag;\r\n  }\r\n\r\n  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\r\n}\r\n\r\nmodule.exports = baseGetTag;\r\n\r\n/***/ }),\r\n/* 23 */\r\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_61634__) {\r\n\r\n\"use strict\";\r\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_61634__(7);\r\n/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_61634__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_0__);\r\n/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_61634__(34);\r\n/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_61634__.n(gl_mat2__WEBPACK_IMPORTED_MODULE_1__);\r\n/* harmony import */ var _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_61634__(12);\r\n/* harmony import */ var _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_61634__(9);\r\n/* harmony import */ var _common_array_helper__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_61634__(11);\r\n/* harmony import */ var _common_image_debug__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_61634__(10);\r\n/* harmony import */ var _rasterizer__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_61634__(87);\r\n/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_61634__(21);\r\n/* harmony import */ var _skeletonizer__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_61634__(88);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar _config;\r\n\r\nvar _currentImageWrapper;\r\n\r\nvar _skelImageWrapper;\r\n\r\nvar _subImageWrapper;\r\n\r\nvar _labelImageWrapper;\r\n\r\nvar _patchGrid;\r\n\r\nvar _patchLabelGrid;\r\n\r\nvar _imageToPatchGrid;\r\n\r\nvar _binaryImageWrapper;\r\n\r\nvar _patchSize;\r\n\r\nvar _canvasContainer = {\r\n  ctx: {\r\n    binary: null\r\n  },\r\n  dom: {\r\n    binary: null\r\n  }\r\n};\r\nvar _numPatches = {\r\n  x: 0,\r\n  y: 0\r\n};\r\n\r\nvar _inputImageWrapper;\r\n\r\nvar _skeletonizer;\r\n\r\nfunction initBuffers() {\r\n  if (_config.halfSample) {\r\n    _currentImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"]({\r\n      // eslint-disable-next-line no-bitwise\r\n      x: _inputImageWrapper.size.x / 2 | 0,\r\n      // eslint-disable-next-line no-bitwise\r\n      y: _inputImageWrapper.size.y / 2 | 0\r\n    });\r\n  } else {\r\n    _currentImageWrapper = _inputImageWrapper;\r\n  }\r\n\r\n  _patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* calculatePatchSize */ \"a\"])(_config.patchSize, _currentImageWrapper.size); // eslint-disable-next-line no-bitwise\r\n\r\n  _numPatches.x = _currentImageWrapper.size.x / _patchSize.x | 0; // eslint-disable-next-line no-bitwise\r\n\r\n  _numPatches.y = _currentImageWrapper.size.y / _patchSize.y | 0;\r\n  _binaryImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"](_currentImageWrapper.size, undefined, Uint8Array, false);\r\n  _labelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"](_patchSize, undefined, Array, true);\r\n  var skeletonImageData = new ArrayBuffer(64 * 1024);\r\n  _subImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"](_patchSize, new Uint8Array(skeletonImageData, 0, _patchSize.x * _patchSize.y));\r\n  _skelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"](_patchSize, new Uint8Array(skeletonImageData, _patchSize.x * _patchSize.y * 3, _patchSize.x * _patchSize.y), undefined, true);\r\n  _skeletonizer = Object(_skeletonizer__WEBPACK_IMPORTED_MODULE_8__[/* default */ \"a\"])(typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : global, {\r\n    size: _patchSize.x\r\n  }, skeletonImageData);\r\n  _imageToPatchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"]({\r\n    // eslint-disable-next-line no-bitwise\r\n    x: _currentImageWrapper.size.x / _subImageWrapper.size.x | 0,\r\n    // eslint-disable-next-line no-bitwise\r\n    y: _currentImageWrapper.size.y / _subImageWrapper.size.y | 0\r\n  }, undefined, Array, true);\r\n  _patchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"](_imageToPatchGrid.size, undefined, undefined, true);\r\n  _patchLabelGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ \"a\"](_imageToPatchGrid.size, undefined, Int32Array, true);\r\n}\r\n\r\nfunction initCanvas() {\r\n  if (_config.useWorker || typeof document === 'undefined') {\r\n    return;\r\n  }\r\n\r\n  _canvasContainer.dom.binary = document.createElement('canvas');\r\n  _canvasContainer.dom.binary.className = 'binaryBuffer';\r\n\r\n  if (  true && _config.debug.showCanvas === true) {\r\n    document.querySelector('#debug').appendChild(_canvasContainer.dom.binary);\r\n  }\r\n\r\n  _canvasContainer.ctx.binary = _canvasContainer.dom.binary.getContext('2d');\r\n  _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;\r\n  _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;\r\n}\r\n/**\r\n * Creates a bounding box which encloses all the given patches\r\n * @returns {Array} The minimal bounding box\r\n */\r\n\r\n\r\nfunction boxFromPatches(patches) {\r\n  var overAvg;\r\n  var i;\r\n  var j;\r\n  var patch;\r\n  var transMat;\r\n  var minx = _binaryImageWrapper.size.x;\r\n  var miny = _binaryImageWrapper.size.y;\r\n  var maxx = -_binaryImageWrapper.size.x;\r\n  var maxy = -_binaryImageWrapper.size.y;\r\n  var box;\r\n  var scale; // draw all patches which are to be taken into consideration\r\n\r\n  overAvg = 0;\r\n\r\n  for (i = 0; i < patches.length; i++) {\r\n    patch = patches[i];\r\n    overAvg += patch.rad;\r\n\r\n    if (  true && _config.debug.showPatches) {\r\n      _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {\r\n        color: 'red'\r\n      });\r\n    }\r\n  }\r\n\r\n  overAvg /= patches.length;\r\n  overAvg = (overAvg * 180 / Math.PI + 90) % 180 - 90;\r\n\r\n  if (overAvg < 0) {\r\n    overAvg += 180;\r\n  }\r\n\r\n  overAvg = (180 - overAvg) * Math.PI / 180;\r\n  transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__[\"copy\"](gl_mat2__WEBPACK_IMPORTED_MODULE_1__[\"create\"](), [Math.cos(overAvg), Math.sin(overAvg), -Math.sin(overAvg), Math.cos(overAvg)]); // iterate over patches and rotate by angle\r\n\r\n  for (i = 0; i < patches.length; i++) {\r\n    patch = patches[i];\r\n\r\n    for (j = 0; j < 4; j++) {\r\n      gl_vec2__WEBPACK_IMPORTED_MODULE_0__[\"transformMat2\"](patch.box[j], patch.box[j], transMat);\r\n    }\r\n\r\n    if (  true && _config.debug.boxFromPatches.showTransformed) {\r\n      _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].drawPath(patch.box, {\r\n        x: 0,\r\n        y: 1\r\n      }, _canvasContainer.ctx.binary, {\r\n        color: '#99ff00',\r\n        lineWidth: 2\r\n      });\r\n    }\r\n  } // find bounding box\r\n\r\n\r\n  for (i = 0; i < patches.length; i++) {\r\n    patch = patches[i];\r\n\r\n    for (j = 0; j < 4; j++) {\r\n      if (patch.box[j][0] < minx) {\r\n        minx = patch.box[j][0];\r\n      }\r\n\r\n      if (patch.box[j][0] > maxx) {\r\n        maxx = patch.box[j][0];\r\n      }\r\n\r\n      if (patch.box[j][1] < miny) {\r\n        miny = patch.box[j][1];\r\n      }\r\n\r\n      if (patch.box[j][1] > maxy) {\r\n        maxy = patch.box[j][1];\r\n      }\r\n    }\r\n  }\r\n\r\n  box = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];\r\n\r\n  if (  true && _config.debug.boxFromPatches.showTransformedBox) {\r\n    _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].drawPath(box, {\r\n      x: 0,\r\n      y: 1\r\n    }, _canvasContainer.ctx.binary, {\r\n      color: '#ff0000',\r\n      lineWidth: 2\r\n    });\r\n  }\r\n\r\n  scale = _config.halfSample ? 2 : 1; // reverse rotation;\r\n\r\n  transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__[\"invert\"](transMat, transMat);\r\n\r\n  for (j = 0; j < 4; j++) {\r\n    gl_vec2__WEBPACK_IMPORTED_MODULE_0__[\"transformMat2\"](box[j], box[j], transMat);\r\n  }\r\n\r\n  if (  true && _config.debug.boxFromPatches.showBB) {\r\n    _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].drawPath(box, {\r\n      x: 0,\r\n      y: 1\r\n    }, _canvasContainer.ctx.binary, {\r\n      color: '#ff0000',\r\n      lineWidth: 2\r\n    });\r\n  }\r\n\r\n  for (j = 0; j < 4; j++) {\r\n    gl_vec2__WEBPACK_IMPORTED_MODULE_0__[\"scale\"](box[j], box[j], scale);\r\n  }\r\n\r\n  return box;\r\n}\r\n/**\r\n * Creates a binary image of the current image\r\n */\r\n\r\n\r\nfunction binarizeImage() {\r\n  Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* otsuThreshold */ \"i\"])(_currentImageWrapper, _binaryImageWrapper);\r\n\r\n  _binaryImageWrapper.zeroBorder();\r\n\r\n  if (  true && _config.debug.showCanvas) {\r\n    _binaryImageWrapper.show(_canvasContainer.dom.binary, 255);\r\n  }\r\n}\r\n/**\r\n * Iterate over the entire image\r\n * extract patches\r\n */\r\n\r\n\r\nfunction findPatches() {\r\n  var i;\r\n  var j;\r\n  var x;\r\n  var y;\r\n  var moments;\r\n  var patchesFound = [];\r\n  var rasterizer;\r\n  var rasterResult;\r\n  var patch;\r\n\r\n  for (i = 0; i < _numPatches.x; i++) {\r\n    for (j = 0; j < _numPatches.y; j++) {\r\n      x = _subImageWrapper.size.x * i;\r\n      y = _subImageWrapper.size.y * j; // seperate parts\r\n\r\n      skeletonize(x, y); // Rasterize, find individual bars\r\n\r\n      _skelImageWrapper.zeroBorder();\r\n\r\n      _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"].init(_labelImageWrapper.data, 0);\r\n      rasterizer = _rasterizer__WEBPACK_IMPORTED_MODULE_6__[/* default */ \"a\"].create(_skelImageWrapper, _labelImageWrapper);\r\n      rasterResult = rasterizer.rasterize(0);\r\n\r\n      if (  true && _config.debug.showLabels) {\r\n        _labelImageWrapper.overlay(_canvasContainer.dom.binary, Math.floor(360 / rasterResult.count), {\r\n          x: x,\r\n          y: y\r\n        });\r\n      } // calculate moments from the skeletonized patch\r\n\r\n\r\n      moments = _labelImageWrapper.moments(rasterResult.count); // extract eligible patches\r\n\r\n      patchesFound = patchesFound.concat(describePatch(moments, [i, j], x, y));\r\n    }\r\n  }\r\n\r\n  if (  true && _config.debug.showFoundPatches) {\r\n    for (i = 0; i < patchesFound.length; i++) {\r\n      patch = patchesFound[i];\r\n      _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {\r\n        color: '#99ff00',\r\n        lineWidth: 2\r\n      });\r\n    }\r\n  }\r\n\r\n  return patchesFound;\r\n}\r\n/**\r\n * Finds those connected areas which contain at least 6 patches\r\n * and returns them ordered DESC by the number of contained patches\r\n * @param {Number} maxLabel\r\n */\r\n\r\n\r\nfunction findBiggestConnectedAreas(maxLabel) {\r\n  var i;\r\n  var sum;\r\n  var labelHist = [];\r\n  var topLabels = [];\r\n\r\n  for (i = 0; i < maxLabel; i++) {\r\n    labelHist.push(0);\r\n  }\r\n\r\n  sum = _patchLabelGrid.data.length;\r\n\r\n  while (sum--) {\r\n    if (_patchLabelGrid.data[sum] > 0) {\r\n      labelHist[_patchLabelGrid.data[sum] - 1]++;\r\n    }\r\n  }\r\n\r\n  labelHist = labelHist.map(function (val, idx) {\r\n    return {\r\n      val: val,\r\n      label: idx + 1\r\n    };\r\n  });\r\n  labelHist.sort(function (a, b) {\r\n    return b.val - a.val;\r\n  }); // extract top areas with at least 6 patches present\r\n\r\n  topLabels = labelHist.filter(function (el) {\r\n    return el.val >= 5;\r\n  });\r\n  return topLabels;\r\n}\r\n/**\r\n *\r\n */\r\n\r\n\r\nfunction findBoxes(topLabels, maxLabel) {\r\n  var i;\r\n  var j;\r\n  var sum;\r\n  var patches = [];\r\n  var patch;\r\n  var box;\r\n  var boxes = [];\r\n  var hsv = [0, 1, 1];\r\n  var rgb = [0, 0, 0];\r\n\r\n  for (i = 0; i < topLabels.length; i++) {\r\n    sum = _patchLabelGrid.data.length;\r\n    patches.length = 0;\r\n\r\n    while (sum--) {\r\n      if (_patchLabelGrid.data[sum] === topLabels[i].label) {\r\n        patch = _imageToPatchGrid.data[sum];\r\n        patches.push(patch);\r\n      }\r\n    }\r\n\r\n    box = boxFromPatches(patches);\r\n\r\n    if (box) {\r\n      boxes.push(box); // draw patch-labels if requested\r\n\r\n      if (  true && _config.debug.showRemainingPatchLabels) {\r\n        for (j = 0; j < patches.length; j++) {\r\n          patch = patches[j];\r\n          hsv[0] = topLabels[i].label / (maxLabel + 1) * 360;\r\n          Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* hsv2rgb */ \"g\"])(hsv, rgb);\r\n          _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {\r\n            color: \"rgb(\".concat(rgb.join(','), \")\"),\r\n            lineWidth: 2\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return boxes;\r\n}\r\n/**\r\n * Find similar moments (via cluster)\r\n * @param {Object} moments\r\n */\r\n\r\n\r\nfunction similarMoments(moments) {\r\n  var clusters = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* cluster */ \"b\"])(moments, 0.90);\r\n  var topCluster = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* topGeneric */ \"j\"])(clusters, 1, function (e) {\r\n    return e.getPoints().length;\r\n  });\r\n  var points = [];\r\n  var result = [];\r\n\r\n  if (topCluster.length === 1) {\r\n    points = topCluster[0].item.getPoints();\r\n\r\n    for (var i = 0; i < points.length; i++) {\r\n      result.push(points[i].point);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction skeletonize(x, y) {\r\n  _binaryImageWrapper.subImageAsCopy(_subImageWrapper, Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* imageRef */ \"h\"])(x, y));\r\n\r\n  _skeletonizer.skeletonize(); // Show skeleton if requested\r\n\r\n\r\n  if (  true && _config.debug.showSkeleton) {\r\n    _skelImageWrapper.overlay(_canvasContainer.dom.binary, 360, Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* imageRef */ \"h\"])(x, y));\r\n  }\r\n}\r\n/**\r\n * Extracts and describes those patches which seem to contain a barcode pattern\r\n * @param {Array} moments\r\n * @param {Object} patchPos,\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @returns {Array} list of patches\r\n */\r\n\r\n\r\nfunction describePatch(moments, patchPos, x, y) {\r\n  var k;\r\n  var avg;\r\n  var eligibleMoments = [];\r\n  var matchingMoments;\r\n  var patch;\r\n  var patchesFound = [];\r\n  var minComponentWeight = Math.ceil(_patchSize.x / 3);\r\n\r\n  if (moments.length >= 2) {\r\n    // only collect moments which's area covers at least minComponentWeight pixels.\r\n    for (k = 0; k < moments.length; k++) {\r\n      if (moments[k].m00 > minComponentWeight) {\r\n        eligibleMoments.push(moments[k]);\r\n      }\r\n    } // if at least 2 moments are found which have at least minComponentWeights covered\r\n\r\n\r\n    if (eligibleMoments.length >= 2) {\r\n      matchingMoments = similarMoments(eligibleMoments);\r\n      avg = 0; // determine the similarity of the moments\r\n\r\n      for (k = 0; k < matchingMoments.length; k++) {\r\n        avg += matchingMoments[k].rad;\r\n      } // Only two of the moments are allowed not to fit into the equation\r\n      // add the patch to the set\r\n\r\n\r\n      if (matchingMoments.length > 1 && matchingMoments.length >= eligibleMoments.length / 4 * 3 && matchingMoments.length > moments.length / 4) {\r\n        avg /= matchingMoments.length;\r\n        patch = {\r\n          index: patchPos[1] * _numPatches.x + patchPos[0],\r\n          pos: {\r\n            x: x,\r\n            y: y\r\n          },\r\n          box: [gl_vec2__WEBPACK_IMPORTED_MODULE_0__[\"clone\"]([x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__[\"clone\"]([x + _subImageWrapper.size.x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__[\"clone\"]([x + _subImageWrapper.size.x, y + _subImageWrapper.size.y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__[\"clone\"]([x, y + _subImageWrapper.size.y])],\r\n          moments: matchingMoments,\r\n          rad: avg,\r\n          vec: gl_vec2__WEBPACK_IMPORTED_MODULE_0__[\"clone\"]([Math.cos(avg), Math.sin(avg)])\r\n        };\r\n        patchesFound.push(patch);\r\n      }\r\n    }\r\n  }\r\n\r\n  return patchesFound;\r\n}\r\n/**\r\n * finds patches which are connected and share the same orientation\r\n * @param {Object} patchesFound\r\n */\r\n\r\n\r\nfunction rasterizeAngularSimilarity(patchesFound) {\r\n  var label = 0;\r\n  var threshold = 0.95;\r\n  var currIdx = 0;\r\n  var j;\r\n  var patch;\r\n  var hsv = [0, 1, 1];\r\n  var rgb = [0, 0, 0];\r\n\r\n  function notYetProcessed() {\r\n    var i;\r\n\r\n    for (i = 0; i < _patchLabelGrid.data.length; i++) {\r\n      if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    return _patchLabelGrid.length;\r\n  }\r\n\r\n  function trace(currentIdx) {\r\n    var x;\r\n    var y;\r\n    var currentPatch;\r\n    var idx;\r\n    var dir;\r\n    var current = {\r\n      x: currentIdx % _patchLabelGrid.size.x,\r\n      y: currentIdx / _patchLabelGrid.size.x | 0\r\n    };\r\n    var similarity;\r\n\r\n    if (currentIdx < _patchLabelGrid.data.length) {\r\n      currentPatch = _imageToPatchGrid.data[currentIdx]; // assign label\r\n\r\n      _patchLabelGrid.data[currentIdx] = label;\r\n\r\n      for (dir = 0; dir < _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"].searchDirections.length; dir++) {\r\n        y = current.y + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"].searchDirections[dir][0];\r\n        x = current.x + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ \"a\"].searchDirections[dir][1];\r\n        idx = y * _patchLabelGrid.size.x + x; // continue if patch empty\r\n\r\n        if (_patchGrid.data[idx] === 0) {\r\n          _patchLabelGrid.data[idx] = Number.MAX_VALUE; // eslint-disable-next-line no-continue\r\n\r\n          continue;\r\n        }\r\n\r\n        if (_patchLabelGrid.data[idx] === 0) {\r\n          similarity = Math.abs(gl_vec2__WEBPACK_IMPORTED_MODULE_0__[\"dot\"](_imageToPatchGrid.data[idx].vec, currentPatch.vec));\r\n\r\n          if (similarity > threshold) {\r\n            trace(idx);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  } // prepare for finding the right patches\r\n\r\n\r\n  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"].init(_patchGrid.data, 0);\r\n  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"].init(_patchLabelGrid.data, 0);\r\n  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ \"a\"].init(_imageToPatchGrid.data, null);\r\n\r\n  for (j = 0; j < patchesFound.length; j++) {\r\n    patch = patchesFound[j];\r\n    _imageToPatchGrid.data[patch.index] = patch;\r\n    _patchGrid.data[patch.index] = 1;\r\n  } // rasterize the patches found to determine area\r\n\r\n\r\n  _patchGrid.zeroBorder(); // eslint-disable-next-line no-cond-assign\r\n\r\n\r\n  while ((currIdx = notYetProcessed()) < _patchLabelGrid.data.length) {\r\n    label++;\r\n    trace(currIdx);\r\n  } // draw patch-labels if requested\r\n\r\n\r\n  if (  true && _config.debug.showPatchLabels) {\r\n    for (j = 0; j < _patchLabelGrid.data.length; j++) {\r\n      if (_patchLabelGrid.data[j] > 0 && _patchLabelGrid.data[j] <= label) {\r\n        patch = _imageToPatchGrid.data[j];\r\n        hsv[0] = _patchLabelGrid.data[j] / (label + 1) * 360;\r\n        Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* hsv2rgb */ \"g\"])(hsv, rgb);\r\n        _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ \"a\"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {\r\n          color: \"rgb(\".concat(rgb.join(','), \")\"),\r\n          lineWidth: 2\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  return label;\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\r\n  init: function init(inputImageWrapper, config) {\r\n    _config = config;\r\n    _inputImageWrapper = inputImageWrapper;\r\n    initBuffers();\r\n    initCanvas();\r\n  },\r\n  locate: function locate() {\r\n    if (_config.halfSample) {\r\n      Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* halfSample */ \"f\"])(_inputImageWrapper, _currentImageWrapper);\r\n    }\r\n\r\n    binarizeImage();\r\n    var patchesFound = findPatches(); // return unless 5% or more patches are found\r\n\r\n    if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {\r\n      return null;\r\n    } // rasterrize area by comparing angular similarity;\r\n\r\n\r\n    var maxLabel = rasterizeAngularSimilarity(patchesFound);\r\n\r\n    if (maxLabel < 1) {\r\n      return null;\r\n    } // search for area with the most patches (biggest connected area)\r\n\r\n\r\n    var topLabels = findBiggestConnectedAreas(maxLabel);\r\n\r\n    if (topLabels.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    var boxes = findBoxes(topLabels, maxLabel);\r\n    return boxes;\r\n  },\r\n  checkImageConstraints: function checkImageConstraints(inputStream, config) {\r\n    var patchSize;\r\n    var width = inputStream.getWidth();\r\n    var height = inputStream.getHeight();\r\n    var thisHalfSample = config.halfSample ? 0.5 : 1;\r\n    var area; // calculate width and height based on area\r\n\r\n    if (inputStream.getConfig().area) {\r\n      area = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* computeImageArea */ \"d\"])(width, height, inputStream.getConfig().area);\r\n      inputStream.setTopRight({\r\n        x: area.sx,\r\n        y: area.sy\r\n      });\r\n      inputStream.setCanvasSize({\r\n        x: width,\r\n        y: height\r\n      });\r\n      width = area.sw;\r\n      height = area.sh;\r\n    }\r\n\r\n    var size = {\r\n      x: Math.floor(width * thisHalfSample),\r\n      y: Math.floor(height * thisHalfSample)\r\n    };\r\n    patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__[/* calculatePatchSize */ \"a\"])(config.patchSize, size);\r\n\r\n    if (true) {\r\n      console.log(\"Patch-Size: \".concat(JSON.stringify(patchSize)));\r\n    }\r\n\r\n    inputStream.setWidth(Math.floor(Math.floor(size.x / patchSize.x) * (1 / thisHalfSample) * patchSize.x));\r\n    inputStream.setHeight(Math.floor(Math.floor(size.y / patchSize.y) * (1 / thisHalfSample) * patchSize.y));\r\n\r\n    if (inputStream.getWidth() % patchSize.x === 0 && inputStream.getHeight() % patchSize.y === 0) {\r\n      return true;\r\n    }\r\n\r\n    throw new Error(\"Image dimensions do not comply with the current settings: Width (\".concat(width, \" )and height (\").concat(height, \") must a multiple of \").concat(patchSize.x));\r\n  }\r\n});\r\n/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_61634__(46)))\r\n\r\n/***/ }),\r\n/* 24 */\r\n/***/ (function(module, exports, __nested_webpack_require_82998__) {\r\n\r\nvar listCacheClear = __nested_webpack_require_82998__(92),\r\n    listCacheDelete = __nested_webpack_require_82998__(93),\r\n    listCacheGet = __nested_webpack_require_82998__(94),\r\n    listCacheHas = __nested_webpack_require_82998__(95),\r\n    listCacheSet = __nested_webpack_require_82998__(96);\r\n/**\r\n * Creates an list cache object.\r\n *\r\n * @private\r\n * @constructor\r\n * @param {Array} [entries] The key-value pairs to cache.\r\n */\r\n\r\n\r\nfunction ListCache(entries) {\r\n  var index = -1,\r\n      length = entries == null ? 0 : entries.length;\r\n  this.clear();\r\n\r\n  while (++index < length) {\r\n    var entry = entries[index];\r\n    this.set(entry[0], entry[1]);\r\n  }\r\n} // Add methods to `ListCache`.\r\n\r\n\r\nListCache.prototype.clear = listCacheClear;\r\nListCache.prototype['delete'] = listCacheDelete;\r\nListCache.prototype.get = listCacheGet;\r\nListCache.prototype.has = listCacheHas;\r\nListCache.prototype.set = listCacheSet;\r\nmodule.exports = ListCache;\r\n\r\n/***/ }),\r\n/* 25 */\r\n/***/ (function(module, exports, __nested_webpack_require_83962__) {\r\n\r\nvar eq = __nested_webpack_require_83962__(26);\r\n/**\r\n * Gets the index at which the `key` is found in `array` of key-value pairs.\r\n *\r\n * @private\r\n * @param {Array} array The array to inspect.\r\n * @param {*} key The key to search for.\r\n * @returns {number} Returns the index of the matched value, else `-1`.\r\n */\r\n\r\n\r\nfunction assocIndexOf(array, key) {\r\n  var length = array.length;\r\n\r\n  while (length--) {\r\n    if (eq(array[length][0], key)) {\r\n      return length;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\nmodule.exports = assocIndexOf;\r\n\r\n/***/ }),\r\n/* 26 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * Performs a\r\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n * comparison between two values to determine if they are equivalent.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to compare.\r\n * @param {*} other The other value to compare.\r\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\r\n * @example\r\n *\r\n * var object = { 'a': 1 };\r\n * var other = { 'a': 1 };\r\n *\r\n * _.eq(object, object);\r\n * // => true\r\n *\r\n * _.eq(object, other);\r\n * // => false\r\n *\r\n * _.eq('a', 'a');\r\n * // => true\r\n *\r\n * _.eq('a', Object('a'));\r\n * // => false\r\n *\r\n * _.eq(NaN, NaN);\r\n * // => true\r\n */\r\nfunction eq(value, other) {\r\n  return value === other || value !== value && other !== other;\r\n}\r\n\r\nmodule.exports = eq;\r\n\r\n/***/ }),\r\n/* 27 */\r\n/***/ (function(module, exports, __nested_webpack_require_85461__) {\r\n\r\nvar root = __nested_webpack_require_85461__(18);\r\n/** Built-in value references. */\r\n\r\n\r\nvar Symbol = root.Symbol;\r\nmodule.exports = Symbol;\r\n\r\n/***/ }),\r\n/* 28 */\r\n/***/ (function(module, exports, __nested_webpack_require_85672__) {\r\n\r\nvar getNative = __nested_webpack_require_85672__(35);\r\n/* Built-in method references that are verified to be native. */\r\n\r\n\r\nvar nativeCreate = getNative(Object, 'create');\r\nmodule.exports = nativeCreate;\r\n\r\n/***/ }),\r\n/* 29 */\r\n/***/ (function(module, exports, __nested_webpack_require_85947__) {\r\n\r\nvar isKeyable = __nested_webpack_require_85947__(117);\r\n/**\r\n * Gets the data for `map`.\r\n *\r\n * @private\r\n * @param {Object} map The map to query.\r\n * @param {string} key The reference key.\r\n * @returns {*} Returns the map data.\r\n */\r\n\r\n\r\nfunction getMapData(map, key) {\r\n  var data = map.__data__;\r\n  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;\r\n}\r\n\r\nmodule.exports = getMapData;\r\n\r\n/***/ }),\r\n/* 30 */\r\n/***/ (function(module, exports, __nested_webpack_require_86440__) {\r\n\r\nvar baseIsArguments = __nested_webpack_require_86440__(132),\r\n    isObjectLike = __nested_webpack_require_86440__(19);\r\n/** Used for built-in method references. */\r\n\r\n\r\nvar objectProto = Object.prototype;\r\n/** Used to check objects for own properties. */\r\n\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n/** Built-in value references. */\r\n\r\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\r\n/**\r\n * Checks if `value` is likely an `arguments` object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\r\n *  else `false`.\r\n * @example\r\n *\r\n * _.isArguments(function() { return arguments; }());\r\n * // => true\r\n *\r\n * _.isArguments([1, 2, 3]);\r\n * // => false\r\n */\r\n\r\nvar isArguments = baseIsArguments(function () {\r\n  return arguments;\r\n}()) ? baseIsArguments : function (value) {\r\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');\r\n};\r\nmodule.exports = isArguments;\r\n\r\n/***/ }),\r\n/* 31 */\r\n/***/ (function(module, exports) {\r\n\r\n/** Used as references for various `Number` constants. */\r\nvar MAX_SAFE_INTEGER = 9007199254740991;\r\n/** Used to detect unsigned integer values. */\r\n\r\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\r\n/**\r\n * Checks if `value` is a valid array-like index.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\r\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\r\n */\r\n\r\nfunction isIndex(value, length) {\r\n  var type = typeof value;\r\n  length = length == null ? MAX_SAFE_INTEGER : length;\r\n  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\r\n}\r\n\r\nmodule.exports = isIndex;\r\n\r\n/***/ }),\r\n/* 32 */\r\n/***/ (function(module, exports, __nested_webpack_require_88396__) {\r\n\r\nvar isArray = __nested_webpack_require_88396__(16),\r\n    isKey = __nested_webpack_require_88396__(232),\r\n    stringToPath = __nested_webpack_require_88396__(233),\r\n    toString = __nested_webpack_require_88396__(236);\r\n/**\r\n * Casts `value` to a path array if it's not one.\r\n *\r\n * @private\r\n * @param {*} value The value to inspect.\r\n * @param {Object} [object] The object to query keys on.\r\n * @returns {Array} Returns the cast property path array.\r\n */\r\n\r\n\r\nfunction castPath(value, object) {\r\n  if (isArray(value)) {\r\n    return value;\r\n  }\r\n\r\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\r\n}\r\n\r\nmodule.exports = castPath;\r\n\r\n/***/ }),\r\n/* 33 */\r\n/***/ (function(module, exports, __nested_webpack_require_89081__) {\r\n\r\nvar arrayWithoutHoles = __nested_webpack_require_89081__(226);\r\n\r\nvar iterableToArray = __nested_webpack_require_89081__(227);\r\n\r\nvar unsupportedIterableToArray = __nested_webpack_require_89081__(60);\r\n\r\nvar nonIterableSpread = __nested_webpack_require_89081__(228);\r\n\r\nfunction _toConsumableArray(arr) {\r\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\r\n}\r\n\r\nmodule.exports = _toConsumableArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 34 */\r\n/***/ (function(module, exports, __nested_webpack_require_89654__) {\r\n\r\nmodule.exports = {\r\n  determinant: __nested_webpack_require_89654__(251),\r\n  transpose: __nested_webpack_require_89654__(252),\r\n  multiply: __nested_webpack_require_89654__(253),\r\n  identity: __nested_webpack_require_89654__(254),\r\n  adjoint: __nested_webpack_require_89654__(255),\r\n  rotate: __nested_webpack_require_89654__(256),\r\n  invert: __nested_webpack_require_89654__(257),\r\n  create: __nested_webpack_require_89654__(258),\r\n  scale: __nested_webpack_require_89654__(259),\r\n  copy: __nested_webpack_require_89654__(260),\r\n  frob: __nested_webpack_require_89654__(261),\r\n  ldu: __nested_webpack_require_89654__(262)\r\n};\r\n\r\n/***/ }),\r\n/* 35 */\r\n/***/ (function(module, exports, __nested_webpack_require_90208__) {\r\n\r\nvar baseIsNative = __nested_webpack_require_90208__(102),\r\n    getValue = __nested_webpack_require_90208__(108);\r\n/**\r\n * Gets the native function at `key` of `object`.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @param {string} key The key of the method to get.\r\n * @returns {*} Returns the function if it's native, else `undefined`.\r\n */\r\n\r\n\r\nfunction getNative(object, key) {\r\n  var value = getValue(object, key);\r\n  return baseIsNative(value) ? value : undefined;\r\n}\r\n\r\nmodule.exports = getNative;\r\n\r\n/***/ }),\r\n/* 36 */\r\n/***/ (function(module, exports, __nested_webpack_require_90792__) {\r\n\r\nvar baseGetTag = __nested_webpack_require_90792__(22),\r\n    isObject = __nested_webpack_require_90792__(15);\r\n/** `Object#toString` result references. */\r\n\r\n\r\nvar asyncTag = '[object AsyncFunction]',\r\n    funcTag = '[object Function]',\r\n    genTag = '[object GeneratorFunction]',\r\n    proxyTag = '[object Proxy]';\r\n/**\r\n * Checks if `value` is classified as a `Function` object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\r\n * @example\r\n *\r\n * _.isFunction(_);\r\n * // => true\r\n *\r\n * _.isFunction(/abc/);\r\n * // => false\r\n */\r\n\r\nfunction isFunction(value) {\r\n  if (!isObject(value)) {\r\n    return false;\r\n  } // The use of `Object#toString` avoids issues with the `typeof` operator\r\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\r\n\r\n\r\n  var tag = baseGetTag(value);\r\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\r\n}\r\n\r\nmodule.exports = isFunction;\r\n\r\n/***/ }),\r\n/* 37 */\r\n/***/ (function(module, exports, __nested_webpack_require_91908__) {\r\n\r\nvar defineProperty = __nested_webpack_require_91908__(49);\r\n/**\r\n * The base implementation of `assignValue` and `assignMergeValue` without\r\n * value checks.\r\n *\r\n * @private\r\n * @param {Object} object The object to modify.\r\n * @param {string} key The key of the property to assign.\r\n * @param {*} value The value to assign.\r\n */\r\n\r\n\r\nfunction baseAssignValue(object, key, value) {\r\n  if (key == '__proto__' && defineProperty) {\r\n    defineProperty(object, key, {\r\n      'configurable': true,\r\n      'enumerable': true,\r\n      'value': value,\r\n      'writable': true\r\n    });\r\n  } else {\r\n    object[key] = value;\r\n  }\r\n}\r\n\r\nmodule.exports = baseAssignValue;\r\n\r\n/***/ }),\r\n/* 38 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = function (module) {\r\n  if (!module.webpackPolyfill) {\r\n    module.deprecate = function () {};\r\n\r\n    module.paths = []; // module.parent = undefined by default\r\n\r\n    if (!module.children) module.children = [];\r\n    Object.defineProperty(module, \"loaded\", {\r\n      enumerable: true,\r\n      get: function () {\r\n        return module.l;\r\n      }\r\n    });\r\n    Object.defineProperty(module, \"id\", {\r\n      enumerable: true,\r\n      get: function () {\r\n        return module.i;\r\n      }\r\n    });\r\n    module.webpackPolyfill = 1;\r\n  }\r\n\r\n  return module;\r\n};\r\n\r\n/***/ }),\r\n/* 39 */\r\n/***/ (function(module, exports, __nested_webpack_require_93269__) {\r\n\r\nvar isFunction = __nested_webpack_require_93269__(36),\r\n    isLength = __nested_webpack_require_93269__(40);\r\n/**\r\n * Checks if `value` is array-like. A value is considered array-like if it's\r\n * not a function and has a `value.length` that's an integer greater than or\r\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\r\n * @example\r\n *\r\n * _.isArrayLike([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isArrayLike(document.body.children);\r\n * // => true\r\n *\r\n * _.isArrayLike('abc');\r\n * // => true\r\n *\r\n * _.isArrayLike(_.noop);\r\n * // => false\r\n */\r\n\r\n\r\nfunction isArrayLike(value) {\r\n  return value != null && isLength(value.length) && !isFunction(value);\r\n}\r\n\r\nmodule.exports = isArrayLike;\r\n\r\n/***/ }),\r\n/* 40 */\r\n/***/ (function(module, exports) {\r\n\r\n/** Used as references for various `Number` constants. */\r\nvar MAX_SAFE_INTEGER = 9007199254740991;\r\n/**\r\n * Checks if `value` is a valid array-like length.\r\n *\r\n * **Note:** This method is loosely based on\r\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\r\n * @example\r\n *\r\n * _.isLength(3);\r\n * // => true\r\n *\r\n * _.isLength(Number.MIN_VALUE);\r\n * // => false\r\n *\r\n * _.isLength(Infinity);\r\n * // => false\r\n *\r\n * _.isLength('3');\r\n * // => false\r\n */\r\n\r\nfunction isLength(value) {\r\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\r\n}\r\n\r\nmodule.exports = isLength;\r\n\r\n/***/ }),\r\n/* 41 */\r\n/***/ (function(module, exports) {\r\n\r\nfunction _setPrototypeOf(o, p) {\r\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\r\n    o.__proto__ = p;\r\n    return o;\r\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n  return _setPrototypeOf(o, p);\r\n}\r\n\r\nmodule.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 42 */\r\n/***/ (function(module, exports, __nested_webpack_require_95574__) {\r\n\r\nvar baseGetTag = __nested_webpack_require_95574__(22),\r\n    isObjectLike = __nested_webpack_require_95574__(19);\r\n/** `Object#toString` result references. */\r\n\r\n\r\nvar symbolTag = '[object Symbol]';\r\n/**\r\n * Checks if `value` is classified as a `Symbol` primitive or object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\r\n * @example\r\n *\r\n * _.isSymbol(Symbol.iterator);\r\n * // => true\r\n *\r\n * _.isSymbol('abc');\r\n * // => false\r\n */\r\n\r\nfunction isSymbol(value) {\r\n  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;\r\n}\r\n\r\nmodule.exports = isSymbol;\r\n\r\n/***/ }),\r\n/* 43 */\r\n/***/ (function(module, exports, __nested_webpack_require_96359__) {\r\n\r\nvar isSymbol = __nested_webpack_require_96359__(42);\r\n/** Used as references for various `Number` constants. */\r\n\r\n\r\nvar INFINITY = 1 / 0;\r\n/**\r\n * Converts `value` to a string key if it's not a string or symbol.\r\n *\r\n * @private\r\n * @param {*} value The value to inspect.\r\n * @returns {string|symbol} Returns the key.\r\n */\r\n\r\nfunction toKey(value) {\r\n  if (typeof value == 'string' || isSymbol(value)) {\r\n    return value;\r\n  }\r\n\r\n  var result = value + '';\r\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\r\n}\r\n\r\nmodule.exports = toKey;\r\n\r\n/***/ }),\r\n/* 44 */\r\n/***/ (function(module, exports, __nested_webpack_require_96985__) {\r\n\r\nvar getNative = __nested_webpack_require_96985__(35),\r\n    root = __nested_webpack_require_96985__(18);\r\n/* Built-in method references that are verified to be native. */\r\n\r\n\r\nvar Map = getNative(root, 'Map');\r\nmodule.exports = Map;\r\n\r\n/***/ }),\r\n/* 45 */\r\n/***/ (function(module, exports, __nested_webpack_require_97274__) {\r\n\r\n/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */\r\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\r\nmodule.exports = freeGlobal;\r\n/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_97274__(46)))\r\n\r\n/***/ }),\r\n/* 46 */\r\n/***/ (function(module, exports) {\r\n\r\nvar g; // This works in non-strict mode\r\n\r\ng = function () {\r\n  return this;\r\n}();\r\n\r\ntry {\r\n  // This works if eval is allowed (see CSP)\r\n  g = g || new Function(\"return this\")();\r\n} catch (e) {\r\n  // This works if the window reference is available\r\n  if (typeof window === \"object\") g = window;\r\n} // g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\n\r\nmodule.exports = g;\r\n\r\n/***/ }),\r\n/* 47 */\r\n/***/ (function(module, exports, __nested_webpack_require_98199__) {\r\n\r\nvar mapCacheClear = __nested_webpack_require_98199__(109),\r\n    mapCacheDelete = __nested_webpack_require_98199__(116),\r\n    mapCacheGet = __nested_webpack_require_98199__(118),\r\n    mapCacheHas = __nested_webpack_require_98199__(119),\r\n    mapCacheSet = __nested_webpack_require_98199__(120);\r\n/**\r\n * Creates a map cache object to store key-value pairs.\r\n *\r\n * @private\r\n * @constructor\r\n * @param {Array} [entries] The key-value pairs to cache.\r\n */\r\n\r\n\r\nfunction MapCache(entries) {\r\n  var index = -1,\r\n      length = entries == null ? 0 : entries.length;\r\n  this.clear();\r\n\r\n  while (++index < length) {\r\n    var entry = entries[index];\r\n    this.set(entry[0], entry[1]);\r\n  }\r\n} // Add methods to `MapCache`.\r\n\r\n\r\nMapCache.prototype.clear = mapCacheClear;\r\nMapCache.prototype['delete'] = mapCacheDelete;\r\nMapCache.prototype.get = mapCacheGet;\r\nMapCache.prototype.has = mapCacheHas;\r\nMapCache.prototype.set = mapCacheSet;\r\nmodule.exports = MapCache;\r\n\r\n/***/ }),\r\n/* 48 */\r\n/***/ (function(module, exports, __nested_webpack_require_99173__) {\r\n\r\nvar baseAssignValue = __nested_webpack_require_99173__(37),\r\n    eq = __nested_webpack_require_99173__(26);\r\n/**\r\n * This function is like `assignValue` except that it doesn't assign\r\n * `undefined` values.\r\n *\r\n * @private\r\n * @param {Object} object The object to modify.\r\n * @param {string} key The key of the property to assign.\r\n * @param {*} value The value to assign.\r\n */\r\n\r\n\r\nfunction assignMergeValue(object, key, value) {\r\n  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {\r\n    baseAssignValue(object, key, value);\r\n  }\r\n}\r\n\r\nmodule.exports = assignMergeValue;\r\n\r\n/***/ }),\r\n/* 49 */\r\n/***/ (function(module, exports, __nested_webpack_require_99850__) {\r\n\r\nvar getNative = __nested_webpack_require_99850__(35);\r\n\r\nvar defineProperty = function () {\r\n  try {\r\n    var func = getNative(Object, 'defineProperty');\r\n    func({}, '', {});\r\n    return func;\r\n  } catch (e) {}\r\n}();\r\n\r\nmodule.exports = defineProperty;\r\n\r\n/***/ }),\r\n/* 50 */\r\n/***/ (function(module, exports, __nested_webpack_require_100175__) {\r\n\r\nvar overArg = __nested_webpack_require_100175__(131);\r\n/** Built-in value references. */\r\n\r\n\r\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\r\nmodule.exports = getPrototype;\r\n\r\n/***/ }),\r\n/* 51 */\r\n/***/ (function(module, exports) {\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n/**\r\n * Checks if `value` is likely a prototype object.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\r\n */\r\n\r\nfunction isPrototype(value) {\r\n  var Ctor = value && value.constructor,\r\n      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;\r\n  return value === proto;\r\n}\r\n\r\nmodule.exports = isPrototype;\r\n\r\n/***/ }),\r\n/* 52 */\r\n/***/ (function(module, exports, __nested_webpack_require_100984__) {\r\n\r\n/* WEBPACK VAR INJECTION */(function(module) {var root = __nested_webpack_require_100984__(18),\r\n    stubFalse = __nested_webpack_require_100984__(134);\r\n/** Detect free variable `exports`. */\r\n\r\n\r\nvar freeExports =   true && exports && !exports.nodeType && exports;\r\n/** Detect free variable `module`. */\r\n\r\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\r\n/** Detect the popular CommonJS extension `module.exports`. */\r\n\r\nvar moduleExports = freeModule && freeModule.exports === freeExports;\r\n/** Built-in value references. */\r\n\r\nvar Buffer = moduleExports ? root.Buffer : undefined;\r\n/* Built-in method references for those with the same name as other `lodash` methods. */\r\n\r\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\r\n/**\r\n * Checks if `value` is a buffer.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.3.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\r\n * @example\r\n *\r\n * _.isBuffer(new Buffer(2));\r\n * // => true\r\n *\r\n * _.isBuffer(new Uint8Array(2));\r\n * // => false\r\n */\r\n\r\nvar isBuffer = nativeIsBuffer || stubFalse;\r\nmodule.exports = isBuffer;\r\n/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_100984__(38)(module)))\r\n\r\n/***/ }),\r\n/* 53 */\r\n/***/ (function(module, exports, __nested_webpack_require_102325__) {\r\n\r\nvar baseIsTypedArray = __nested_webpack_require_102325__(136),\r\n    baseUnary = __nested_webpack_require_102325__(137),\r\n    nodeUtil = __nested_webpack_require_102325__(138);\r\n/* Node.js helper references. */\r\n\r\n\r\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\r\n/**\r\n * Checks if `value` is classified as a typed array.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 3.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\r\n * @example\r\n *\r\n * _.isTypedArray(new Uint8Array);\r\n * // => true\r\n *\r\n * _.isTypedArray([]);\r\n * // => false\r\n */\r\n\r\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\r\nmodule.exports = isTypedArray;\r\n\r\n/***/ }),\r\n/* 54 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @param {string} key The key of the property to get.\r\n * @returns {*} Returns the property value.\r\n */\r\nfunction safeGet(object, key) {\r\n  if (key === 'constructor' && typeof object[key] === 'function') {\r\n    return;\r\n  }\r\n\r\n  if (key == '__proto__') {\r\n    return;\r\n  }\r\n\r\n  return object[key];\r\n}\r\n\r\nmodule.exports = safeGet;\r\n\r\n/***/ }),\r\n/* 55 */\r\n/***/ (function(module, exports, __nested_webpack_require_103664__) {\r\n\r\nvar baseAssignValue = __nested_webpack_require_103664__(37),\r\n    eq = __nested_webpack_require_103664__(26);\r\n/** Used for built-in method references. */\r\n\r\n\r\nvar objectProto = Object.prototype;\r\n/** Used to check objects for own properties. */\r\n\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n/**\r\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\r\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n * for equality comparisons.\r\n *\r\n * @private\r\n * @param {Object} object The object to modify.\r\n * @param {string} key The key of the property to assign.\r\n * @param {*} value The value to assign.\r\n */\r\n\r\nfunction assignValue(object, key, value) {\r\n  var objValue = object[key];\r\n\r\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {\r\n    baseAssignValue(object, key, value);\r\n  }\r\n}\r\n\r\nmodule.exports = assignValue;\r\n\r\n/***/ }),\r\n/* 56 */\r\n/***/ (function(module, exports, __nested_webpack_require_104670__) {\r\n\r\nvar arrayLikeKeys = __nested_webpack_require_104670__(141),\r\n    baseKeysIn = __nested_webpack_require_104670__(143),\r\n    isArrayLike = __nested_webpack_require_104670__(39);\r\n/**\r\n * Creates an array of the own and inherited enumerable property names of `object`.\r\n *\r\n * **Note:** Non-object values are coerced to objects.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 3.0.0\r\n * @category Object\r\n * @param {Object} object The object to query.\r\n * @returns {Array} Returns the array of property names.\r\n * @example\r\n *\r\n * function Foo() {\r\n *   this.a = 1;\r\n *   this.b = 2;\r\n * }\r\n *\r\n * Foo.prototype.c = 3;\r\n *\r\n * _.keysIn(new Foo);\r\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\r\n */\r\n\r\n\r\nfunction keysIn(object) {\r\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\r\n}\r\n\r\nmodule.exports = keysIn;\r\n\r\n/***/ }),\r\n/* 57 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * This method returns the first argument it receives.\r\n *\r\n * @static\r\n * @since 0.1.0\r\n * @memberOf _\r\n * @category Util\r\n * @param {*} value Any value.\r\n * @returns {*} Returns `value`.\r\n * @example\r\n *\r\n * var object = { 'a': 1 };\r\n *\r\n * console.log(_.identity(object) === object);\r\n * // => true\r\n */\r\nfunction identity(value) {\r\n  return value;\r\n}\r\n\r\nmodule.exports = identity;\r\n\r\n/***/ }),\r\n/* 58 */\r\n/***/ (function(module, exports, __nested_webpack_require_106012__) {\r\n\r\nvar apply = __nested_webpack_require_106012__(147);\r\n/* Built-in method references for those with the same name as other `lodash` methods. */\r\n\r\n\r\nvar nativeMax = Math.max;\r\n/**\r\n * A specialized version of `baseRest` which transforms the rest array.\r\n *\r\n * @private\r\n * @param {Function} func The function to apply a rest parameter to.\r\n * @param {number} [start=func.length-1] The start position of the rest parameter.\r\n * @param {Function} transform The rest array transform.\r\n * @returns {Function} Returns the new function.\r\n */\r\n\r\nfunction overRest(func, start, transform) {\r\n  start = nativeMax(start === undefined ? func.length - 1 : start, 0);\r\n  return function () {\r\n    var args = arguments,\r\n        index = -1,\r\n        length = nativeMax(args.length - start, 0),\r\n        array = Array(length);\r\n\r\n    while (++index < length) {\r\n      array[index] = args[start + index];\r\n    }\r\n\r\n    index = -1;\r\n    var otherArgs = Array(start + 1);\r\n\r\n    while (++index < start) {\r\n      otherArgs[index] = args[index];\r\n    }\r\n\r\n    otherArgs[start] = transform(array);\r\n    return apply(func, this, otherArgs);\r\n  };\r\n}\r\n\r\nmodule.exports = overRest;\r\n\r\n/***/ }),\r\n/* 59 */\r\n/***/ (function(module, exports, __nested_webpack_require_107238__) {\r\n\r\nvar baseSetToString = __nested_webpack_require_107238__(148),\r\n    shortOut = __nested_webpack_require_107238__(150);\r\n/**\r\n * Sets the `toString` method of `func` to return `string`.\r\n *\r\n * @private\r\n * @param {Function} func The function to modify.\r\n * @param {Function} string The `toString` result.\r\n * @returns {Function} Returns `func`.\r\n */\r\n\r\n\r\nvar setToString = shortOut(baseSetToString);\r\nmodule.exports = setToString;\r\n\r\n/***/ }),\r\n/* 60 */\r\n/***/ (function(module, exports, __nested_webpack_require_107723__) {\r\n\r\nvar arrayLikeToArray = __nested_webpack_require_107723__(61);\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) {\r\n  if (!o) return;\r\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\r\n  var n = Object.prototype.toString.call(o).slice(8, -1);\r\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\r\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\r\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\r\n}\r\n\r\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 61 */\r\n/***/ (function(module, exports) {\r\n\r\nfunction _arrayLikeToArray(arr, len) {\r\n  if (len == null || len > arr.length) len = arr.length;\r\n\r\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\r\n    arr2[i] = arr[i];\r\n  }\r\n\r\n  return arr2;\r\n}\r\n\r\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 62 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = 0.000001;\r\n\r\n/***/ }),\r\n/* 63 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = create;\r\n/**\r\n * Creates a new, empty vec2\r\n *\r\n * @returns {vec2} a new 2D vector\r\n */\r\n\r\nfunction create() {\r\n  var out = new Float32Array(2);\r\n  out[0] = 0;\r\n  out[1] = 0;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 64 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = subtract;\r\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction subtract(out, a, b) {\r\n  out[0] = a[0] - b[0];\r\n  out[1] = a[1] - b[1];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 65 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = multiply;\r\n/**\r\n * Multiplies two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction multiply(out, a, b) {\r\n  out[0] = a[0] * b[0];\r\n  out[1] = a[1] * b[1];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 66 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = divide;\r\n/**\r\n * Divides two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction divide(out, a, b) {\r\n  out[0] = a[0] / b[0];\r\n  out[1] = a[1] / b[1];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 67 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = distance;\r\n/**\r\n * Calculates the euclidian distance between two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\r\n\r\nfunction distance(a, b) {\r\n  var x = b[0] - a[0],\r\n      y = b[1] - a[1];\r\n  return Math.sqrt(x * x + y * y);\r\n}\r\n\r\n/***/ }),\r\n/* 68 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = squaredDistance;\r\n/**\r\n * Calculates the squared euclidian distance between two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\r\n\r\nfunction squaredDistance(a, b) {\r\n  var x = b[0] - a[0],\r\n      y = b[1] - a[1];\r\n  return x * x + y * y;\r\n}\r\n\r\n/***/ }),\r\n/* 69 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = length;\r\n/**\r\n * Calculates the length of a vec2\r\n *\r\n * @param {vec2} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\r\n\r\nfunction length(a) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  return Math.sqrt(x * x + y * y);\r\n}\r\n\r\n/***/ }),\r\n/* 70 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = squaredLength;\r\n/**\r\n * Calculates the squared length of a vec2\r\n *\r\n * @param {vec2} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\r\n\r\nfunction squaredLength(a) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  return x * x + y * y;\r\n}\r\n\r\n/***/ }),\r\n/* 71 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = 0.000001;\r\n\r\n/***/ }),\r\n/* 72 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = create;\r\n/**\r\n * Creates a new, empty vec3\r\n *\r\n * @returns {vec3} a new 3D vector\r\n */\r\n\r\nfunction create() {\r\n  var out = new Float32Array(3);\r\n  out[0] = 0;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 73 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = fromValues;\r\n/**\r\n * Creates a new vec3 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} a new 3D vector\r\n */\r\n\r\nfunction fromValues(x, y, z) {\r\n  var out = new Float32Array(3);\r\n  out[0] = x;\r\n  out[1] = y;\r\n  out[2] = z;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 74 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = normalize;\r\n/**\r\n * Normalize a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to normalize\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction normalize(out, a) {\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2];\r\n  var len = x * x + y * y + z * z;\r\n\r\n  if (len > 0) {\r\n    //TODO: evaluate use of glm_invsqrt here?\r\n    len = 1 / Math.sqrt(len);\r\n    out[0] = a[0] * len;\r\n    out[1] = a[1] * len;\r\n    out[2] = a[2] * len;\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 75 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = dot;\r\n/**\r\n * Calculates the dot product of two vec3's\r\n *\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\r\n\r\nfunction dot(a, b) {\r\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\r\n}\r\n\r\n/***/ }),\r\n/* 76 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = subtract;\r\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction subtract(out, a, b) {\r\n  out[0] = a[0] - b[0];\r\n  out[1] = a[1] - b[1];\r\n  out[2] = a[2] - b[2];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 77 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = multiply;\r\n/**\r\n * Multiplies two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction multiply(out, a, b) {\r\n  out[0] = a[0] * b[0];\r\n  out[1] = a[1] * b[1];\r\n  out[2] = a[2] * b[2];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 78 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = divide;\r\n/**\r\n * Divides two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction divide(out, a, b) {\r\n  out[0] = a[0] / b[0];\r\n  out[1] = a[1] / b[1];\r\n  out[2] = a[2] / b[2];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 79 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = distance;\r\n/**\r\n * Calculates the euclidian distance between two vec3's\r\n *\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\r\n\r\nfunction distance(a, b) {\r\n  var x = b[0] - a[0],\r\n      y = b[1] - a[1],\r\n      z = b[2] - a[2];\r\n  return Math.sqrt(x * x + y * y + z * z);\r\n}\r\n\r\n/***/ }),\r\n/* 80 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = squaredDistance;\r\n/**\r\n * Calculates the squared euclidian distance between two vec3's\r\n *\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\r\n\r\nfunction squaredDistance(a, b) {\r\n  var x = b[0] - a[0],\r\n      y = b[1] - a[1],\r\n      z = b[2] - a[2];\r\n  return x * x + y * y + z * z;\r\n}\r\n\r\n/***/ }),\r\n/* 81 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = length;\r\n/**\r\n * Calculates the length of a vec3\r\n *\r\n * @param {vec3} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\r\n\r\nfunction length(a) {\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2];\r\n  return Math.sqrt(x * x + y * y + z * z);\r\n}\r\n\r\n/***/ }),\r\n/* 82 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = squaredLength;\r\n/**\r\n * Calculates the squared length of a vec3\r\n *\r\n * @param {vec3} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\r\n\r\nfunction squaredLength(a) {\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2];\r\n  return x * x + y * y + z * z;\r\n}\r\n\r\n/***/ }),\r\n/* 83 */\r\n/***/ (function(module, exports, __nested_webpack_require_116277__) {\r\n\r\nvar arrayWithHoles = __nested_webpack_require_116277__(153);\r\n\r\nvar iterableToArrayLimit = __nested_webpack_require_116277__(154);\r\n\r\nvar unsupportedIterableToArray = __nested_webpack_require_116277__(60);\r\n\r\nvar nonIterableRest = __nested_webpack_require_116277__(155);\r\n\r\nfunction _slicedToArray(arr, i) {\r\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\r\n}\r\n\r\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 84 */\r\n/***/ (function(module, exports, __nested_webpack_require_116851__) {\r\n\r\nmodule.exports = {\r\n  EPSILON: __nested_webpack_require_116851__(71),\r\n  create: __nested_webpack_require_116851__(72),\r\n  clone: __nested_webpack_require_116851__(191),\r\n  angle: __nested_webpack_require_116851__(192),\r\n  fromValues: __nested_webpack_require_116851__(73),\r\n  copy: __nested_webpack_require_116851__(193),\r\n  set: __nested_webpack_require_116851__(194),\r\n  equals: __nested_webpack_require_116851__(195),\r\n  exactEquals: __nested_webpack_require_116851__(196),\r\n  add: __nested_webpack_require_116851__(197),\r\n  subtract: __nested_webpack_require_116851__(76),\r\n  sub: __nested_webpack_require_116851__(198),\r\n  multiply: __nested_webpack_require_116851__(77),\r\n  mul: __nested_webpack_require_116851__(199),\r\n  divide: __nested_webpack_require_116851__(78),\r\n  div: __nested_webpack_require_116851__(200),\r\n  min: __nested_webpack_require_116851__(201),\r\n  max: __nested_webpack_require_116851__(202),\r\n  floor: __nested_webpack_require_116851__(203),\r\n  ceil: __nested_webpack_require_116851__(204),\r\n  round: __nested_webpack_require_116851__(205),\r\n  scale: __nested_webpack_require_116851__(206),\r\n  scaleAndAdd: __nested_webpack_require_116851__(207),\r\n  distance: __nested_webpack_require_116851__(79),\r\n  dist: __nested_webpack_require_116851__(208),\r\n  squaredDistance: __nested_webpack_require_116851__(80),\r\n  sqrDist: __nested_webpack_require_116851__(209),\r\n  length: __nested_webpack_require_116851__(81),\r\n  len: __nested_webpack_require_116851__(210),\r\n  squaredLength: __nested_webpack_require_116851__(82),\r\n  sqrLen: __nested_webpack_require_116851__(211),\r\n  negate: __nested_webpack_require_116851__(212),\r\n  inverse: __nested_webpack_require_116851__(213),\r\n  normalize: __nested_webpack_require_116851__(74),\r\n  dot: __nested_webpack_require_116851__(75),\r\n  cross: __nested_webpack_require_116851__(214),\r\n  lerp: __nested_webpack_require_116851__(215),\r\n  random: __nested_webpack_require_116851__(216),\r\n  transformMat4: __nested_webpack_require_116851__(217),\r\n  transformMat3: __nested_webpack_require_116851__(218),\r\n  transformQuat: __nested_webpack_require_116851__(219),\r\n  rotateX: __nested_webpack_require_116851__(220),\r\n  rotateY: __nested_webpack_require_116851__(221),\r\n  rotateZ: __nested_webpack_require_116851__(222),\r\n  forEach: __nested_webpack_require_116851__(223)\r\n};\r\n\r\n/***/ }),\r\n/* 85 */\r\n/***/ (function(module, exports, __nested_webpack_require_118635__) {\r\n\r\nvar basePick = __nested_webpack_require_118635__(229),\r\n    flatRest = __nested_webpack_require_118635__(243);\r\n/**\r\n * Creates an object composed of the picked `object` properties.\r\n *\r\n * @static\r\n * @since 0.1.0\r\n * @memberOf _\r\n * @category Object\r\n * @param {Object} object The source object.\r\n * @param {...(string|string[])} [paths] The property paths to pick.\r\n * @returns {Object} Returns the new object.\r\n * @example\r\n *\r\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\r\n *\r\n * _.pick(object, ['a', 'c']);\r\n * // => { 'a': 1, 'c': 3 }\r\n */\r\n\r\n\r\nvar pick = flatRest(function (object, paths) {\r\n  return object == null ? {} : basePick(object, paths);\r\n});\r\nmodule.exports = pick;\r\n\r\n/***/ }),\r\n/* 86 */\r\n/***/ (function(module, exports, __nested_webpack_require_119376__) {\r\n\r\nvar getPrototypeOf = __nested_webpack_require_119376__(2);\r\n\r\nvar setPrototypeOf = __nested_webpack_require_119376__(41);\r\n\r\nvar isNativeFunction = __nested_webpack_require_119376__(248);\r\n\r\nvar construct = __nested_webpack_require_119376__(249);\r\n\r\nfunction _wrapNativeSuper(Class) {\r\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\r\n\r\n  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\r\n    if (Class === null || !isNativeFunction(Class)) return Class;\r\n\r\n    if (typeof Class !== \"function\") {\r\n      throw new TypeError(\"Super expression must either be null or a function\");\r\n    }\r\n\r\n    if (typeof _cache !== \"undefined\") {\r\n      if (_cache.has(Class)) return _cache.get(Class);\r\n\r\n      _cache.set(Class, Wrapper);\r\n    }\r\n\r\n    function Wrapper() {\r\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\r\n    }\r\n\r\n    Wrapper.prototype = Object.create(Class.prototype, {\r\n      constructor: {\r\n        value: Wrapper,\r\n        enumerable: false,\r\n        writable: true,\r\n        configurable: true\r\n      }\r\n    });\r\n    return setPrototypeOf(Wrapper, Class);\r\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n  return _wrapNativeSuper(Class);\r\n}\r\n\r\nmodule.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 87 */\r\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_120785__) {\r\n\r\n\"use strict\";\r\n/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_120785__(21);\r\n\r\n/**\r\n * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization\r\n */\r\n\r\nvar Rasterizer = {\r\n  createContour2D: function createContour2D() {\r\n    return {\r\n      dir: null,\r\n      index: null,\r\n      firstVertex: null,\r\n      insideContours: null,\r\n      nextpeer: null,\r\n      prevpeer: null\r\n    };\r\n  },\r\n  CONTOUR_DIR: {\r\n    CW_DIR: 0,\r\n    CCW_DIR: 1,\r\n    UNKNOWN_DIR: 2\r\n  },\r\n  DIR: {\r\n    OUTSIDE_EDGE: -32767,\r\n    INSIDE_EDGE: -32766\r\n  },\r\n  create: function create(imageWrapper, labelWrapper) {\r\n    var imageData = imageWrapper.data;\r\n    var labelData = labelWrapper.data;\r\n    var width = imageWrapper.size.x;\r\n    var height = imageWrapper.size.y;\r\n    var tracer = _tracer__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"].create(imageWrapper, labelWrapper);\r\n    return {\r\n      rasterize: function rasterize(depthlabel) {\r\n        var color;\r\n        var bc;\r\n        var lc;\r\n        var labelindex;\r\n        var cx;\r\n        var cy;\r\n        var colorMap = [];\r\n        var vertex;\r\n        var p;\r\n        var cc;\r\n        var sc;\r\n        var pos;\r\n        var connectedCount = 0;\r\n        var i;\r\n\r\n        for (i = 0; i < 400; i++) {\r\n          colorMap[i] = 0;\r\n        }\r\n\r\n        colorMap[0] = imageData[0];\r\n        cc = null;\r\n\r\n        for (cy = 1; cy < height - 1; cy++) {\r\n          labelindex = 0;\r\n          bc = colorMap[0];\r\n\r\n          for (cx = 1; cx < width - 1; cx++) {\r\n            pos = cy * width + cx;\r\n\r\n            if (labelData[pos] === 0) {\r\n              color = imageData[pos];\r\n\r\n              if (color !== bc) {\r\n                if (labelindex === 0) {\r\n                  lc = connectedCount + 1;\r\n                  colorMap[lc] = color;\r\n                  bc = color;\r\n                  vertex = tracer.contourTracing(cy, cx, lc, color, Rasterizer.DIR.OUTSIDE_EDGE);\r\n\r\n                  if (vertex !== null) {\r\n                    connectedCount++;\r\n                    labelindex = lc;\r\n                    p = Rasterizer.createContour2D();\r\n                    p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;\r\n                    p.index = labelindex;\r\n                    p.firstVertex = vertex;\r\n                    p.nextpeer = cc;\r\n                    p.insideContours = null;\r\n\r\n                    if (cc !== null) {\r\n                      cc.prevpeer = p;\r\n                    }\r\n\r\n                    cc = p;\r\n                  }\r\n                } else {\r\n                  vertex = tracer.contourTracing(cy, cx, Rasterizer.DIR.INSIDE_EDGE, color, labelindex);\r\n\r\n                  if (vertex !== null) {\r\n                    p = Rasterizer.createContour2D();\r\n                    p.firstVertex = vertex;\r\n                    p.insideContours = null;\r\n\r\n                    if (depthlabel === 0) {\r\n                      p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;\r\n                    } else {\r\n                      p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;\r\n                    }\r\n\r\n                    p.index = depthlabel;\r\n                    sc = cc;\r\n\r\n                    while (sc !== null && sc.index !== labelindex) {\r\n                      sc = sc.nextpeer;\r\n                    }\r\n\r\n                    if (sc !== null) {\r\n                      p.nextpeer = sc.insideContours;\r\n\r\n                      if (sc.insideContours !== null) {\r\n                        sc.insideContours.prevpeer = p;\r\n                      }\r\n\r\n                      sc.insideContours = p;\r\n                    }\r\n                  }\r\n                }\r\n              } else {\r\n                labelData[pos] = labelindex;\r\n              }\r\n            } else if (labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE || labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {\r\n              labelindex = 0;\r\n\r\n              if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {\r\n                bc = imageData[pos];\r\n              } else {\r\n                bc = colorMap[0];\r\n              }\r\n            } else {\r\n              labelindex = labelData[pos];\r\n              bc = colorMap[labelindex];\r\n            }\r\n          }\r\n        }\r\n\r\n        sc = cc;\r\n\r\n        while (sc !== null) {\r\n          sc.index = depthlabel;\r\n          sc = sc.nextpeer;\r\n        }\r\n\r\n        return {\r\n          cc: cc,\r\n          count: connectedCount\r\n        };\r\n      },\r\n      debug: {\r\n        drawContour: function drawContour(canvas, firstContour) {\r\n          var ctx = canvas.getContext('2d');\r\n          var pq = firstContour;\r\n          var iq;\r\n          var q;\r\n          var p;\r\n          ctx.strokeStyle = 'red';\r\n          ctx.fillStyle = 'red';\r\n          ctx.lineWidth = 1;\r\n\r\n          if (pq !== null) {\r\n            iq = pq.insideContours;\r\n          } else {\r\n            iq = null;\r\n          }\r\n\r\n          while (pq !== null) {\r\n            if (iq !== null) {\r\n              q = iq;\r\n              iq = iq.nextpeer;\r\n            } else {\r\n              q = pq;\r\n              pq = pq.nextpeer;\r\n\r\n              if (pq !== null) {\r\n                iq = pq.insideContours;\r\n              } else {\r\n                iq = null;\r\n              }\r\n            }\r\n\r\n            switch (q.dir) {\r\n              case Rasterizer.CONTOUR_DIR.CW_DIR:\r\n                ctx.strokeStyle = 'red';\r\n                break;\r\n\r\n              case Rasterizer.CONTOUR_DIR.CCW_DIR:\r\n                ctx.strokeStyle = 'blue';\r\n                break;\r\n\r\n              case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:\r\n                ctx.strokeStyle = 'green';\r\n                break;\r\n            }\r\n\r\n            p = q.firstVertex;\r\n            ctx.beginPath();\r\n            ctx.moveTo(p.x, p.y);\r\n\r\n            do {\r\n              p = p.next;\r\n              ctx.lineTo(p.x, p.y);\r\n            } while (p !== q.firstVertex);\r\n\r\n            ctx.stroke();\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n};\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (Rasterizer);\r\n\r\n/***/ }),\r\n/* 88 */\r\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\r\n\r\n\"use strict\";\r\n/* eslint-disable no-param-reassign */\r\n\r\n/* eslint-disable no-bitwise */\r\n\r\n/* eslint-disable eqeqeq */\r\n\r\n/* @preserve ASM BEGIN */\r\nfunction Skeletonizer(stdlib, foreign, buffer) {\r\n  'use asm';\r\n\r\n  var images = new stdlib.Uint8Array(buffer);\r\n  var size = foreign.size | 0;\r\n  var imul = stdlib.Math.imul;\r\n\r\n  function erode(inImagePtr, outImagePtr) {\r\n    inImagePtr |= 0;\r\n    outImagePtr |= 0;\r\n    var v = 0;\r\n    var u = 0;\r\n    var sum = 0;\r\n    var yStart1 = 0;\r\n    var yStart2 = 0;\r\n    var xStart1 = 0;\r\n    var xStart2 = 0;\r\n    var offset = 0;\r\n\r\n    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {\r\n      offset = offset + size | 0;\r\n\r\n      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {\r\n        yStart1 = offset - size | 0;\r\n        yStart2 = offset + size | 0;\r\n        xStart1 = u - 1 | 0;\r\n        xStart2 = u + 1 | 0;\r\n        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;\r\n\r\n        if ((sum | 0) == (5 | 0)) {\r\n          images[outImagePtr + offset + u | 0] = 1;\r\n        } else {\r\n          images[outImagePtr + offset + u | 0] = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function subtract(aImagePtr, bImagePtr, outImagePtr) {\r\n    aImagePtr |= 0;\r\n    bImagePtr |= 0;\r\n    outImagePtr |= 0;\r\n    var length = 0;\r\n    length = imul(size, size) | 0;\r\n\r\n    while ((length | 0) > 0) {\r\n      length = length - 1 | 0;\r\n      images[outImagePtr + length | 0] = (images[aImagePtr + length | 0] | 0) - (images[bImagePtr + length | 0] | 0) | 0;\r\n    }\r\n  }\r\n\r\n  function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {\r\n    aImagePtr |= 0;\r\n    bImagePtr |= 0;\r\n    outImagePtr |= 0;\r\n    var length = 0;\r\n    length = imul(size, size) | 0;\r\n\r\n    while ((length | 0) > 0) {\r\n      length = length - 1 | 0;\r\n      images[outImagePtr + length | 0] = images[aImagePtr + length | 0] | 0 | (images[bImagePtr + length | 0] | 0) | 0;\r\n    }\r\n  }\r\n\r\n  function countNonZero(imagePtr) {\r\n    imagePtr |= 0;\r\n    var sum = 0;\r\n    var length = 0;\r\n    length = imul(size, size) | 0;\r\n\r\n    while ((length | 0) > 0) {\r\n      length = length - 1 | 0;\r\n      sum = (sum | 0) + (images[imagePtr + length | 0] | 0) | 0;\r\n    }\r\n\r\n    return sum | 0;\r\n  }\r\n\r\n  function init(imagePtr, value) {\r\n    imagePtr |= 0;\r\n    value |= 0;\r\n    var length = 0;\r\n    length = imul(size, size) | 0;\r\n\r\n    while ((length | 0) > 0) {\r\n      length = length - 1 | 0;\r\n      images[imagePtr + length | 0] = value;\r\n    }\r\n  }\r\n\r\n  function dilate(inImagePtr, outImagePtr) {\r\n    inImagePtr |= 0;\r\n    outImagePtr |= 0;\r\n    var v = 0;\r\n    var u = 0;\r\n    var sum = 0;\r\n    var yStart1 = 0;\r\n    var yStart2 = 0;\r\n    var xStart1 = 0;\r\n    var xStart2 = 0;\r\n    var offset = 0;\r\n\r\n    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {\r\n      offset = offset + size | 0;\r\n\r\n      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {\r\n        yStart1 = offset - size | 0;\r\n        yStart2 = offset + size | 0;\r\n        xStart1 = u - 1 | 0;\r\n        xStart2 = u + 1 | 0;\r\n        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;\r\n\r\n        if ((sum | 0) > (0 | 0)) {\r\n          images[outImagePtr + offset + u | 0] = 1;\r\n        } else {\r\n          images[outImagePtr + offset + u | 0] = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function memcpy(srcImagePtr, dstImagePtr) {\r\n    srcImagePtr |= 0;\r\n    dstImagePtr |= 0;\r\n    var length = 0;\r\n    length = imul(size, size) | 0;\r\n\r\n    while ((length | 0) > 0) {\r\n      length = length - 1 | 0;\r\n      images[dstImagePtr + length | 0] = images[srcImagePtr + length | 0] | 0;\r\n    }\r\n  }\r\n\r\n  function zeroBorder(imagePtr) {\r\n    imagePtr |= 0;\r\n    var x = 0;\r\n    var y = 0;\r\n\r\n    for (x = 0; (x | 0) < (size - 1 | 0); x = x + 1 | 0) {\r\n      images[imagePtr + x | 0] = 0;\r\n      images[imagePtr + y | 0] = 0;\r\n      y = y + size - 1 | 0;\r\n      images[imagePtr + y | 0] = 0;\r\n      y = y + 1 | 0;\r\n    }\r\n\r\n    for (x = 0; (x | 0) < (size | 0); x = x + 1 | 0) {\r\n      images[imagePtr + y | 0] = 0;\r\n      y = y + 1 | 0;\r\n    }\r\n  }\r\n\r\n  function skeletonize() {\r\n    var subImagePtr = 0;\r\n    var erodedImagePtr = 0;\r\n    var tempImagePtr = 0;\r\n    var skelImagePtr = 0;\r\n    var sum = 0;\r\n    var done = 0;\r\n    erodedImagePtr = imul(size, size) | 0;\r\n    tempImagePtr = erodedImagePtr + erodedImagePtr | 0;\r\n    skelImagePtr = tempImagePtr + erodedImagePtr | 0; // init skel-image\r\n\r\n    init(skelImagePtr, 0);\r\n    zeroBorder(subImagePtr);\r\n\r\n    do {\r\n      erode(subImagePtr, erodedImagePtr);\r\n      dilate(erodedImagePtr, tempImagePtr);\r\n      subtract(subImagePtr, tempImagePtr, tempImagePtr);\r\n      bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);\r\n      memcpy(erodedImagePtr, subImagePtr);\r\n      sum = countNonZero(subImagePtr) | 0;\r\n      done = (sum | 0) == 0 | 0;\r\n    } while (!done);\r\n  }\r\n\r\n  return {\r\n    skeletonize: skeletonize\r\n  };\r\n}\r\n/* @preserve ASM END */\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (Skeletonizer);\r\n/* eslint-enable eqeqeq */\r\n\r\n/***/ }),\r\n/* 89 */\r\n/***/ (function(module, exports, __nested_webpack_require_132367__) {\r\n\r\nmodule.exports = __nested_webpack_require_132367__(263);\r\n\r\n\r\n/***/ }),\r\n/* 90 */\r\n/***/ (function(module, exports, __nested_webpack_require_132495__) {\r\n\r\nvar Stack = __nested_webpack_require_132495__(91),\r\n    assignMergeValue = __nested_webpack_require_132495__(48),\r\n    baseFor = __nested_webpack_require_132495__(121),\r\n    baseMergeDeep = __nested_webpack_require_132495__(123),\r\n    isObject = __nested_webpack_require_132495__(15),\r\n    keysIn = __nested_webpack_require_132495__(56),\r\n    safeGet = __nested_webpack_require_132495__(54);\r\n/**\r\n * The base implementation of `_.merge` without support for multiple sources.\r\n *\r\n * @private\r\n * @param {Object} object The destination object.\r\n * @param {Object} source The source object.\r\n * @param {number} srcIndex The index of `source`.\r\n * @param {Function} [customizer] The function to customize merged values.\r\n * @param {Object} [stack] Tracks traversed source values and their merged\r\n *  counterparts.\r\n */\r\n\r\n\r\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\r\n  if (object === source) {\r\n    return;\r\n  }\r\n\r\n  baseFor(source, function (srcValue, key) {\r\n    stack || (stack = new Stack());\r\n\r\n    if (isObject(srcValue)) {\r\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\r\n    } else {\r\n      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;\r\n\r\n      if (newValue === undefined) {\r\n        newValue = srcValue;\r\n      }\r\n\r\n      assignMergeValue(object, key, newValue);\r\n    }\r\n  }, keysIn);\r\n}\r\n\r\nmodule.exports = baseMerge;\r\n\r\n/***/ }),\r\n/* 91 */\r\n/***/ (function(module, exports, __nested_webpack_require_133938__) {\r\n\r\nvar ListCache = __nested_webpack_require_133938__(24),\r\n    stackClear = __nested_webpack_require_133938__(97),\r\n    stackDelete = __nested_webpack_require_133938__(98),\r\n    stackGet = __nested_webpack_require_133938__(99),\r\n    stackHas = __nested_webpack_require_133938__(100),\r\n    stackSet = __nested_webpack_require_133938__(101);\r\n/**\r\n * Creates a stack cache object to store key-value pairs.\r\n *\r\n * @private\r\n * @constructor\r\n * @param {Array} [entries] The key-value pairs to cache.\r\n */\r\n\r\n\r\nfunction Stack(entries) {\r\n  var data = this.__data__ = new ListCache(entries);\r\n  this.size = data.size;\r\n} // Add methods to `Stack`.\r\n\r\n\r\nStack.prototype.clear = stackClear;\r\nStack.prototype['delete'] = stackDelete;\r\nStack.prototype.get = stackGet;\r\nStack.prototype.has = stackHas;\r\nStack.prototype.set = stackSet;\r\nmodule.exports = Stack;\r\n\r\n/***/ }),\r\n/* 92 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * Removes all key-value entries from the list cache.\r\n *\r\n * @private\r\n * @name clear\r\n * @memberOf ListCache\r\n */\r\nfunction listCacheClear() {\r\n  this.__data__ = [];\r\n  this.size = 0;\r\n}\r\n\r\nmodule.exports = listCacheClear;\r\n\r\n/***/ }),\r\n/* 93 */\r\n/***/ (function(module, exports, __nested_webpack_require_135076__) {\r\n\r\nvar assocIndexOf = __nested_webpack_require_135076__(25);\r\n/** Used for built-in method references. */\r\n\r\n\r\nvar arrayProto = Array.prototype;\r\n/** Built-in value references. */\r\n\r\nvar splice = arrayProto.splice;\r\n/**\r\n * Removes `key` and its value from the list cache.\r\n *\r\n * @private\r\n * @name delete\r\n * @memberOf ListCache\r\n * @param {string} key The key of the value to remove.\r\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n */\r\n\r\nfunction listCacheDelete(key) {\r\n  var data = this.__data__,\r\n      index = assocIndexOf(data, key);\r\n\r\n  if (index < 0) {\r\n    return false;\r\n  }\r\n\r\n  var lastIndex = data.length - 1;\r\n\r\n  if (index == lastIndex) {\r\n    data.pop();\r\n  } else {\r\n    splice.call(data, index, 1);\r\n  }\r\n\r\n  --this.size;\r\n  return true;\r\n}\r\n\r\nmodule.exports = listCacheDelete;\r\n\r\n/***/ }),\r\n/* 94 */\r\n/***/ (function(module, exports, __nested_webpack_require_135973__) {\r\n\r\nvar assocIndexOf = __nested_webpack_require_135973__(25);\r\n/**\r\n * Gets the list cache value for `key`.\r\n *\r\n * @private\r\n * @name get\r\n * @memberOf ListCache\r\n * @param {string} key The key of the value to get.\r\n * @returns {*} Returns the entry value.\r\n */\r\n\r\n\r\nfunction listCacheGet(key) {\r\n  var data = this.__data__,\r\n      index = assocIndexOf(data, key);\r\n  return index < 0 ? undefined : data[index][1];\r\n}\r\n\r\nmodule.exports = listCacheGet;\r\n\r\n/***/ }),\r\n/* 95 */\r\n/***/ (function(module, exports, __nested_webpack_require_136491__) {\r\n\r\nvar assocIndexOf = __nested_webpack_require_136491__(25);\r\n/**\r\n * Checks if a list cache value for `key` exists.\r\n *\r\n * @private\r\n * @name has\r\n * @memberOf ListCache\r\n * @param {string} key The key of the entry to check.\r\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n */\r\n\r\n\r\nfunction listCacheHas(key) {\r\n  return assocIndexOf(this.__data__, key) > -1;\r\n}\r\n\r\nmodule.exports = listCacheHas;\r\n\r\n/***/ }),\r\n/* 96 */\r\n/***/ (function(module, exports, __nested_webpack_require_136991__) {\r\n\r\nvar assocIndexOf = __nested_webpack_require_136991__(25);\r\n/**\r\n * Sets the list cache `key` to `value`.\r\n *\r\n * @private\r\n * @name set\r\n * @memberOf ListCache\r\n * @param {string} key The key of the value to set.\r\n * @param {*} value The value to set.\r\n * @returns {Object} Returns the list cache instance.\r\n */\r\n\r\n\r\nfunction listCacheSet(key, value) {\r\n  var data = this.__data__,\r\n      index = assocIndexOf(data, key);\r\n\r\n  if (index < 0) {\r\n    ++this.size;\r\n    data.push([key, value]);\r\n  } else {\r\n    data[index][1] = value;\r\n  }\r\n\r\n  return this;\r\n}\r\n\r\nmodule.exports = listCacheSet;\r\n\r\n/***/ }),\r\n/* 97 */\r\n/***/ (function(module, exports, __nested_webpack_require_137653__) {\r\n\r\nvar ListCache = __nested_webpack_require_137653__(24);\r\n/**\r\n * Removes all key-value entries from the stack.\r\n *\r\n * @private\r\n * @name clear\r\n * @memberOf Stack\r\n */\r\n\r\n\r\nfunction stackClear() {\r\n  this.__data__ = new ListCache();\r\n  this.size = 0;\r\n}\r\n\r\nmodule.exports = stackClear;\r\n\r\n/***/ }),\r\n/* 98 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * Removes `key` and its value from the stack.\r\n *\r\n * @private\r\n * @name delete\r\n * @memberOf Stack\r\n * @param {string} key The key of the value to remove.\r\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n */\r\nfunction stackDelete(key) {\r\n  var data = this.__data__,\r\n      result = data['delete'](key);\r\n  this.size = data.size;\r\n  return result;\r\n}\r\n\r\nmodule.exports = stackDelete;\r\n\r\n/***/ }),\r\n/* 99 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * Gets the stack value for `key`.\r\n *\r\n * @private\r\n * @name get\r\n * @memberOf Stack\r\n * @param {string} key The key of the value to get.\r\n * @returns {*} Returns the entry value.\r\n */\r\nfunction stackGet(key) {\r\n  return this.__data__.get(key);\r\n}\r\n\r\nmodule.exports = stackGet;\r\n\r\n/***/ }),\r\n/* 100 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * Checks if a stack value for `key` exists.\r\n *\r\n * @private\r\n * @name has\r\n * @memberOf Stack\r\n * @param {string} key The key of the entry to check.\r\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n */\r\nfunction stackHas(key) {\r\n  return this.__data__.has(key);\r\n}\r\n\r\nmodule.exports = stackHas;\r\n\r\n/***/ }),\r\n/* 101 */\r\n/***/ (function(module, exports, __nested_webpack_require_139236__) {\r\n\r\nvar ListCache = __nested_webpack_require_139236__(24),\r\n    Map = __nested_webpack_require_139236__(44),\r\n    MapCache = __nested_webpack_require_139236__(47);\r\n/** Used as the size to enable large array optimizations. */\r\n\r\n\r\nvar LARGE_ARRAY_SIZE = 200;\r\n/**\r\n * Sets the stack `key` to `value`.\r\n *\r\n * @private\r\n * @name set\r\n * @memberOf Stack\r\n * @param {string} key The key of the value to set.\r\n * @param {*} value The value to set.\r\n * @returns {Object} Returns the stack cache instance.\r\n */\r\n\r\nfunction stackSet(key, value) {\r\n  var data = this.__data__;\r\n\r\n  if (data instanceof ListCache) {\r\n    var pairs = data.__data__;\r\n\r\n    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {\r\n      pairs.push([key, value]);\r\n      this.size = ++data.size;\r\n      return this;\r\n    }\r\n\r\n    data = this.__data__ = new MapCache(pairs);\r\n  }\r\n\r\n  data.set(key, value);\r\n  this.size = data.size;\r\n  return this;\r\n}\r\n\r\nmodule.exports = stackSet;\r\n\r\n/***/ }),\r\n/* 102 */\r\n/***/ (function(module, exports, __nested_webpack_require_140221__) {\r\n\r\nvar isFunction = __nested_webpack_require_140221__(36),\r\n    isMasked = __nested_webpack_require_140221__(105),\r\n    isObject = __nested_webpack_require_140221__(15),\r\n    toSource = __nested_webpack_require_140221__(107);\r\n/**\r\n * Used to match `RegExp`\r\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\r\n */\r\n\r\n\r\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\r\n/** Used to detect host constructors (Safari). */\r\n\r\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\r\n/** Used for built-in method references. */\r\n\r\nvar funcProto = Function.prototype,\r\n    objectProto = Object.prototype;\r\n/** Used to resolve the decompiled source of functions. */\r\n\r\nvar funcToString = funcProto.toString;\r\n/** Used to check objects for own properties. */\r\n\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n/** Used to detect if a method is native. */\r\n\r\nvar reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\r\n/**\r\n * The base implementation of `_.isNative` without bad shim checks.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a native function,\r\n *  else `false`.\r\n */\r\n\r\nfunction baseIsNative(value) {\r\n  if (!isObject(value) || isMasked(value)) {\r\n    return false;\r\n  }\r\n\r\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\r\n  return pattern.test(toSource(value));\r\n}\r\n\r\nmodule.exports = baseIsNative;\r\n\r\n/***/ }),\r\n/* 103 */\r\n/***/ (function(module, exports, __nested_webpack_require_141769__) {\r\n\r\nvar Symbol = __nested_webpack_require_141769__(27);\r\n/** Used for built-in method references. */\r\n\r\n\r\nvar objectProto = Object.prototype;\r\n/** Used to check objects for own properties. */\r\n\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n/**\r\n * Used to resolve the\r\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\r\n * of values.\r\n */\r\n\r\nvar nativeObjectToString = objectProto.toString;\r\n/** Built-in value references. */\r\n\r\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\r\n/**\r\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\r\n *\r\n * @private\r\n * @param {*} value The value to query.\r\n * @returns {string} Returns the raw `toStringTag`.\r\n */\r\n\r\nfunction getRawTag(value) {\r\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\r\n      tag = value[symToStringTag];\r\n\r\n  try {\r\n    value[symToStringTag] = undefined;\r\n    var unmasked = true;\r\n  } catch (e) {}\r\n\r\n  var result = nativeObjectToString.call(value);\r\n\r\n  if (unmasked) {\r\n    if (isOwn) {\r\n      value[symToStringTag] = tag;\r\n    } else {\r\n      delete value[symToStringTag];\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports = getRawTag;\r\n\r\n/***/ }),\r\n/* 104 */\r\n/***/ (function(module, exports) {\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n/**\r\n * Used to resolve the\r\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\r\n * of values.\r\n */\r\n\r\nvar nativeObjectToString = objectProto.toString;\r\n/**\r\n * Converts `value` to a string using `Object.prototype.toString`.\r\n *\r\n * @private\r\n * @param {*} value The value to convert.\r\n * @returns {string} Returns the converted string.\r\n */\r\n\r\nfunction objectToString(value) {\r\n  return nativeObjectToString.call(value);\r\n}\r\n\r\nmodule.exports = objectToString;\r\n\r\n/***/ }),\r\n/* 105 */\r\n/***/ (function(module, exports, __nested_webpack_require_143695__) {\r\n\r\nvar coreJsData = __nested_webpack_require_143695__(106);\r\n/** Used to detect methods masquerading as native. */\r\n\r\n\r\nvar maskSrcKey = function () {\r\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\r\n  return uid ? 'Symbol(src)_1.' + uid : '';\r\n}();\r\n/**\r\n * Checks if `func` has its source masked.\r\n *\r\n * @private\r\n * @param {Function} func The function to check.\r\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\r\n */\r\n\r\n\r\nfunction isMasked(func) {\r\n  return !!maskSrcKey && maskSrcKey in func;\r\n}\r\n\r\nmodule.exports = isMasked;\r\n\r\n/***/ }),\r\n/* 106 */\r\n/***/ (function(module, exports, __nested_webpack_require_144361__) {\r\n\r\nvar root = __nested_webpack_require_144361__(18);\r\n/** Used to detect overreaching core-js shims. */\r\n\r\n\r\nvar coreJsData = root['__core-js_shared__'];\r\nmodule.exports = coreJsData;\r\n\r\n/***/ }),\r\n/* 107 */\r\n/***/ (function(module, exports) {\r\n\r\n/** Used for built-in method references. */\r\nvar funcProto = Function.prototype;\r\n/** Used to resolve the decompiled source of functions. */\r\n\r\nvar funcToString = funcProto.toString;\r\n/**\r\n * Converts `func` to its source code.\r\n *\r\n * @private\r\n * @param {Function} func The function to convert.\r\n * @returns {string} Returns the source code.\r\n */\r\n\r\nfunction toSource(func) {\r\n  if (func != null) {\r\n    try {\r\n      return funcToString.call(func);\r\n    } catch (e) {}\r\n\r\n    try {\r\n      return func + '';\r\n    } catch (e) {}\r\n  }\r\n\r\n  return '';\r\n}\r\n\r\nmodule.exports = toSource;\r\n\r\n/***/ }),\r\n/* 108 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * Gets the value at `key` of `object`.\r\n *\r\n * @private\r\n * @param {Object} [object] The object to query.\r\n * @param {string} key The key of the property to get.\r\n * @returns {*} Returns the property value.\r\n */\r\nfunction getValue(object, key) {\r\n  return object == null ? undefined : object[key];\r\n}\r\n\r\nmodule.exports = getValue;\r\n\r\n/***/ }),\r\n/* 109 */\r\n/***/ (function(module, exports, __nested_webpack_require_145658__) {\r\n\r\nvar Hash = __nested_webpack_require_145658__(110),\r\n    ListCache = __nested_webpack_require_145658__(24),\r\n    Map = __nested_webpack_require_145658__(44);\r\n/**\r\n * Removes all key-value entries from the map.\r\n *\r\n * @private\r\n * @name clear\r\n * @memberOf MapCache\r\n */\r\n\r\n\r\nfunction mapCacheClear() {\r\n  this.size = 0;\r\n  this.__data__ = {\r\n    'hash': new Hash(),\r\n    'map': new (Map || ListCache)(),\r\n    'string': new Hash()\r\n  };\r\n}\r\n\r\nmodule.exports = mapCacheClear;\r\n\r\n/***/ }),\r\n/* 110 */\r\n/***/ (function(module, exports, __nested_webpack_require_146175__) {\r\n\r\nvar hashClear = __nested_webpack_require_146175__(111),\r\n    hashDelete = __nested_webpack_require_146175__(112),\r\n    hashGet = __nested_webpack_require_146175__(113),\r\n    hashHas = __nested_webpack_require_146175__(114),\r\n    hashSet = __nested_webpack_require_146175__(115);\r\n/**\r\n * Creates a hash object.\r\n *\r\n * @private\r\n * @constructor\r\n * @param {Array} [entries] The key-value pairs to cache.\r\n */\r\n\r\n\r\nfunction Hash(entries) {\r\n  var index = -1,\r\n      length = entries == null ? 0 : entries.length;\r\n  this.clear();\r\n\r\n  while (++index < length) {\r\n    var entry = entries[index];\r\n    this.set(entry[0], entry[1]);\r\n  }\r\n} // Add methods to `Hash`.\r\n\r\n\r\nHash.prototype.clear = hashClear;\r\nHash.prototype['delete'] = hashDelete;\r\nHash.prototype.get = hashGet;\r\nHash.prototype.has = hashHas;\r\nHash.prototype.set = hashSet;\r\nmodule.exports = Hash;\r\n\r\n/***/ }),\r\n/* 111 */\r\n/***/ (function(module, exports, __nested_webpack_require_147048__) {\r\n\r\nvar nativeCreate = __nested_webpack_require_147048__(28);\r\n/**\r\n * Removes all key-value entries from the hash.\r\n *\r\n * @private\r\n * @name clear\r\n * @memberOf Hash\r\n */\r\n\r\n\r\nfunction hashClear() {\r\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\r\n  this.size = 0;\r\n}\r\n\r\nmodule.exports = hashClear;\r\n\r\n/***/ }),\r\n/* 112 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * Removes `key` and its value from the hash.\r\n *\r\n * @private\r\n * @name delete\r\n * @memberOf Hash\r\n * @param {Object} hash The hash to modify.\r\n * @param {string} key The key of the value to remove.\r\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n */\r\nfunction hashDelete(key) {\r\n  var result = this.has(key) && delete this.__data__[key];\r\n  this.size -= result ? 1 : 0;\r\n  return result;\r\n}\r\n\r\nmodule.exports = hashDelete;\r\n\r\n/***/ }),\r\n/* 113 */\r\n/***/ (function(module, exports, __nested_webpack_require_147950__) {\r\n\r\nvar nativeCreate = __nested_webpack_require_147950__(28);\r\n/** Used to stand-in for `undefined` hash values. */\r\n\r\n\r\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\r\n/** Used for built-in method references. */\r\n\r\nvar objectProto = Object.prototype;\r\n/** Used to check objects for own properties. */\r\n\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n/**\r\n * Gets the hash value for `key`.\r\n *\r\n * @private\r\n * @name get\r\n * @memberOf Hash\r\n * @param {string} key The key of the value to get.\r\n * @returns {*} Returns the entry value.\r\n */\r\n\r\nfunction hashGet(key) {\r\n  var data = this.__data__;\r\n\r\n  if (nativeCreate) {\r\n    var result = data[key];\r\n    return result === HASH_UNDEFINED ? undefined : result;\r\n  }\r\n\r\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\r\n}\r\n\r\nmodule.exports = hashGet;\r\n\r\n/***/ }),\r\n/* 114 */\r\n/***/ (function(module, exports, __nested_webpack_require_148838__) {\r\n\r\nvar nativeCreate = __nested_webpack_require_148838__(28);\r\n/** Used for built-in method references. */\r\n\r\n\r\nvar objectProto = Object.prototype;\r\n/** Used to check objects for own properties. */\r\n\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n/**\r\n * Checks if a hash value for `key` exists.\r\n *\r\n * @private\r\n * @name has\r\n * @memberOf Hash\r\n * @param {string} key The key of the entry to check.\r\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n */\r\n\r\nfunction hashHas(key) {\r\n  var data = this.__data__;\r\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\r\n}\r\n\r\nmodule.exports = hashHas;\r\n\r\n/***/ }),\r\n/* 115 */\r\n/***/ (function(module, exports, __nested_webpack_require_149567__) {\r\n\r\nvar nativeCreate = __nested_webpack_require_149567__(28);\r\n/** Used to stand-in for `undefined` hash values. */\r\n\r\n\r\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\r\n/**\r\n * Sets the hash `key` to `value`.\r\n *\r\n * @private\r\n * @name set\r\n * @memberOf Hash\r\n * @param {string} key The key of the value to set.\r\n * @param {*} value The value to set.\r\n * @returns {Object} Returns the hash instance.\r\n */\r\n\r\nfunction hashSet(key, value) {\r\n  var data = this.__data__;\r\n  this.size += this.has(key) ? 0 : 1;\r\n  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;\r\n  return this;\r\n}\r\n\r\nmodule.exports = hashSet;\r\n\r\n/***/ }),\r\n/* 116 */\r\n/***/ (function(module, exports, __nested_webpack_require_150268__) {\r\n\r\nvar getMapData = __nested_webpack_require_150268__(29);\r\n/**\r\n * Removes `key` and its value from the map.\r\n *\r\n * @private\r\n * @name delete\r\n * @memberOf MapCache\r\n * @param {string} key The key of the value to remove.\r\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n */\r\n\r\n\r\nfunction mapCacheDelete(key) {\r\n  var result = getMapData(this, key)['delete'](key);\r\n  this.size -= result ? 1 : 0;\r\n  return result;\r\n}\r\n\r\nmodule.exports = mapCacheDelete;\r\n\r\n/***/ }),\r\n/* 117 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * Checks if `value` is suitable for use as unique object key.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\r\n */\r\nfunction isKeyable(value) {\r\n  var type = typeof value;\r\n  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;\r\n}\r\n\r\nmodule.exports = isKeyable;\r\n\r\n/***/ }),\r\n/* 118 */\r\n/***/ (function(module, exports, __nested_webpack_require_151311__) {\r\n\r\nvar getMapData = __nested_webpack_require_151311__(29);\r\n/**\r\n * Gets the map value for `key`.\r\n *\r\n * @private\r\n * @name get\r\n * @memberOf MapCache\r\n * @param {string} key The key of the value to get.\r\n * @returns {*} Returns the entry value.\r\n */\r\n\r\n\r\nfunction mapCacheGet(key) {\r\n  return getMapData(this, key).get(key);\r\n}\r\n\r\nmodule.exports = mapCacheGet;\r\n\r\n/***/ }),\r\n/* 119 */\r\n/***/ (function(module, exports, __nested_webpack_require_151741__) {\r\n\r\nvar getMapData = __nested_webpack_require_151741__(29);\r\n/**\r\n * Checks if a map value for `key` exists.\r\n *\r\n * @private\r\n * @name has\r\n * @memberOf MapCache\r\n * @param {string} key The key of the entry to check.\r\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n */\r\n\r\n\r\nfunction mapCacheHas(key) {\r\n  return getMapData(this, key).has(key);\r\n}\r\n\r\nmodule.exports = mapCacheHas;\r\n\r\n/***/ }),\r\n/* 120 */\r\n/***/ (function(module, exports, __nested_webpack_require_152223__) {\r\n\r\nvar getMapData = __nested_webpack_require_152223__(29);\r\n/**\r\n * Sets the map `key` to `value`.\r\n *\r\n * @private\r\n * @name set\r\n * @memberOf MapCache\r\n * @param {string} key The key of the value to set.\r\n * @param {*} value The value to set.\r\n * @returns {Object} Returns the map cache instance.\r\n */\r\n\r\n\r\nfunction mapCacheSet(key, value) {\r\n  var data = getMapData(this, key),\r\n      size = data.size;\r\n  data.set(key, value);\r\n  this.size += data.size == size ? 0 : 1;\r\n  return this;\r\n}\r\n\r\nmodule.exports = mapCacheSet;\r\n\r\n/***/ }),\r\n/* 121 */\r\n/***/ (function(module, exports, __nested_webpack_require_152816__) {\r\n\r\nvar createBaseFor = __nested_webpack_require_152816__(122);\r\n/**\r\n * The base implementation of `baseForOwn` which iterates over `object`\r\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\r\n * Iteratee functions may exit iteration early by explicitly returning `false`.\r\n *\r\n * @private\r\n * @param {Object} object The object to iterate over.\r\n * @param {Function} iteratee The function invoked per iteration.\r\n * @param {Function} keysFunc The function to get the keys of `object`.\r\n * @returns {Object} Returns `object`.\r\n */\r\n\r\n\r\nvar baseFor = createBaseFor();\r\nmodule.exports = baseFor;\r\n\r\n/***/ }),\r\n/* 122 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\r\n *\r\n * @private\r\n * @param {boolean} [fromRight] Specify iterating from right to left.\r\n * @returns {Function} Returns the new base function.\r\n */\r\nfunction createBaseFor(fromRight) {\r\n  return function (object, iteratee, keysFunc) {\r\n    var index = -1,\r\n        iterable = Object(object),\r\n        props = keysFunc(object),\r\n        length = props.length;\r\n\r\n    while (length--) {\r\n      var key = props[fromRight ? length : ++index];\r\n\r\n      if (iteratee(iterable[key], key, iterable) === false) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return object;\r\n  };\r\n}\r\n\r\nmodule.exports = createBaseFor;\r\n\r\n/***/ }),\r\n/* 123 */\r\n/***/ (function(module, exports, __nested_webpack_require_154245__) {\r\n\r\nvar assignMergeValue = __nested_webpack_require_154245__(48),\r\n    cloneBuffer = __nested_webpack_require_154245__(124),\r\n    cloneTypedArray = __nested_webpack_require_154245__(125),\r\n    copyArray = __nested_webpack_require_154245__(128),\r\n    initCloneObject = __nested_webpack_require_154245__(129),\r\n    isArguments = __nested_webpack_require_154245__(30),\r\n    isArray = __nested_webpack_require_154245__(16),\r\n    isArrayLikeObject = __nested_webpack_require_154245__(133),\r\n    isBuffer = __nested_webpack_require_154245__(52),\r\n    isFunction = __nested_webpack_require_154245__(36),\r\n    isObject = __nested_webpack_require_154245__(15),\r\n    isPlainObject = __nested_webpack_require_154245__(135),\r\n    isTypedArray = __nested_webpack_require_154245__(53),\r\n    safeGet = __nested_webpack_require_154245__(54),\r\n    toPlainObject = __nested_webpack_require_154245__(139);\r\n/**\r\n * A specialized version of `baseMerge` for arrays and objects which performs\r\n * deep merges and tracks traversed objects enabling objects with circular\r\n * references to be merged.\r\n *\r\n * @private\r\n * @param {Object} object The destination object.\r\n * @param {Object} source The source object.\r\n * @param {string} key The key of the value to merge.\r\n * @param {number} srcIndex The index of `source`.\r\n * @param {Function} mergeFunc The function to merge values.\r\n * @param {Function} [customizer] The function to customize assigned values.\r\n * @param {Object} [stack] Tracks traversed source values and their merged\r\n *  counterparts.\r\n */\r\n\r\n\r\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\r\n  var objValue = safeGet(object, key),\r\n      srcValue = safeGet(source, key),\r\n      stacked = stack.get(srcValue);\r\n\r\n  if (stacked) {\r\n    assignMergeValue(object, key, stacked);\r\n    return;\r\n  }\r\n\r\n  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;\r\n  var isCommon = newValue === undefined;\r\n\r\n  if (isCommon) {\r\n    var isArr = isArray(srcValue),\r\n        isBuff = !isArr && isBuffer(srcValue),\r\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\r\n    newValue = srcValue;\r\n\r\n    if (isArr || isBuff || isTyped) {\r\n      if (isArray(objValue)) {\r\n        newValue = objValue;\r\n      } else if (isArrayLikeObject(objValue)) {\r\n        newValue = copyArray(objValue);\r\n      } else if (isBuff) {\r\n        isCommon = false;\r\n        newValue = cloneBuffer(srcValue, true);\r\n      } else if (isTyped) {\r\n        isCommon = false;\r\n        newValue = cloneTypedArray(srcValue, true);\r\n      } else {\r\n        newValue = [];\r\n      }\r\n    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {\r\n      newValue = objValue;\r\n\r\n      if (isArguments(objValue)) {\r\n        newValue = toPlainObject(objValue);\r\n      } else if (!isObject(objValue) || isFunction(objValue)) {\r\n        newValue = initCloneObject(srcValue);\r\n      }\r\n    } else {\r\n      isCommon = false;\r\n    }\r\n  }\r\n\r\n  if (isCommon) {\r\n    // Recursively merge objects and arrays (susceptible to call stack limits).\r\n    stack.set(srcValue, newValue);\r\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\r\n    stack['delete'](srcValue);\r\n  }\r\n\r\n  assignMergeValue(object, key, newValue);\r\n}\r\n\r\nmodule.exports = baseMergeDeep;\r\n\r\n/***/ }),\r\n/* 124 */\r\n/***/ (function(module, exports, __nested_webpack_require_157421__) {\r\n\r\n/* WEBPACK VAR INJECTION */(function(module) {var root = __nested_webpack_require_157421__(18);\r\n/** Detect free variable `exports`. */\r\n\r\n\r\nvar freeExports =   true && exports && !exports.nodeType && exports;\r\n/** Detect free variable `module`. */\r\n\r\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\r\n/** Detect the popular CommonJS extension `module.exports`. */\r\n\r\nvar moduleExports = freeModule && freeModule.exports === freeExports;\r\n/** Built-in value references. */\r\n\r\nvar Buffer = moduleExports ? root.Buffer : undefined,\r\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\r\n/**\r\n * Creates a clone of  `buffer`.\r\n *\r\n * @private\r\n * @param {Buffer} buffer The buffer to clone.\r\n * @param {boolean} [isDeep] Specify a deep clone.\r\n * @returns {Buffer} Returns the cloned buffer.\r\n */\r\n\r\nfunction cloneBuffer(buffer, isDeep) {\r\n  if (isDeep) {\r\n    return buffer.slice();\r\n  }\r\n\r\n  var length = buffer.length,\r\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\r\n  buffer.copy(result);\r\n  return result;\r\n}\r\n\r\nmodule.exports = cloneBuffer;\r\n/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_157421__(38)(module)))\r\n\r\n/***/ }),\r\n/* 125 */\r\n/***/ (function(module, exports, __nested_webpack_require_158702__) {\r\n\r\nvar cloneArrayBuffer = __nested_webpack_require_158702__(126);\r\n/**\r\n * Creates a clone of `typedArray`.\r\n *\r\n * @private\r\n * @param {Object} typedArray The typed array to clone.\r\n * @param {boolean} [isDeep] Specify a deep clone.\r\n * @returns {Object} Returns the cloned typed array.\r\n */\r\n\r\n\r\nfunction cloneTypedArray(typedArray, isDeep) {\r\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\r\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\r\n}\r\n\r\nmodule.exports = cloneTypedArray;\r\n\r\n/***/ }),\r\n/* 126 */\r\n/***/ (function(module, exports, __nested_webpack_require_159324__) {\r\n\r\nvar Uint8Array = __nested_webpack_require_159324__(127);\r\n/**\r\n * Creates a clone of `arrayBuffer`.\r\n *\r\n * @private\r\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\r\n * @returns {ArrayBuffer} Returns the cloned array buffer.\r\n */\r\n\r\n\r\nfunction cloneArrayBuffer(arrayBuffer) {\r\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\r\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\r\n  return result;\r\n}\r\n\r\nmodule.exports = cloneArrayBuffer;\r\n\r\n/***/ }),\r\n/* 127 */\r\n/***/ (function(module, exports, __nested_webpack_require_159874__) {\r\n\r\nvar root = __nested_webpack_require_159874__(18);\r\n/** Built-in value references. */\r\n\r\n\r\nvar Uint8Array = root.Uint8Array;\r\nmodule.exports = Uint8Array;\r\n\r\n/***/ }),\r\n/* 128 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * Copies the values of `source` to `array`.\r\n *\r\n * @private\r\n * @param {Array} source The array to copy values from.\r\n * @param {Array} [array=[]] The array to copy values to.\r\n * @returns {Array} Returns `array`.\r\n */\r\nfunction copyArray(source, array) {\r\n  var index = -1,\r\n      length = source.length;\r\n  array || (array = Array(length));\r\n\r\n  while (++index < length) {\r\n    array[index] = source[index];\r\n  }\r\n\r\n  return array;\r\n}\r\n\r\nmodule.exports = copyArray;\r\n\r\n/***/ }),\r\n/* 129 */\r\n/***/ (function(module, exports, __nested_webpack_require_160636__) {\r\n\r\nvar baseCreate = __nested_webpack_require_160636__(130),\r\n    getPrototype = __nested_webpack_require_160636__(50),\r\n    isPrototype = __nested_webpack_require_160636__(51);\r\n/**\r\n * Initializes an object clone.\r\n *\r\n * @private\r\n * @param {Object} object The object to clone.\r\n * @returns {Object} Returns the initialized clone.\r\n */\r\n\r\n\r\nfunction initCloneObject(object) {\r\n  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};\r\n}\r\n\r\nmodule.exports = initCloneObject;\r\n\r\n/***/ }),\r\n/* 130 */\r\n/***/ (function(module, exports, __nested_webpack_require_161208__) {\r\n\r\nvar isObject = __nested_webpack_require_161208__(15);\r\n/** Built-in value references. */\r\n\r\n\r\nvar objectCreate = Object.create;\r\n/**\r\n * The base implementation of `_.create` without support for assigning\r\n * properties to the created object.\r\n *\r\n * @private\r\n * @param {Object} proto The object to inherit from.\r\n * @returns {Object} Returns the new object.\r\n */\r\n\r\nvar baseCreate = function () {\r\n  function object() {}\r\n\r\n  return function (proto) {\r\n    if (!isObject(proto)) {\r\n      return {};\r\n    }\r\n\r\n    if (objectCreate) {\r\n      return objectCreate(proto);\r\n    }\r\n\r\n    object.prototype = proto;\r\n    var result = new object();\r\n    object.prototype = undefined;\r\n    return result;\r\n  };\r\n}();\r\n\r\nmodule.exports = baseCreate;\r\n\r\n/***/ }),\r\n/* 131 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * Creates a unary function that invokes `func` with its argument transformed.\r\n *\r\n * @private\r\n * @param {Function} func The function to wrap.\r\n * @param {Function} transform The argument transform.\r\n * @returns {Function} Returns the new function.\r\n */\r\nfunction overArg(func, transform) {\r\n  return function (arg) {\r\n    return func(transform(arg));\r\n  };\r\n}\r\n\r\nmodule.exports = overArg;\r\n\r\n/***/ }),\r\n/* 132 */\r\n/***/ (function(module, exports, __nested_webpack_require_162479__) {\r\n\r\nvar baseGetTag = __nested_webpack_require_162479__(22),\r\n    isObjectLike = __nested_webpack_require_162479__(19);\r\n/** `Object#toString` result references. */\r\n\r\n\r\nvar argsTag = '[object Arguments]';\r\n/**\r\n * The base implementation of `_.isArguments`.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\r\n */\r\n\r\nfunction baseIsArguments(value) {\r\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\r\n}\r\n\r\nmodule.exports = baseIsArguments;\r\n\r\n/***/ }),\r\n/* 133 */\r\n/***/ (function(module, exports, __nested_webpack_require_163067__) {\r\n\r\nvar isArrayLike = __nested_webpack_require_163067__(39),\r\n    isObjectLike = __nested_webpack_require_163067__(19);\r\n/**\r\n * This method is like `_.isArrayLike` except that it also checks if `value`\r\n * is an object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an array-like object,\r\n *  else `false`.\r\n * @example\r\n *\r\n * _.isArrayLikeObject([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isArrayLikeObject(document.body.children);\r\n * // => true\r\n *\r\n * _.isArrayLikeObject('abc');\r\n * // => false\r\n *\r\n * _.isArrayLikeObject(_.noop);\r\n * // => false\r\n */\r\n\r\n\r\nfunction isArrayLikeObject(value) {\r\n  return isObjectLike(value) && isArrayLike(value);\r\n}\r\n\r\nmodule.exports = isArrayLikeObject;\r\n\r\n/***/ }),\r\n/* 134 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * This method returns `false`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.13.0\r\n * @category Util\r\n * @returns {boolean} Returns `false`.\r\n * @example\r\n *\r\n * _.times(2, _.stubFalse);\r\n * // => [false, false]\r\n */\r\nfunction stubFalse() {\r\n  return false;\r\n}\r\n\r\nmodule.exports = stubFalse;\r\n\r\n/***/ }),\r\n/* 135 */\r\n/***/ (function(module, exports, __nested_webpack_require_164284__) {\r\n\r\nvar baseGetTag = __nested_webpack_require_164284__(22),\r\n    getPrototype = __nested_webpack_require_164284__(50),\r\n    isObjectLike = __nested_webpack_require_164284__(19);\r\n/** `Object#toString` result references. */\r\n\r\n\r\nvar objectTag = '[object Object]';\r\n/** Used for built-in method references. */\r\n\r\nvar funcProto = Function.prototype,\r\n    objectProto = Object.prototype;\r\n/** Used to resolve the decompiled source of functions. */\r\n\r\nvar funcToString = funcProto.toString;\r\n/** Used to check objects for own properties. */\r\n\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n/** Used to infer the `Object` constructor. */\r\n\r\nvar objectCtorString = funcToString.call(Object);\r\n/**\r\n * Checks if `value` is a plain object, that is, an object created by the\r\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.8.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\r\n * @example\r\n *\r\n * function Foo() {\r\n *   this.a = 1;\r\n * }\r\n *\r\n * _.isPlainObject(new Foo);\r\n * // => false\r\n *\r\n * _.isPlainObject([1, 2, 3]);\r\n * // => false\r\n *\r\n * _.isPlainObject({ 'x': 0, 'y': 0 });\r\n * // => true\r\n *\r\n * _.isPlainObject(Object.create(null));\r\n * // => true\r\n */\r\n\r\nfunction isPlainObject(value) {\r\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\r\n    return false;\r\n  }\r\n\r\n  var proto = getPrototype(value);\r\n\r\n  if (proto === null) {\r\n    return true;\r\n  }\r\n\r\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\r\n  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\r\n}\r\n\r\nmodule.exports = isPlainObject;\r\n\r\n/***/ }),\r\n/* 136 */\r\n/***/ (function(module, exports, __nested_webpack_require_166076__) {\r\n\r\nvar baseGetTag = __nested_webpack_require_166076__(22),\r\n    isLength = __nested_webpack_require_166076__(40),\r\n    isObjectLike = __nested_webpack_require_166076__(19);\r\n/** `Object#toString` result references. */\r\n\r\n\r\nvar argsTag = '[object Arguments]',\r\n    arrayTag = '[object Array]',\r\n    boolTag = '[object Boolean]',\r\n    dateTag = '[object Date]',\r\n    errorTag = '[object Error]',\r\n    funcTag = '[object Function]',\r\n    mapTag = '[object Map]',\r\n    numberTag = '[object Number]',\r\n    objectTag = '[object Object]',\r\n    regexpTag = '[object RegExp]',\r\n    setTag = '[object Set]',\r\n    stringTag = '[object String]',\r\n    weakMapTag = '[object WeakMap]';\r\nvar arrayBufferTag = '[object ArrayBuffer]',\r\n    dataViewTag = '[object DataView]',\r\n    float32Tag = '[object Float32Array]',\r\n    float64Tag = '[object Float64Array]',\r\n    int8Tag = '[object Int8Array]',\r\n    int16Tag = '[object Int16Array]',\r\n    int32Tag = '[object Int32Array]',\r\n    uint8Tag = '[object Uint8Array]',\r\n    uint8ClampedTag = '[object Uint8ClampedArray]',\r\n    uint16Tag = '[object Uint16Array]',\r\n    uint32Tag = '[object Uint32Array]';\r\n/** Used to identify `toStringTag` values of typed arrays. */\r\n\r\nvar typedArrayTags = {};\r\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\r\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\r\n/**\r\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\r\n */\r\n\r\nfunction baseIsTypedArray(value) {\r\n  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\r\n}\r\n\r\nmodule.exports = baseIsTypedArray;\r\n\r\n/***/ }),\r\n/* 137 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * The base implementation of `_.unary` without support for storing metadata.\r\n *\r\n * @private\r\n * @param {Function} func The function to cap arguments for.\r\n * @returns {Function} Returns the new capped function.\r\n */\r\nfunction baseUnary(func) {\r\n  return function (value) {\r\n    return func(value);\r\n  };\r\n}\r\n\r\nmodule.exports = baseUnary;\r\n\r\n/***/ }),\r\n/* 138 */\r\n/***/ (function(module, exports, __nested_webpack_require_168833__) {\r\n\r\n/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __nested_webpack_require_168833__(45);\r\n/** Detect free variable `exports`. */\r\n\r\n\r\nvar freeExports =   true && exports && !exports.nodeType && exports;\r\n/** Detect free variable `module`. */\r\n\r\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\r\n/** Detect the popular CommonJS extension `module.exports`. */\r\n\r\nvar moduleExports = freeModule && freeModule.exports === freeExports;\r\n/** Detect free variable `process` from Node.js. */\r\n\r\nvar freeProcess = moduleExports && freeGlobal.process;\r\n/** Used to access faster Node.js helpers. */\r\n\r\nvar nodeUtil = function () {\r\n  try {\r\n    // Use `util.types` for Node.js 10+.\r\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\r\n\r\n    if (types) {\r\n      return types;\r\n    } // Legacy `process.binding('util')` for Node.js < 10.\r\n\r\n\r\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\r\n  } catch (e) {}\r\n}();\r\n\r\nmodule.exports = nodeUtil;\r\n/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_168833__(38)(module)))\r\n\r\n/***/ }),\r\n/* 139 */\r\n/***/ (function(module, exports, __nested_webpack_require_170038__) {\r\n\r\nvar copyObject = __nested_webpack_require_170038__(140),\r\n    keysIn = __nested_webpack_require_170038__(56);\r\n/**\r\n * Converts `value` to a plain object flattening inherited enumerable string\r\n * keyed properties of `value` to own properties of the plain object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 3.0.0\r\n * @category Lang\r\n * @param {*} value The value to convert.\r\n * @returns {Object} Returns the converted plain object.\r\n * @example\r\n *\r\n * function Foo() {\r\n *   this.b = 2;\r\n * }\r\n *\r\n * Foo.prototype.c = 3;\r\n *\r\n * _.assign({ 'a': 1 }, new Foo);\r\n * // => { 'a': 1, 'b': 2 }\r\n *\r\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\r\n * // => { 'a': 1, 'b': 2, 'c': 3 }\r\n */\r\n\r\n\r\nfunction toPlainObject(value) {\r\n  return copyObject(value, keysIn(value));\r\n}\r\n\r\nmodule.exports = toPlainObject;\r\n\r\n/***/ }),\r\n/* 140 */\r\n/***/ (function(module, exports, __nested_webpack_require_170903__) {\r\n\r\nvar assignValue = __nested_webpack_require_170903__(55),\r\n    baseAssignValue = __nested_webpack_require_170903__(37);\r\n/**\r\n * Copies properties of `source` to `object`.\r\n *\r\n * @private\r\n * @param {Object} source The object to copy properties from.\r\n * @param {Array} props The property identifiers to copy.\r\n * @param {Object} [object={}] The object to copy properties to.\r\n * @param {Function} [customizer] The function to customize copied values.\r\n * @returns {Object} Returns `object`.\r\n */\r\n\r\n\r\nfunction copyObject(source, props, object, customizer) {\r\n  var isNew = !object;\r\n  object || (object = {});\r\n  var index = -1,\r\n      length = props.length;\r\n\r\n  while (++index < length) {\r\n    var key = props[index];\r\n    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;\r\n\r\n    if (newValue === undefined) {\r\n      newValue = source[key];\r\n    }\r\n\r\n    if (isNew) {\r\n      baseAssignValue(object, key, newValue);\r\n    } else {\r\n      assignValue(object, key, newValue);\r\n    }\r\n  }\r\n\r\n  return object;\r\n}\r\n\r\nmodule.exports = copyObject;\r\n\r\n/***/ }),\r\n/* 141 */\r\n/***/ (function(module, exports, __nested_webpack_require_172050__) {\r\n\r\nvar baseTimes = __nested_webpack_require_172050__(142),\r\n    isArguments = __nested_webpack_require_172050__(30),\r\n    isArray = __nested_webpack_require_172050__(16),\r\n    isBuffer = __nested_webpack_require_172050__(52),\r\n    isIndex = __nested_webpack_require_172050__(31),\r\n    isTypedArray = __nested_webpack_require_172050__(53);\r\n/** Used for built-in method references. */\r\n\r\n\r\nvar objectProto = Object.prototype;\r\n/** Used to check objects for own properties. */\r\n\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n/**\r\n * Creates an array of the enumerable property names of the array-like `value`.\r\n *\r\n * @private\r\n * @param {*} value The value to query.\r\n * @param {boolean} inherited Specify returning inherited property names.\r\n * @returns {Array} Returns the array of property names.\r\n */\r\n\r\nfunction arrayLikeKeys(value, inherited) {\r\n  var isArr = isArray(value),\r\n      isArg = !isArr && isArguments(value),\r\n      isBuff = !isArr && !isArg && isBuffer(value),\r\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\r\n      skipIndexes = isArr || isArg || isBuff || isType,\r\n      result = skipIndexes ? baseTimes(value.length, String) : [],\r\n      length = result.length;\r\n\r\n  for (var key in value) {\r\n    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.\r\n    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.\r\n    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.\r\n    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.\r\n    isIndex(key, length)))) {\r\n      result.push(key);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports = arrayLikeKeys;\r\n\r\n/***/ }),\r\n/* 142 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * The base implementation of `_.times` without support for iteratee shorthands\r\n * or max array length checks.\r\n *\r\n * @private\r\n * @param {number} n The number of times to invoke `iteratee`.\r\n * @param {Function} iteratee The function invoked per iteration.\r\n * @returns {Array} Returns the array of results.\r\n */\r\nfunction baseTimes(n, iteratee) {\r\n  var index = -1,\r\n      result = Array(n);\r\n\r\n  while (++index < n) {\r\n    result[index] = iteratee(index);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports = baseTimes;\r\n\r\n/***/ }),\r\n/* 143 */\r\n/***/ (function(module, exports, __nested_webpack_require_174458__) {\r\n\r\nvar isObject = __nested_webpack_require_174458__(15),\r\n    isPrototype = __nested_webpack_require_174458__(51),\r\n    nativeKeysIn = __nested_webpack_require_174458__(144);\r\n/** Used for built-in method references. */\r\n\r\n\r\nvar objectProto = Object.prototype;\r\n/** Used to check objects for own properties. */\r\n\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n/**\r\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @returns {Array} Returns the array of property names.\r\n */\r\n\r\nfunction baseKeysIn(object) {\r\n  if (!isObject(object)) {\r\n    return nativeKeysIn(object);\r\n  }\r\n\r\n  var isProto = isPrototype(object),\r\n      result = [];\r\n\r\n  for (var key in object) {\r\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\r\n      result.push(key);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports = baseKeysIn;\r\n\r\n/***/ }),\r\n/* 144 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * This function is like\r\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\r\n * except that it includes inherited enumerable properties.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @returns {Array} Returns the array of property names.\r\n */\r\nfunction nativeKeysIn(object) {\r\n  var result = [];\r\n\r\n  if (object != null) {\r\n    for (var key in Object(object)) {\r\n      result.push(key);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports = nativeKeysIn;\r\n\r\n/***/ }),\r\n/* 145 */\r\n/***/ (function(module, exports, __nested_webpack_require_176024__) {\r\n\r\nvar baseRest = __nested_webpack_require_176024__(146),\r\n    isIterateeCall = __nested_webpack_require_176024__(151);\r\n/**\r\n * Creates a function like `_.assign`.\r\n *\r\n * @private\r\n * @param {Function} assigner The function to assign values.\r\n * @returns {Function} Returns the new assigner function.\r\n */\r\n\r\n\r\nfunction createAssigner(assigner) {\r\n  return baseRest(function (object, sources) {\r\n    var index = -1,\r\n        length = sources.length,\r\n        customizer = length > 1 ? sources[length - 1] : undefined,\r\n        guard = length > 2 ? sources[2] : undefined;\r\n    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;\r\n\r\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\r\n      customizer = length < 3 ? undefined : customizer;\r\n      length = 1;\r\n    }\r\n\r\n    object = Object(object);\r\n\r\n    while (++index < length) {\r\n      var source = sources[index];\r\n\r\n      if (source) {\r\n        assigner(object, source, index, customizer);\r\n      }\r\n    }\r\n\r\n    return object;\r\n  });\r\n}\r\n\r\nmodule.exports = createAssigner;\r\n\r\n/***/ }),\r\n/* 146 */\r\n/***/ (function(module, exports, __nested_webpack_require_177177__) {\r\n\r\nvar identity = __nested_webpack_require_177177__(57),\r\n    overRest = __nested_webpack_require_177177__(58),\r\n    setToString = __nested_webpack_require_177177__(59);\r\n/**\r\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\r\n *\r\n * @private\r\n * @param {Function} func The function to apply a rest parameter to.\r\n * @param {number} [start=func.length-1] The start position of the rest parameter.\r\n * @returns {Function} Returns the new function.\r\n */\r\n\r\n\r\nfunction baseRest(func, start) {\r\n  return setToString(overRest(func, start, identity), func + '');\r\n}\r\n\r\nmodule.exports = baseRest;\r\n\r\n/***/ }),\r\n/* 147 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * A faster alternative to `Function#apply`, this function invokes `func`\r\n * with the `this` binding of `thisArg` and the arguments of `args`.\r\n *\r\n * @private\r\n * @param {Function} func The function to invoke.\r\n * @param {*} thisArg The `this` binding of `func`.\r\n * @param {Array} args The arguments to invoke `func` with.\r\n * @returns {*} Returns the result of `func`.\r\n */\r\nfunction apply(func, thisArg, args) {\r\n  switch (args.length) {\r\n    case 0:\r\n      return func.call(thisArg);\r\n\r\n    case 1:\r\n      return func.call(thisArg, args[0]);\r\n\r\n    case 2:\r\n      return func.call(thisArg, args[0], args[1]);\r\n\r\n    case 3:\r\n      return func.call(thisArg, args[0], args[1], args[2]);\r\n  }\r\n\r\n  return func.apply(thisArg, args);\r\n}\r\n\r\nmodule.exports = apply;\r\n\r\n/***/ }),\r\n/* 148 */\r\n/***/ (function(module, exports, __nested_webpack_require_178672__) {\r\n\r\nvar constant = __nested_webpack_require_178672__(149),\r\n    defineProperty = __nested_webpack_require_178672__(49),\r\n    identity = __nested_webpack_require_178672__(57);\r\n/**\r\n * The base implementation of `setToString` without support for hot loop shorting.\r\n *\r\n * @private\r\n * @param {Function} func The function to modify.\r\n * @param {Function} string The `toString` result.\r\n * @returns {Function} Returns `func`.\r\n */\r\n\r\n\r\nvar baseSetToString = !defineProperty ? identity : function (func, string) {\r\n  return defineProperty(func, 'toString', {\r\n    'configurable': true,\r\n    'enumerable': false,\r\n    'value': constant(string),\r\n    'writable': true\r\n  });\r\n};\r\nmodule.exports = baseSetToString;\r\n\r\n/***/ }),\r\n/* 149 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * Creates a function that returns `value`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 2.4.0\r\n * @category Util\r\n * @param {*} value The value to return from the new function.\r\n * @returns {Function} Returns the new constant function.\r\n * @example\r\n *\r\n * var objects = _.times(2, _.constant({ 'a': 1 }));\r\n *\r\n * console.log(objects);\r\n * // => [{ 'a': 1 }, { 'a': 1 }]\r\n *\r\n * console.log(objects[0] === objects[1]);\r\n * // => true\r\n */\r\nfunction constant(value) {\r\n  return function () {\r\n    return value;\r\n  };\r\n}\r\n\r\nmodule.exports = constant;\r\n\r\n/***/ }),\r\n/* 150 */\r\n/***/ (function(module, exports) {\r\n\r\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\r\nvar HOT_COUNT = 800,\r\n    HOT_SPAN = 16;\r\n/* Built-in method references for those with the same name as other `lodash` methods. */\r\n\r\nvar nativeNow = Date.now;\r\n/**\r\n * Creates a function that'll short out and invoke `identity` instead\r\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\r\n * milliseconds.\r\n *\r\n * @private\r\n * @param {Function} func The function to restrict.\r\n * @returns {Function} Returns the new shortable function.\r\n */\r\n\r\nfunction shortOut(func) {\r\n  var count = 0,\r\n      lastCalled = 0;\r\n  return function () {\r\n    var stamp = nativeNow(),\r\n        remaining = HOT_SPAN - (stamp - lastCalled);\r\n    lastCalled = stamp;\r\n\r\n    if (remaining > 0) {\r\n      if (++count >= HOT_COUNT) {\r\n        return arguments[0];\r\n      }\r\n    } else {\r\n      count = 0;\r\n    }\r\n\r\n    return func.apply(undefined, arguments);\r\n  };\r\n}\r\n\r\nmodule.exports = shortOut;\r\n\r\n/***/ }),\r\n/* 151 */\r\n/***/ (function(module, exports, __nested_webpack_require_181077__) {\r\n\r\nvar eq = __nested_webpack_require_181077__(26),\r\n    isArrayLike = __nested_webpack_require_181077__(39),\r\n    isIndex = __nested_webpack_require_181077__(31),\r\n    isObject = __nested_webpack_require_181077__(15);\r\n/**\r\n * Checks if the given arguments are from an iteratee call.\r\n *\r\n * @private\r\n * @param {*} value The potential iteratee value argument.\r\n * @param {*} index The potential iteratee index or key argument.\r\n * @param {*} object The potential iteratee object argument.\r\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\r\n *  else `false`.\r\n */\r\n\r\n\r\nfunction isIterateeCall(value, index, object) {\r\n  if (!isObject(object)) {\r\n    return false;\r\n  }\r\n\r\n  var type = typeof index;\r\n\r\n  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {\r\n    return eq(object[index], value);\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nmodule.exports = isIterateeCall;\r\n\r\n/***/ }),\r\n/* 152 */\r\n/***/ (function(module, exports) {\r\n\r\n/*\r\n * typedefs.js\r\n * Normalizes browser-specific prefixes and provide some basic polyfills\r\n */\r\nif (typeof window !== 'undefined') {\r\n  if (!window.requestAnimationFrame) {\r\n    window.requestAnimationFrame = function () {\r\n      return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (\r\n      /* function FrameRequestCallback */\r\n      callback) {\r\n        window.setTimeout(callback, 1000 / 60);\r\n      };\r\n    }();\r\n  }\r\n}\r\n\r\nif (typeof Math.imul !== 'function') {\r\n  /* eslint-disable no-bitwise */\r\n  Math.imul = function (a, b) {\r\n    var ah = a >>> 16 & 0xffff;\r\n    var al = a & 0xffff;\r\n    var bh = b >>> 16 & 0xffff;\r\n    var bl = b & 0xffff; // the shift by 0 fixes the sign on the high part\r\n    // the final |0 converts the unsigned value into a signed value\r\n\r\n    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;\r\n  };\r\n  /* eslint-enable no-bitwise */\r\n\r\n}\r\n\r\nif (typeof Object.assign !== 'function') {\r\n  Object.assign = function (target) {\r\n    // .length of function is 2\r\n    'use strict';\r\n\r\n    if (target === null) {\r\n      // TypeError if undefined or null\r\n      throw new TypeError('Cannot convert undefined or null to object');\r\n    }\r\n\r\n    var to = Object(target);\r\n\r\n    for (var index = 1; index < arguments.length; index++) {\r\n      // eslint-disable-next-line prefer-rest-params\r\n      var nextSource = arguments[index];\r\n\r\n      if (nextSource !== null) {\r\n        // Skip over if undefined or null\r\n        // eslint-disable-next-line no-restricted-syntax\r\n        for (var nextKey in nextSource) {\r\n          // Avoid bugs when hasOwnProperty is shadowed\r\n          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\r\n            to[nextKey] = nextSource[nextKey];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return to;\r\n  };\r\n}\r\n\r\n/***/ }),\r\n/* 153 */\r\n/***/ (function(module, exports) {\r\n\r\nfunction _arrayWithHoles(arr) {\r\n  if (Array.isArray(arr)) return arr;\r\n}\r\n\r\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 154 */\r\n/***/ (function(module, exports) {\r\n\r\nfunction _iterableToArrayLimit(arr, i) {\r\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\r\n\r\n  if (_i == null) return;\r\n  var _arr = [];\r\n  var _n = true;\r\n  var _d = false;\r\n\r\n  var _s, _e;\r\n\r\n  try {\r\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\r\n      _arr.push(_s.value);\r\n\r\n      if (i && _arr.length === i) break;\r\n    }\r\n  } catch (err) {\r\n    _d = true;\r\n    _e = err;\r\n  } finally {\r\n    try {\r\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\r\n    } finally {\r\n      if (_d) throw _e;\r\n    }\r\n  }\r\n\r\n  return _arr;\r\n}\r\n\r\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 155 */\r\n/***/ (function(module, exports) {\r\n\r\nfunction _nonIterableRest() {\r\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\r\n}\r\n\r\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 156 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = clone;\r\n/**\r\n * Creates a new vec2 initialized with values from an existing vector\r\n *\r\n * @param {vec2} a vector to clone\r\n * @returns {vec2} a new 2D vector\r\n */\r\n\r\nfunction clone(a) {\r\n  var out = new Float32Array(2);\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 157 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = fromValues;\r\n/**\r\n * Creates a new vec2 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} a new 2D vector\r\n */\r\n\r\nfunction fromValues(x, y) {\r\n  var out = new Float32Array(2);\r\n  out[0] = x;\r\n  out[1] = y;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 158 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = copy;\r\n/**\r\n * Copy the values from one vec2 to another\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the source vector\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 159 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = set;\r\n/**\r\n * Set the components of a vec2 to the given values\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction set(out, x, y) {\r\n  out[0] = x;\r\n  out[1] = y;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 160 */\r\n/***/ (function(module, exports, __nested_webpack_require_186875__) {\r\n\r\nmodule.exports = equals;\r\n\r\nvar EPSILON = __nested_webpack_require_186875__(62);\r\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {vec2} a The first vector.\r\n * @param {vec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\n\r\n\r\nfunction equals(a, b) {\r\n  var a0 = a[0];\r\n  var a1 = a[1];\r\n  var b0 = b[0];\r\n  var b1 = b[1];\r\n  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\r\n}\r\n\r\n/***/ }),\r\n/* 161 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = exactEquals;\r\n/**\r\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\r\n *\r\n * @param {vec2} a The first vector.\r\n * @param {vec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\n\r\nfunction exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1];\r\n}\r\n\r\n/***/ }),\r\n/* 162 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = add;\r\n/**\r\n * Adds two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 163 */\r\n/***/ (function(module, exports, __nested_webpack_require_188358__) {\r\n\r\nmodule.exports = __nested_webpack_require_188358__(64);\r\n\r\n/***/ }),\r\n/* 164 */\r\n/***/ (function(module, exports, __nested_webpack_require_188484__) {\r\n\r\nmodule.exports = __nested_webpack_require_188484__(65);\r\n\r\n/***/ }),\r\n/* 165 */\r\n/***/ (function(module, exports, __nested_webpack_require_188610__) {\r\n\r\nmodule.exports = __nested_webpack_require_188610__(66);\r\n\r\n/***/ }),\r\n/* 166 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = inverse;\r\n/**\r\n * Returns the inverse of the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to invert\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction inverse(out, a) {\r\n  out[0] = 1.0 / a[0];\r\n  out[1] = 1.0 / a[1];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 167 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = min;\r\n/**\r\n * Returns the minimum of two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction min(out, a, b) {\r\n  out[0] = Math.min(a[0], b[0]);\r\n  out[1] = Math.min(a[1], b[1]);\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 168 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = max;\r\n/**\r\n * Returns the maximum of two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction max(out, a, b) {\r\n  out[0] = Math.max(a[0], b[0]);\r\n  out[1] = Math.max(a[1], b[1]);\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 169 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = rotate;\r\n/**\r\n * Rotates a vec2 by an angle\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to rotate\r\n * @param {Number} angle the angle of rotation (in radians)\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction rotate(out, a, angle) {\r\n  var c = Math.cos(angle),\r\n      s = Math.sin(angle);\r\n  var x = a[0],\r\n      y = a[1];\r\n  out[0] = x * c - y * s;\r\n  out[1] = x * s + y * c;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 170 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = floor;\r\n/**\r\n * Math.floor the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to floor\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction floor(out, a) {\r\n  out[0] = Math.floor(a[0]);\r\n  out[1] = Math.floor(a[1]);\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 171 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = ceil;\r\n/**\r\n * Math.ceil the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to ceil\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction ceil(out, a) {\r\n  out[0] = Math.ceil(a[0]);\r\n  out[1] = Math.ceil(a[1]);\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 172 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = round;\r\n/**\r\n * Math.round the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to round\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction round(out, a) {\r\n  out[0] = Math.round(a[0]);\r\n  out[1] = Math.round(a[1]);\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 173 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = scale;\r\n/**\r\n * Scales a vec2 by a scalar number\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction scale(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 174 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = scaleAndAdd;\r\n/**\r\n * Adds two vec2's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction scaleAndAdd(out, a, b, scale) {\r\n  out[0] = a[0] + b[0] * scale;\r\n  out[1] = a[1] + b[1] * scale;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 175 */\r\n/***/ (function(module, exports, __nested_webpack_require_192332__) {\r\n\r\nmodule.exports = __nested_webpack_require_192332__(67);\r\n\r\n/***/ }),\r\n/* 176 */\r\n/***/ (function(module, exports, __nested_webpack_require_192458__) {\r\n\r\nmodule.exports = __nested_webpack_require_192458__(68);\r\n\r\n/***/ }),\r\n/* 177 */\r\n/***/ (function(module, exports, __nested_webpack_require_192584__) {\r\n\r\nmodule.exports = __nested_webpack_require_192584__(69);\r\n\r\n/***/ }),\r\n/* 178 */\r\n/***/ (function(module, exports, __nested_webpack_require_192710__) {\r\n\r\nmodule.exports = __nested_webpack_require_192710__(70);\r\n\r\n/***/ }),\r\n/* 179 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = negate;\r\n/**\r\n * Negates the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to negate\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction negate(out, a) {\r\n  out[0] = -a[0];\r\n  out[1] = -a[1];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 180 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = normalize;\r\n/**\r\n * Normalize a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to normalize\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction normalize(out, a) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  var len = x * x + y * y;\r\n\r\n  if (len > 0) {\r\n    //TODO: evaluate use of glm_invsqrt here?\r\n    len = 1 / Math.sqrt(len);\r\n    out[0] = a[0] * len;\r\n    out[1] = a[1] * len;\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 181 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = dot;\r\n/**\r\n * Calculates the dot product of two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\r\n\r\nfunction dot(a, b) {\r\n  return a[0] * b[0] + a[1] * b[1];\r\n}\r\n\r\n/***/ }),\r\n/* 182 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = cross;\r\n/**\r\n * Computes the cross product of two vec2's\r\n * Note that the cross product must by definition produce a 3D vector\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction cross(out, a, b) {\r\n  var z = a[0] * b[1] - a[1] * b[0];\r\n  out[0] = out[1] = 0;\r\n  out[2] = z;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 183 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = lerp;\r\n/**\r\n * Performs a linear interpolation between two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @param {Number} t interpolation amount between the two inputs\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction lerp(out, a, b, t) {\r\n  var ax = a[0],\r\n      ay = a[1];\r\n  out[0] = ax + t * (b[0] - ax);\r\n  out[1] = ay + t * (b[1] - ay);\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 184 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = random;\r\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction random(out, scale) {\r\n  scale = scale || 1.0;\r\n  var r = Math.random() * 2.0 * Math.PI;\r\n  out[0] = Math.cos(r) * scale;\r\n  out[1] = Math.sin(r) * scale;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 185 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = transformMat2;\r\n/**\r\n * Transforms the vec2 with a mat2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat2} m matrix to transform with\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction transformMat2(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  out[0] = m[0] * x + m[2] * y;\r\n  out[1] = m[1] * x + m[3] * y;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 186 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = transformMat2d;\r\n/**\r\n * Transforms the vec2 with a mat2d\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat2d} m matrix to transform with\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction transformMat2d(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  out[0] = m[0] * x + m[2] * y + m[4];\r\n  out[1] = m[1] * x + m[3] * y + m[5];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 187 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = transformMat3;\r\n/**\r\n * Transforms the vec2 with a mat3\r\n * 3rd vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat3} m matrix to transform with\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction transformMat3(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  out[0] = m[0] * x + m[3] * y + m[6];\r\n  out[1] = m[1] * x + m[4] * y + m[7];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 188 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = transformMat4;\r\n/**\r\n * Transforms the vec2 with a mat4\r\n * 3rd vector component is implicitly '0'\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat4} m matrix to transform with\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction transformMat4(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  out[0] = m[0] * x + m[4] * y + m[12];\r\n  out[1] = m[1] * x + m[5] * y + m[13];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 189 */\r\n/***/ (function(module, exports, __nested_webpack_require_197520__) {\r\n\r\nmodule.exports = forEach;\r\n\r\nvar vec = __nested_webpack_require_197520__(63)();\r\n/**\r\n * Perform some operation over an array of vec2s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\r\n\r\n\r\nfunction forEach(a, stride, offset, count, fn, arg) {\r\n  var i, l;\r\n\r\n  if (!stride) {\r\n    stride = 2;\r\n  }\r\n\r\n  if (!offset) {\r\n    offset = 0;\r\n  }\r\n\r\n  if (count) {\r\n    l = Math.min(count * stride + offset, a.length);\r\n  } else {\r\n    l = a.length;\r\n  }\r\n\r\n  for (i = offset; i < l; i += stride) {\r\n    vec[0] = a[i];\r\n    vec[1] = a[i + 1];\r\n    fn(vec, vec, arg);\r\n    a[i] = vec[0];\r\n    a[i + 1] = vec[1];\r\n  }\r\n\r\n  return a;\r\n}\r\n\r\n/***/ }),\r\n/* 190 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = limit;\r\n/**\r\n * Limit the magnitude of this vector to the value used for the `max`\r\n * parameter.\r\n *\r\n * @param  {vec2} the vector to limit\r\n * @param  {Number} max the maximum magnitude for the vector\r\n * @returns {vec2} out\r\n */\r\n\r\nfunction limit(out, a, max) {\r\n  var mSq = a[0] * a[0] + a[1] * a[1];\r\n\r\n  if (mSq > max * max) {\r\n    var n = Math.sqrt(mSq);\r\n    out[0] = a[0] / n * max;\r\n    out[1] = a[1] / n * max;\r\n  } else {\r\n    out[0] = a[0];\r\n    out[1] = a[1];\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 191 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = clone;\r\n/**\r\n * Creates a new vec3 initialized with values from an existing vector\r\n *\r\n * @param {vec3} a vector to clone\r\n * @returns {vec3} a new 3D vector\r\n */\r\n\r\nfunction clone(a) {\r\n  var out = new Float32Array(3);\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 192 */\r\n/***/ (function(module, exports, __nested_webpack_require_199637__) {\r\n\r\nmodule.exports = angle;\r\n\r\nvar fromValues = __nested_webpack_require_199637__(73);\r\n\r\nvar normalize = __nested_webpack_require_199637__(74);\r\n\r\nvar dot = __nested_webpack_require_199637__(75);\r\n/**\r\n * Get the angle between two 3D vectors\r\n * @param {vec3} a The first operand\r\n * @param {vec3} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\r\n\r\n\r\nfunction angle(a, b) {\r\n  var tempA = fromValues(a[0], a[1], a[2]);\r\n  var tempB = fromValues(b[0], b[1], b[2]);\r\n  normalize(tempA, tempA);\r\n  normalize(tempB, tempB);\r\n  var cosine = dot(tempA, tempB);\r\n\r\n  if (cosine > 1.0) {\r\n    return 0;\r\n  } else {\r\n    return Math.acos(cosine);\r\n  }\r\n}\r\n\r\n/***/ }),\r\n/* 193 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = copy;\r\n/**\r\n * Copy the values from one vec3 to another\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the source vector\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 194 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = set;\r\n/**\r\n * Set the components of a vec3 to the given values\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction set(out, x, y, z) {\r\n  out[0] = x;\r\n  out[1] = y;\r\n  out[2] = z;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 195 */\r\n/***/ (function(module, exports, __nested_webpack_require_201108__) {\r\n\r\nmodule.exports = equals;\r\n\r\nvar EPSILON = __nested_webpack_require_201108__(71);\r\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {vec3} a The first vector.\r\n * @param {vec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\n\r\n\r\nfunction equals(a, b) {\r\n  var a0 = a[0];\r\n  var a1 = a[1];\r\n  var a2 = a[2];\r\n  var b0 = b[0];\r\n  var b1 = b[1];\r\n  var b2 = b[2];\r\n  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\r\n}\r\n\r\n/***/ }),\r\n/* 196 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = exactEquals;\r\n/**\r\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\r\n *\r\n * @param {vec3} a The first vector.\r\n * @param {vec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\n\r\nfunction exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\r\n}\r\n\r\n/***/ }),\r\n/* 197 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = add;\r\n/**\r\n * Adds two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  out[2] = a[2] + b[2];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 198 */\r\n/***/ (function(module, exports, __nested_webpack_require_202745__) {\r\n\r\nmodule.exports = __nested_webpack_require_202745__(76);\r\n\r\n/***/ }),\r\n/* 199 */\r\n/***/ (function(module, exports, __nested_webpack_require_202871__) {\r\n\r\nmodule.exports = __nested_webpack_require_202871__(77);\r\n\r\n/***/ }),\r\n/* 200 */\r\n/***/ (function(module, exports, __nested_webpack_require_202997__) {\r\n\r\nmodule.exports = __nested_webpack_require_202997__(78);\r\n\r\n/***/ }),\r\n/* 201 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = min;\r\n/**\r\n * Returns the minimum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction min(out, a, b) {\r\n  out[0] = Math.min(a[0], b[0]);\r\n  out[1] = Math.min(a[1], b[1]);\r\n  out[2] = Math.min(a[2], b[2]);\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 202 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = max;\r\n/**\r\n * Returns the maximum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction max(out, a, b) {\r\n  out[0] = Math.max(a[0], b[0]);\r\n  out[1] = Math.max(a[1], b[1]);\r\n  out[2] = Math.max(a[2], b[2]);\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 203 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = floor;\r\n/**\r\n * Math.floor the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to floor\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction floor(out, a) {\r\n  out[0] = Math.floor(a[0]);\r\n  out[1] = Math.floor(a[1]);\r\n  out[2] = Math.floor(a[2]);\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 204 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = ceil;\r\n/**\r\n * Math.ceil the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to ceil\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction ceil(out, a) {\r\n  out[0] = Math.ceil(a[0]);\r\n  out[1] = Math.ceil(a[1]);\r\n  out[2] = Math.ceil(a[2]);\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 205 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = round;\r\n/**\r\n * Math.round the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to round\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction round(out, a) {\r\n  out[0] = Math.round(a[0]);\r\n  out[1] = Math.round(a[1]);\r\n  out[2] = Math.round(a[2]);\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 206 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = scale;\r\n/**\r\n * Scales a vec3 by a scalar number\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction scale(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  out[2] = a[2] * b;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 207 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = scaleAndAdd;\r\n/**\r\n * Adds two vec3's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction scaleAndAdd(out, a, b, scale) {\r\n  out[0] = a[0] + b[0] * scale;\r\n  out[1] = a[1] + b[1] * scale;\r\n  out[2] = a[2] + b[2] * scale;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 208 */\r\n/***/ (function(module, exports, __nested_webpack_require_206076__) {\r\n\r\nmodule.exports = __nested_webpack_require_206076__(79);\r\n\r\n/***/ }),\r\n/* 209 */\r\n/***/ (function(module, exports, __nested_webpack_require_206202__) {\r\n\r\nmodule.exports = __nested_webpack_require_206202__(80);\r\n\r\n/***/ }),\r\n/* 210 */\r\n/***/ (function(module, exports, __nested_webpack_require_206328__) {\r\n\r\nmodule.exports = __nested_webpack_require_206328__(81);\r\n\r\n/***/ }),\r\n/* 211 */\r\n/***/ (function(module, exports, __nested_webpack_require_206454__) {\r\n\r\nmodule.exports = __nested_webpack_require_206454__(82);\r\n\r\n/***/ }),\r\n/* 212 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = negate;\r\n/**\r\n * Negates the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to negate\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction negate(out, a) {\r\n  out[0] = -a[0];\r\n  out[1] = -a[1];\r\n  out[2] = -a[2];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 213 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = inverse;\r\n/**\r\n * Returns the inverse of the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to invert\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction inverse(out, a) {\r\n  out[0] = 1.0 / a[0];\r\n  out[1] = 1.0 / a[1];\r\n  out[2] = 1.0 / a[2];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 214 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = cross;\r\n/**\r\n * Computes the cross product of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction cross(out, a, b) {\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      bx = b[0],\r\n      by = b[1],\r\n      bz = b[2];\r\n  out[0] = ay * bz - az * by;\r\n  out[1] = az * bx - ax * bz;\r\n  out[2] = ax * by - ay * bx;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 215 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = lerp;\r\n/**\r\n * Performs a linear interpolation between two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {Number} t interpolation amount between the two inputs\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction lerp(out, a, b, t) {\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2];\r\n  out[0] = ax + t * (b[0] - ax);\r\n  out[1] = ay + t * (b[1] - ay);\r\n  out[2] = az + t * (b[2] - az);\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 216 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = random;\r\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction random(out, scale) {\r\n  scale = scale || 1.0;\r\n  var r = Math.random() * 2.0 * Math.PI;\r\n  var z = Math.random() * 2.0 - 1.0;\r\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\r\n  out[0] = Math.cos(r) * zScale;\r\n  out[1] = Math.sin(r) * zScale;\r\n  out[2] = z * scale;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 217 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = transformMat4;\r\n/**\r\n * Transforms the vec3 with a mat4.\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to transform\r\n * @param {mat4} m matrix to transform with\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction transformMat4(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2],\r\n      w = m[3] * x + m[7] * y + m[11] * z + m[15];\r\n  w = w || 1.0;\r\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\r\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\r\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 218 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = transformMat3;\r\n/**\r\n * Transforms the vec3 with a mat3.\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to transform\r\n * @param {mat4} m the 3x3 matrix to transform with\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction transformMat3(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2];\r\n  out[0] = x * m[0] + y * m[3] + z * m[6];\r\n  out[1] = x * m[1] + y * m[4] + z * m[7];\r\n  out[2] = x * m[2] + y * m[5] + z * m[8];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 219 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = transformQuat;\r\n/**\r\n * Transforms the vec3 with a quat\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to transform\r\n * @param {quat} q quaternion to transform with\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction transformQuat(out, a, q) {\r\n  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2],\r\n      qx = q[0],\r\n      qy = q[1],\r\n      qz = q[2],\r\n      qw = q[3],\r\n      // calculate quat * vec\r\n  ix = qw * x + qy * z - qz * y,\r\n      iy = qw * y + qz * x - qx * z,\r\n      iz = qw * z + qx * y - qy * x,\r\n      iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\r\n\r\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 220 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = rotateX;\r\n/**\r\n * Rotate a 3D vector around the x-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {vec3} a The vec3 point to rotate\r\n * @param {vec3} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction rotateX(out, a, b, c) {\r\n  var by = b[1];\r\n  var bz = b[2]; // Translate point to the origin\r\n\r\n  var py = a[1] - by;\r\n  var pz = a[2] - bz;\r\n  var sc = Math.sin(c);\r\n  var cc = Math.cos(c); // perform rotation and translate to correct position\r\n\r\n  out[0] = a[0];\r\n  out[1] = by + py * cc - pz * sc;\r\n  out[2] = bz + py * sc + pz * cc;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 221 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = rotateY;\r\n/**\r\n * Rotate a 3D vector around the y-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {vec3} a The vec3 point to rotate\r\n * @param {vec3} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction rotateY(out, a, b, c) {\r\n  var bx = b[0];\r\n  var bz = b[2]; // translate point to the origin\r\n\r\n  var px = a[0] - bx;\r\n  var pz = a[2] - bz;\r\n  var sc = Math.sin(c);\r\n  var cc = Math.cos(c); // perform rotation and translate to correct position\r\n\r\n  out[0] = bx + pz * sc + px * cc;\r\n  out[1] = a[1];\r\n  out[2] = bz + pz * cc - px * sc;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 222 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = rotateZ;\r\n/**\r\n * Rotate a 3D vector around the z-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {vec3} a The vec3 point to rotate\r\n * @param {vec3} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec3} out\r\n */\r\n\r\nfunction rotateZ(out, a, b, c) {\r\n  var bx = b[0];\r\n  var by = b[1]; //Translate point to the origin\r\n\r\n  var px = a[0] - bx;\r\n  var py = a[1] - by;\r\n  var sc = Math.sin(c);\r\n  var cc = Math.cos(c); // perform rotation and translate to correct position\r\n\r\n  out[0] = bx + px * cc - py * sc;\r\n  out[1] = by + px * sc + py * cc;\r\n  out[2] = a[2];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 223 */\r\n/***/ (function(module, exports, __nested_webpack_require_213349__) {\r\n\r\nmodule.exports = forEach;\r\n\r\nvar vec = __nested_webpack_require_213349__(72)();\r\n/**\r\n * Perform some operation over an array of vec3s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\r\n\r\n\r\nfunction forEach(a, stride, offset, count, fn, arg) {\r\n  var i, l;\r\n\r\n  if (!stride) {\r\n    stride = 3;\r\n  }\r\n\r\n  if (!offset) {\r\n    offset = 0;\r\n  }\r\n\r\n  if (count) {\r\n    l = Math.min(count * stride + offset, a.length);\r\n  } else {\r\n    l = a.length;\r\n  }\r\n\r\n  for (i = offset; i < l; i += stride) {\r\n    vec[0] = a[i];\r\n    vec[1] = a[i + 1];\r\n    vec[2] = a[i + 2];\r\n    fn(vec, vec, arg);\r\n    a[i] = vec[0];\r\n    a[i + 1] = vec[1];\r\n    a[i + 2] = vec[2];\r\n  }\r\n\r\n  return a;\r\n}\r\n\r\n/***/ }),\r\n/* 224 */\r\n/***/ (function(module, exports, __webpack_require__) {\r\n\r\n/**\r\n * Copyright (c) 2014-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\nvar runtime = function (exports) {\r\n  \"use strict\";\r\n\r\n  var Op = Object.prototype;\r\n  var hasOwn = Op.hasOwnProperty;\r\n  var undefined; // More compressible than void 0.\r\n\r\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\r\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\r\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\r\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\r\n\r\n  function wrap(innerFn, outerFn, self, tryLocsList) {\r\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\r\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\r\n    var generator = Object.create(protoGenerator.prototype);\r\n    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,\r\n    // .throw, and .return methods.\r\n\r\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\r\n    return generator;\r\n  }\r\n\r\n  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion\r\n  // record like context.tryEntries[i].completion. This interface could\r\n  // have been (and was previously) designed to take a closure to be\r\n  // invoked without arguments, but in all the cases we care about we\r\n  // already have an existing method we want to call, so there's no need\r\n  // to create a new function object. We can even get away with assuming\r\n  // the method takes exactly one argument, since that happens to be true\r\n  // in every case, so we don't have to touch the arguments object. The\r\n  // only additional allocation required is the completion record, which\r\n  // has a stable shape and so hopefully should be cheap to allocate.\r\n\r\n  function tryCatch(fn, obj, arg) {\r\n    try {\r\n      return {\r\n        type: \"normal\",\r\n        arg: fn.call(obj, arg)\r\n      };\r\n    } catch (err) {\r\n      return {\r\n        type: \"throw\",\r\n        arg: err\r\n      };\r\n    }\r\n  }\r\n\r\n  var GenStateSuspendedStart = \"suspendedStart\";\r\n  var GenStateSuspendedYield = \"suspendedYield\";\r\n  var GenStateExecuting = \"executing\";\r\n  var GenStateCompleted = \"completed\"; // Returning this object from the innerFn has the same effect as\r\n  // breaking out of the dispatch switch statement.\r\n\r\n  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and\r\n  // .constructor.prototype properties for functions that return Generator\r\n  // objects. For full spec compliance, you may wish to configure your\r\n  // minifier not to mangle the names of these two functions.\r\n\r\n  function Generator() {}\r\n\r\n  function GeneratorFunction() {}\r\n\r\n  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that\r\n  // don't natively support it.\r\n\r\n\r\n  var IteratorPrototype = {};\r\n\r\n  IteratorPrototype[iteratorSymbol] = function () {\r\n    return this;\r\n  };\r\n\r\n  var getProto = Object.getPrototypeOf;\r\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\r\n\r\n  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\r\n    // This environment has a native %IteratorPrototype%; use it instead\r\n    // of the polyfill.\r\n    IteratorPrototype = NativeIteratorPrototype;\r\n  }\r\n\r\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\r\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\r\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\r\n  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\"; // Helper for defining the .next, .throw, and .return methods of the\r\n  // Iterator interface in terms of a single ._invoke method.\r\n\r\n  function defineIteratorMethods(prototype) {\r\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\r\n      prototype[method] = function (arg) {\r\n        return this._invoke(method, arg);\r\n      };\r\n    });\r\n  }\r\n\r\n  exports.isGeneratorFunction = function (genFun) {\r\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\r\n    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\r\n    // do is to check its .name property.\r\n    (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\r\n  };\r\n\r\n  exports.mark = function (genFun) {\r\n    if (Object.setPrototypeOf) {\r\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\r\n    } else {\r\n      genFun.__proto__ = GeneratorFunctionPrototype;\r\n\r\n      if (!(toStringTagSymbol in genFun)) {\r\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\r\n      }\r\n    }\r\n\r\n    genFun.prototype = Object.create(Gp);\r\n    return genFun;\r\n  }; // Within the body of any async function, `await x` is transformed to\r\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\r\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\r\n  // meant to be awaited.\r\n\r\n\r\n  exports.awrap = function (arg) {\r\n    return {\r\n      __await: arg\r\n    };\r\n  };\r\n\r\n  function AsyncIterator(generator, PromiseImpl) {\r\n    function invoke(method, arg, resolve, reject) {\r\n      var record = tryCatch(generator[method], generator, arg);\r\n\r\n      if (record.type === \"throw\") {\r\n        reject(record.arg);\r\n      } else {\r\n        var result = record.arg;\r\n        var value = result.value;\r\n\r\n        if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\r\n          return PromiseImpl.resolve(value.__await).then(function (value) {\r\n            invoke(\"next\", value, resolve, reject);\r\n          }, function (err) {\r\n            invoke(\"throw\", err, resolve, reject);\r\n          });\r\n        }\r\n\r\n        return PromiseImpl.resolve(value).then(function (unwrapped) {\r\n          // When a yielded Promise is resolved, its final value becomes\r\n          // the .value of the Promise<{value,done}> result for the\r\n          // current iteration.\r\n          result.value = unwrapped;\r\n          resolve(result);\r\n        }, function (error) {\r\n          // If a rejected Promise was yielded, throw the rejection back\r\n          // into the async generator function so it can be handled there.\r\n          return invoke(\"throw\", error, resolve, reject);\r\n        });\r\n      }\r\n    }\r\n\r\n    var previousPromise;\r\n\r\n    function enqueue(method, arg) {\r\n      function callInvokeWithMethodAndArg() {\r\n        return new PromiseImpl(function (resolve, reject) {\r\n          invoke(method, arg, resolve, reject);\r\n        });\r\n      }\r\n\r\n      return previousPromise = // If enqueue has been called before, then we want to wait until\r\n      // all previous Promises have been resolved before calling invoke,\r\n      // so that results are always delivered in the correct order. If\r\n      // enqueue has not been called before, then it is important to\r\n      // call invoke immediately, without waiting on a callback to fire,\r\n      // so that the async generator function has the opportunity to do\r\n      // any necessary setup in a predictable way. This predictability\r\n      // is why the Promise constructor synchronously invokes its\r\n      // executor callback, and why async functions synchronously\r\n      // execute code before the first await. Since we implement simple\r\n      // async functions in terms of async generators, it is especially\r\n      // important to get this right, even though it requires care.\r\n      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\r\n      // invocations of the iterator.\r\n      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\r\n    } // Define the unified helper method that is used to implement .next,\r\n    // .throw, and .return (see defineIteratorMethods).\r\n\r\n\r\n    this._invoke = enqueue;\r\n  }\r\n\r\n  defineIteratorMethods(AsyncIterator.prototype);\r\n\r\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\r\n    return this;\r\n  };\r\n\r\n  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of\r\n  // AsyncIterator objects; they just return a Promise for the value of\r\n  // the final result produced by the iterator.\r\n\r\n  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\r\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\r\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\r\n    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\r\n    : iter.next().then(function (result) {\r\n      return result.done ? result.value : iter.next();\r\n    });\r\n  };\r\n\r\n  function makeInvokeMethod(innerFn, self, context) {\r\n    var state = GenStateSuspendedStart;\r\n    return function invoke(method, arg) {\r\n      if (state === GenStateExecuting) {\r\n        throw new Error(\"Generator is already running\");\r\n      }\r\n\r\n      if (state === GenStateCompleted) {\r\n        if (method === \"throw\") {\r\n          throw arg;\r\n        } // Be forgiving, per 25.3.3.3.3 of the spec:\r\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\r\n\r\n\r\n        return doneResult();\r\n      }\r\n\r\n      context.method = method;\r\n      context.arg = arg;\r\n\r\n      while (true) {\r\n        var delegate = context.delegate;\r\n\r\n        if (delegate) {\r\n          var delegateResult = maybeInvokeDelegate(delegate, context);\r\n\r\n          if (delegateResult) {\r\n            if (delegateResult === ContinueSentinel) continue;\r\n            return delegateResult;\r\n          }\r\n        }\r\n\r\n        if (context.method === \"next\") {\r\n          // Setting context._sent for legacy support of Babel's\r\n          // function.sent implementation.\r\n          context.sent = context._sent = context.arg;\r\n        } else if (context.method === \"throw\") {\r\n          if (state === GenStateSuspendedStart) {\r\n            state = GenStateCompleted;\r\n            throw context.arg;\r\n          }\r\n\r\n          context.dispatchException(context.arg);\r\n        } else if (context.method === \"return\") {\r\n          context.abrupt(\"return\", context.arg);\r\n        }\r\n\r\n        state = GenStateExecuting;\r\n        var record = tryCatch(innerFn, self, context);\r\n\r\n        if (record.type === \"normal\") {\r\n          // If an exception is thrown from innerFn, we leave state ===\r\n          // GenStateExecuting and loop back for another invocation.\r\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\r\n\r\n          if (record.arg === ContinueSentinel) {\r\n            continue;\r\n          }\r\n\r\n          return {\r\n            value: record.arg,\r\n            done: context.done\r\n          };\r\n        } else if (record.type === \"throw\") {\r\n          state = GenStateCompleted; // Dispatch the exception by looping back around to the\r\n          // context.dispatchException(context.arg) call above.\r\n\r\n          context.method = \"throw\";\r\n          context.arg = record.arg;\r\n        }\r\n      }\r\n    };\r\n  } // Call delegate.iterator[context.method](context.arg) and handle the\r\n  // result, either by returning a { value, done } result from the\r\n  // delegate iterator, or by modifying context.method and context.arg,\r\n  // setting context.delegate to null, and returning the ContinueSentinel.\r\n\r\n\r\n  function maybeInvokeDelegate(delegate, context) {\r\n    var method = delegate.iterator[context.method];\r\n\r\n    if (method === undefined) {\r\n      // A .throw or .return when the delegate iterator has no .throw\r\n      // method always terminates the yield* loop.\r\n      context.delegate = null;\r\n\r\n      if (context.method === \"throw\") {\r\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\r\n        if (delegate.iterator[\"return\"]) {\r\n          // If the delegate iterator has a return method, give it a\r\n          // chance to clean up.\r\n          context.method = \"return\";\r\n          context.arg = undefined;\r\n          maybeInvokeDelegate(delegate, context);\r\n\r\n          if (context.method === \"throw\") {\r\n            // If maybeInvokeDelegate(context) changed context.method from\r\n            // \"return\" to \"throw\", let that override the TypeError below.\r\n            return ContinueSentinel;\r\n          }\r\n        }\r\n\r\n        context.method = \"throw\";\r\n        context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\r\n      }\r\n\r\n      return ContinueSentinel;\r\n    }\r\n\r\n    var record = tryCatch(method, delegate.iterator, context.arg);\r\n\r\n    if (record.type === \"throw\") {\r\n      context.method = \"throw\";\r\n      context.arg = record.arg;\r\n      context.delegate = null;\r\n      return ContinueSentinel;\r\n    }\r\n\r\n    var info = record.arg;\r\n\r\n    if (!info) {\r\n      context.method = \"throw\";\r\n      context.arg = new TypeError(\"iterator result is not an object\");\r\n      context.delegate = null;\r\n      return ContinueSentinel;\r\n    }\r\n\r\n    if (info.done) {\r\n      // Assign the result of the finished delegate to the temporary\r\n      // variable specified by delegate.resultName (see delegateYield).\r\n      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).\r\n\r\n      context.next = delegate.nextLoc; // If context.method was \"throw\" but the delegate handled the\r\n      // exception, let the outer generator proceed normally. If\r\n      // context.method was \"next\", forget context.arg since it has been\r\n      // \"consumed\" by the delegate iterator. If context.method was\r\n      // \"return\", allow the original .return call to continue in the\r\n      // outer generator.\r\n\r\n      if (context.method !== \"return\") {\r\n        context.method = \"next\";\r\n        context.arg = undefined;\r\n      }\r\n    } else {\r\n      // Re-yield the result returned by the delegate method.\r\n      return info;\r\n    } // The delegate iterator is finished, so forget it and continue with\r\n    // the outer generator.\r\n\r\n\r\n    context.delegate = null;\r\n    return ContinueSentinel;\r\n  } // Define Generator.prototype.{next,throw,return} in terms of the\r\n  // unified ._invoke helper method.\r\n\r\n\r\n  defineIteratorMethods(Gp);\r\n  Gp[toStringTagSymbol] = \"Generator\"; // A Generator should always return itself as the iterator object when the\r\n  // @@iterator function is called on it. Some browsers' implementations of the\r\n  // iterator prototype chain incorrectly implement this, causing the Generator\r\n  // object to not be returned from this call. This ensures that doesn't happen.\r\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\r\n\r\n  Gp[iteratorSymbol] = function () {\r\n    return this;\r\n  };\r\n\r\n  Gp.toString = function () {\r\n    return \"[object Generator]\";\r\n  };\r\n\r\n  function pushTryEntry(locs) {\r\n    var entry = {\r\n      tryLoc: locs[0]\r\n    };\r\n\r\n    if (1 in locs) {\r\n      entry.catchLoc = locs[1];\r\n    }\r\n\r\n    if (2 in locs) {\r\n      entry.finallyLoc = locs[2];\r\n      entry.afterLoc = locs[3];\r\n    }\r\n\r\n    this.tryEntries.push(entry);\r\n  }\r\n\r\n  function resetTryEntry(entry) {\r\n    var record = entry.completion || {};\r\n    record.type = \"normal\";\r\n    delete record.arg;\r\n    entry.completion = record;\r\n  }\r\n\r\n  function Context(tryLocsList) {\r\n    // The root entry object (effectively a try statement without a catch\r\n    // or a finally block) gives us a place to store values thrown from\r\n    // locations where there is no enclosing try statement.\r\n    this.tryEntries = [{\r\n      tryLoc: \"root\"\r\n    }];\r\n    tryLocsList.forEach(pushTryEntry, this);\r\n    this.reset(true);\r\n  }\r\n\r\n  exports.keys = function (object) {\r\n    var keys = [];\r\n\r\n    for (var key in object) {\r\n      keys.push(key);\r\n    }\r\n\r\n    keys.reverse(); // Rather than returning an object with a next method, we keep\r\n    // things simple and return the next function itself.\r\n\r\n    return function next() {\r\n      while (keys.length) {\r\n        var key = keys.pop();\r\n\r\n        if (key in object) {\r\n          next.value = key;\r\n          next.done = false;\r\n          return next;\r\n        }\r\n      } // To avoid creating an additional object, we just hang the .value\r\n      // and .done properties off the next function object itself. This\r\n      // also ensures that the minifier will not anonymize the function.\r\n\r\n\r\n      next.done = true;\r\n      return next;\r\n    };\r\n  };\r\n\r\n  function values(iterable) {\r\n    if (iterable) {\r\n      var iteratorMethod = iterable[iteratorSymbol];\r\n\r\n      if (iteratorMethod) {\r\n        return iteratorMethod.call(iterable);\r\n      }\r\n\r\n      if (typeof iterable.next === \"function\") {\r\n        return iterable;\r\n      }\r\n\r\n      if (!isNaN(iterable.length)) {\r\n        var i = -1,\r\n            next = function next() {\r\n          while (++i < iterable.length) {\r\n            if (hasOwn.call(iterable, i)) {\r\n              next.value = iterable[i];\r\n              next.done = false;\r\n              return next;\r\n            }\r\n          }\r\n\r\n          next.value = undefined;\r\n          next.done = true;\r\n          return next;\r\n        };\r\n\r\n        return next.next = next;\r\n      }\r\n    } // Return an iterator with no values.\r\n\r\n\r\n    return {\r\n      next: doneResult\r\n    };\r\n  }\r\n\r\n  exports.values = values;\r\n\r\n  function doneResult() {\r\n    return {\r\n      value: undefined,\r\n      done: true\r\n    };\r\n  }\r\n\r\n  Context.prototype = {\r\n    constructor: Context,\r\n    reset: function (skipTempReset) {\r\n      this.prev = 0;\r\n      this.next = 0; // Resetting context._sent for legacy support of Babel's\r\n      // function.sent implementation.\r\n\r\n      this.sent = this._sent = undefined;\r\n      this.done = false;\r\n      this.delegate = null;\r\n      this.method = \"next\";\r\n      this.arg = undefined;\r\n      this.tryEntries.forEach(resetTryEntry);\r\n\r\n      if (!skipTempReset) {\r\n        for (var name in this) {\r\n          // Not sure about the optimal order of these conditions:\r\n          if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\r\n            this[name] = undefined;\r\n          }\r\n        }\r\n      }\r\n    },\r\n    stop: function () {\r\n      this.done = true;\r\n      var rootEntry = this.tryEntries[0];\r\n      var rootRecord = rootEntry.completion;\r\n\r\n      if (rootRecord.type === \"throw\") {\r\n        throw rootRecord.arg;\r\n      }\r\n\r\n      return this.rval;\r\n    },\r\n    dispatchException: function (exception) {\r\n      if (this.done) {\r\n        throw exception;\r\n      }\r\n\r\n      var context = this;\r\n\r\n      function handle(loc, caught) {\r\n        record.type = \"throw\";\r\n        record.arg = exception;\r\n        context.next = loc;\r\n\r\n        if (caught) {\r\n          // If the dispatched exception was caught by a catch block,\r\n          // then let that catch block handle the exception normally.\r\n          context.method = \"next\";\r\n          context.arg = undefined;\r\n        }\r\n\r\n        return !!caught;\r\n      }\r\n\r\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\r\n        var entry = this.tryEntries[i];\r\n        var record = entry.completion;\r\n\r\n        if (entry.tryLoc === \"root\") {\r\n          // Exception thrown outside of any try block that could handle\r\n          // it, so set the completion value of the entire function to\r\n          // throw the exception.\r\n          return handle(\"end\");\r\n        }\r\n\r\n        if (entry.tryLoc <= this.prev) {\r\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\r\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\r\n\r\n          if (hasCatch && hasFinally) {\r\n            if (this.prev < entry.catchLoc) {\r\n              return handle(entry.catchLoc, true);\r\n            } else if (this.prev < entry.finallyLoc) {\r\n              return handle(entry.finallyLoc);\r\n            }\r\n          } else if (hasCatch) {\r\n            if (this.prev < entry.catchLoc) {\r\n              return handle(entry.catchLoc, true);\r\n            }\r\n          } else if (hasFinally) {\r\n            if (this.prev < entry.finallyLoc) {\r\n              return handle(entry.finallyLoc);\r\n            }\r\n          } else {\r\n            throw new Error(\"try statement without catch or finally\");\r\n          }\r\n        }\r\n      }\r\n    },\r\n    abrupt: function (type, arg) {\r\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\r\n        var entry = this.tryEntries[i];\r\n\r\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\r\n          var finallyEntry = entry;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\r\n        // Ignore the finally entry if control is not jumping to a\r\n        // location outside the try/catch block.\r\n        finallyEntry = null;\r\n      }\r\n\r\n      var record = finallyEntry ? finallyEntry.completion : {};\r\n      record.type = type;\r\n      record.arg = arg;\r\n\r\n      if (finallyEntry) {\r\n        this.method = \"next\";\r\n        this.next = finallyEntry.finallyLoc;\r\n        return ContinueSentinel;\r\n      }\r\n\r\n      return this.complete(record);\r\n    },\r\n    complete: function (record, afterLoc) {\r\n      if (record.type === \"throw\") {\r\n        throw record.arg;\r\n      }\r\n\r\n      if (record.type === \"break\" || record.type === \"continue\") {\r\n        this.next = record.arg;\r\n      } else if (record.type === \"return\") {\r\n        this.rval = this.arg = record.arg;\r\n        this.method = \"return\";\r\n        this.next = \"end\";\r\n      } else if (record.type === \"normal\" && afterLoc) {\r\n        this.next = afterLoc;\r\n      }\r\n\r\n      return ContinueSentinel;\r\n    },\r\n    finish: function (finallyLoc) {\r\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\r\n        var entry = this.tryEntries[i];\r\n\r\n        if (entry.finallyLoc === finallyLoc) {\r\n          this.complete(entry.completion, entry.afterLoc);\r\n          resetTryEntry(entry);\r\n          return ContinueSentinel;\r\n        }\r\n      }\r\n    },\r\n    \"catch\": function (tryLoc) {\r\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\r\n        var entry = this.tryEntries[i];\r\n\r\n        if (entry.tryLoc === tryLoc) {\r\n          var record = entry.completion;\r\n\r\n          if (record.type === \"throw\") {\r\n            var thrown = record.arg;\r\n            resetTryEntry(entry);\r\n          }\r\n\r\n          return thrown;\r\n        }\r\n      } // The context.catch method must only be called with a location\r\n      // argument that corresponds to a known catch block.\r\n\r\n\r\n      throw new Error(\"illegal catch attempt\");\r\n    },\r\n    delegateYield: function (iterable, resultName, nextLoc) {\r\n      this.delegate = {\r\n        iterator: values(iterable),\r\n        resultName: resultName,\r\n        nextLoc: nextLoc\r\n      };\r\n\r\n      if (this.method === \"next\") {\r\n        // Deliberately forget the last sent value so that we don't\r\n        // accidentally pass it on to the delegate.\r\n        this.arg = undefined;\r\n      }\r\n\r\n      return ContinueSentinel;\r\n    }\r\n  }; // Regardless of whether this script is executing as a CommonJS module\r\n  // or not, return the runtime object so that we can declare the variable\r\n  // regeneratorRuntime in the outer scope, which allows this module to be\r\n  // injected easily by `bin/regenerator --include-runtime script.js`.\r\n\r\n  return exports;\r\n}( // If this script is executing as a CommonJS module, use module.exports\r\n// as the regeneratorRuntime namespace. Otherwise create a new empty\r\n// object. Either way, the resulting object will be used to initialize\r\n// the regeneratorRuntime variable at the top of this file.\r\n  true ? module.exports : 0);\r\n\r\ntry {\r\n  regeneratorRuntime = runtime;\r\n} catch (accidentalStrictMode) {\r\n  // This module should not be running in strict mode, so the above\r\n  // assignment should always work unless something is misconfigured. Just\r\n  // in case runtime.js accidentally runs in strict mode, we can escape\r\n  // strict mode using a global Function call. This could conceivably fail\r\n  // if a Content Security Policy forbids using Function, but in that case\r\n  // the proper solution is to fix the accidental strict mode problem. If\r\n  // you've misconfigured your bundler to force strict mode and applied a\r\n  // CSP to forbid Function, and you're not willing to fix either of those\r\n  // problems, please detail your unique predicament in a GitHub issue.\r\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\r\n}\r\n\r\n/***/ }),\r\n/* 225 */\r\n/***/ (function(module, exports, __nested_webpack_require_239255__) {\r\n\r\nvar getPrototypeOf = __nested_webpack_require_239255__(2);\r\n\r\nfunction _superPropBase(object, property) {\r\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\r\n    object = getPrototypeOf(object);\r\n    if (object === null) break;\r\n  }\r\n\r\n  return object;\r\n}\r\n\r\nmodule.exports = _superPropBase, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 226 */\r\n/***/ (function(module, exports, __nested_webpack_require_239713__) {\r\n\r\nvar arrayLikeToArray = __nested_webpack_require_239713__(61);\r\n\r\nfunction _arrayWithoutHoles(arr) {\r\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\r\n}\r\n\r\nmodule.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 227 */\r\n/***/ (function(module, exports) {\r\n\r\nfunction _iterableToArray(iter) {\r\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\r\n}\r\n\r\nmodule.exports = _iterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 228 */\r\n/***/ (function(module, exports) {\r\n\r\nfunction _nonIterableSpread() {\r\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\r\n}\r\n\r\nmodule.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 229 */\r\n/***/ (function(module, exports, __nested_webpack_require_240779__) {\r\n\r\nvar basePickBy = __nested_webpack_require_240779__(230),\r\n    hasIn = __nested_webpack_require_240779__(240);\r\n/**\r\n * The base implementation of `_.pick` without support for individual\r\n * property identifiers.\r\n *\r\n * @private\r\n * @param {Object} object The source object.\r\n * @param {string[]} paths The property paths to pick.\r\n * @returns {Object} Returns the new object.\r\n */\r\n\r\n\r\nfunction basePick(object, paths) {\r\n  return basePickBy(object, paths, function (value, path) {\r\n    return hasIn(object, path);\r\n  });\r\n}\r\n\r\nmodule.exports = basePick;\r\n\r\n/***/ }),\r\n/* 230 */\r\n/***/ (function(module, exports, __nested_webpack_require_241391__) {\r\n\r\nvar baseGet = __nested_webpack_require_241391__(231),\r\n    baseSet = __nested_webpack_require_241391__(239),\r\n    castPath = __nested_webpack_require_241391__(32);\r\n/**\r\n * The base implementation of  `_.pickBy` without support for iteratee shorthands.\r\n *\r\n * @private\r\n * @param {Object} object The source object.\r\n * @param {string[]} paths The property paths to pick.\r\n * @param {Function} predicate The function invoked per property.\r\n * @returns {Object} Returns the new object.\r\n */\r\n\r\n\r\nfunction basePickBy(object, paths, predicate) {\r\n  var index = -1,\r\n      length = paths.length,\r\n      result = {};\r\n\r\n  while (++index < length) {\r\n    var path = paths[index],\r\n        value = baseGet(object, path);\r\n\r\n    if (predicate(value, path)) {\r\n      baseSet(result, castPath(path, object), value);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports = basePickBy;\r\n\r\n/***/ }),\r\n/* 231 */\r\n/***/ (function(module, exports, __nested_webpack_require_242306__) {\r\n\r\nvar castPath = __nested_webpack_require_242306__(32),\r\n    toKey = __nested_webpack_require_242306__(43);\r\n/**\r\n * The base implementation of `_.get` without support for default values.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @param {Array|string} path The path of the property to get.\r\n * @returns {*} Returns the resolved value.\r\n */\r\n\r\n\r\nfunction baseGet(object, path) {\r\n  path = castPath(path, object);\r\n  var index = 0,\r\n      length = path.length;\r\n\r\n  while (object != null && index < length) {\r\n    object = object[toKey(path[index++])];\r\n  }\r\n\r\n  return index && index == length ? object : undefined;\r\n}\r\n\r\nmodule.exports = baseGet;\r\n\r\n/***/ }),\r\n/* 232 */\r\n/***/ (function(module, exports, __nested_webpack_require_243034__) {\r\n\r\nvar isArray = __nested_webpack_require_243034__(16),\r\n    isSymbol = __nested_webpack_require_243034__(42);\r\n/** Used to match property names within property paths. */\r\n\r\n\r\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\r\n    reIsPlainProp = /^\\w*$/;\r\n/**\r\n * Checks if `value` is a property name and not a property path.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @param {Object} [object] The object to query keys on.\r\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\r\n */\r\n\r\nfunction isKey(value, object) {\r\n  if (isArray(value)) {\r\n    return false;\r\n  }\r\n\r\n  var type = typeof value;\r\n\r\n  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {\r\n    return true;\r\n  }\r\n\r\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\r\n}\r\n\r\nmodule.exports = isKey;\r\n\r\n/***/ }),\r\n/* 233 */\r\n/***/ (function(module, exports, __nested_webpack_require_244025__) {\r\n\r\nvar memoizeCapped = __nested_webpack_require_244025__(234);\r\n/** Used to match property names within property paths. */\r\n\r\n\r\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\r\n/** Used to match backslashes in property paths. */\r\n\r\nvar reEscapeChar = /\\\\(\\\\)?/g;\r\n/**\r\n * Converts `string` to a property path array.\r\n *\r\n * @private\r\n * @param {string} string The string to convert.\r\n * @returns {Array} Returns the property path array.\r\n */\r\n\r\nvar stringToPath = memoizeCapped(function (string) {\r\n  var result = [];\r\n\r\n  if (string.charCodeAt(0) === 46\r\n  /* . */\r\n  ) {\r\n    result.push('');\r\n  }\r\n\r\n  string.replace(rePropName, function (match, number, quote, subString) {\r\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);\r\n  });\r\n  return result;\r\n});\r\nmodule.exports = stringToPath;\r\n\r\n/***/ }),\r\n/* 234 */\r\n/***/ (function(module, exports, __nested_webpack_require_244983__) {\r\n\r\nvar memoize = __nested_webpack_require_244983__(235);\r\n/** Used as the maximum memoize cache size. */\r\n\r\n\r\nvar MAX_MEMOIZE_SIZE = 500;\r\n/**\r\n * A specialized version of `_.memoize` which clears the memoized function's\r\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\r\n *\r\n * @private\r\n * @param {Function} func The function to have its output memoized.\r\n * @returns {Function} Returns the new memoized function.\r\n */\r\n\r\nfunction memoizeCapped(func) {\r\n  var result = memoize(func, function (key) {\r\n    if (cache.size === MAX_MEMOIZE_SIZE) {\r\n      cache.clear();\r\n    }\r\n\r\n    return key;\r\n  });\r\n  var cache = result.cache;\r\n  return result;\r\n}\r\n\r\nmodule.exports = memoizeCapped;\r\n\r\n/***/ }),\r\n/* 235 */\r\n/***/ (function(module, exports, __nested_webpack_require_245732__) {\r\n\r\nvar MapCache = __nested_webpack_require_245732__(47);\r\n/** Error message constants. */\r\n\r\n\r\nvar FUNC_ERROR_TEXT = 'Expected a function';\r\n/**\r\n * Creates a function that memoizes the result of `func`. If `resolver` is\r\n * provided, it determines the cache key for storing the result based on the\r\n * arguments provided to the memoized function. By default, the first argument\r\n * provided to the memoized function is used as the map cache key. The `func`\r\n * is invoked with the `this` binding of the memoized function.\r\n *\r\n * **Note:** The cache is exposed as the `cache` property on the memoized\r\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\r\n * constructor with one whose instances implement the\r\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\r\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Function\r\n * @param {Function} func The function to have its output memoized.\r\n * @param {Function} [resolver] The function to resolve the cache key.\r\n * @returns {Function} Returns the new memoized function.\r\n * @example\r\n *\r\n * var object = { 'a': 1, 'b': 2 };\r\n * var other = { 'c': 3, 'd': 4 };\r\n *\r\n * var values = _.memoize(_.values);\r\n * values(object);\r\n * // => [1, 2]\r\n *\r\n * values(other);\r\n * // => [3, 4]\r\n *\r\n * object.a = 2;\r\n * values(object);\r\n * // => [1, 2]\r\n *\r\n * // Modify the result cache.\r\n * values.cache.set(object, ['a', 'b']);\r\n * values(object);\r\n * // => ['a', 'b']\r\n *\r\n * // Replace `_.memoize.Cache`.\r\n * _.memoize.Cache = WeakMap;\r\n */\r\n\r\nfunction memoize(func, resolver) {\r\n  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {\r\n    throw new TypeError(FUNC_ERROR_TEXT);\r\n  }\r\n\r\n  var memoized = function () {\r\n    var args = arguments,\r\n        key = resolver ? resolver.apply(this, args) : args[0],\r\n        cache = memoized.cache;\r\n\r\n    if (cache.has(key)) {\r\n      return cache.get(key);\r\n    }\r\n\r\n    var result = func.apply(this, args);\r\n    memoized.cache = cache.set(key, result) || cache;\r\n    return result;\r\n  };\r\n\r\n  memoized.cache = new (memoize.Cache || MapCache)();\r\n  return memoized;\r\n} // Expose `MapCache`.\r\n\r\n\r\nmemoize.Cache = MapCache;\r\nmodule.exports = memoize;\r\n\r\n/***/ }),\r\n/* 236 */\r\n/***/ (function(module, exports, __nested_webpack_require_248121__) {\r\n\r\nvar baseToString = __nested_webpack_require_248121__(237);\r\n/**\r\n * Converts `value` to a string. An empty string is returned for `null`\r\n * and `undefined` values. The sign of `-0` is preserved.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to convert.\r\n * @returns {string} Returns the converted string.\r\n * @example\r\n *\r\n * _.toString(null);\r\n * // => ''\r\n *\r\n * _.toString(-0);\r\n * // => '-0'\r\n *\r\n * _.toString([1, 2, 3]);\r\n * // => '1,2,3'\r\n */\r\n\r\n\r\nfunction toString(value) {\r\n  return value == null ? '' : baseToString(value);\r\n}\r\n\r\nmodule.exports = toString;\r\n\r\n/***/ }),\r\n/* 237 */\r\n/***/ (function(module, exports, __nested_webpack_require_248812__) {\r\n\r\nvar Symbol = __nested_webpack_require_248812__(27),\r\n    arrayMap = __nested_webpack_require_248812__(238),\r\n    isArray = __nested_webpack_require_248812__(16),\r\n    isSymbol = __nested_webpack_require_248812__(42);\r\n/** Used as references for various `Number` constants. */\r\n\r\n\r\nvar INFINITY = 1 / 0;\r\n/** Used to convert symbols to primitives and strings. */\r\n\r\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\r\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\r\n/**\r\n * The base implementation of `_.toString` which doesn't convert nullish\r\n * values to empty strings.\r\n *\r\n * @private\r\n * @param {*} value The value to process.\r\n * @returns {string} Returns the string.\r\n */\r\n\r\nfunction baseToString(value) {\r\n  // Exit early for strings to avoid a performance hit in some environments.\r\n  if (typeof value == 'string') {\r\n    return value;\r\n  }\r\n\r\n  if (isArray(value)) {\r\n    // Recursively convert values (susceptible to call stack limits).\r\n    return arrayMap(value, baseToString) + '';\r\n  }\r\n\r\n  if (isSymbol(value)) {\r\n    return symbolToString ? symbolToString.call(value) : '';\r\n  }\r\n\r\n  var result = value + '';\r\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\r\n}\r\n\r\nmodule.exports = baseToString;\r\n\r\n/***/ }),\r\n/* 238 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * A specialized version of `_.map` for arrays without support for iteratee\r\n * shorthands.\r\n *\r\n * @private\r\n * @param {Array} [array] The array to iterate over.\r\n * @param {Function} iteratee The function invoked per iteration.\r\n * @returns {Array} Returns the new mapped array.\r\n */\r\nfunction arrayMap(array, iteratee) {\r\n  var index = -1,\r\n      length = array == null ? 0 : array.length,\r\n      result = Array(length);\r\n\r\n  while (++index < length) {\r\n    result[index] = iteratee(array[index], index, array);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports = arrayMap;\r\n\r\n/***/ }),\r\n/* 239 */\r\n/***/ (function(module, exports, __nested_webpack_require_250739__) {\r\n\r\nvar assignValue = __nested_webpack_require_250739__(55),\r\n    castPath = __nested_webpack_require_250739__(32),\r\n    isIndex = __nested_webpack_require_250739__(31),\r\n    isObject = __nested_webpack_require_250739__(15),\r\n    toKey = __nested_webpack_require_250739__(43);\r\n/**\r\n * The base implementation of `_.set`.\r\n *\r\n * @private\r\n * @param {Object} object The object to modify.\r\n * @param {Array|string} path The path of the property to set.\r\n * @param {*} value The value to set.\r\n * @param {Function} [customizer] The function to customize path creation.\r\n * @returns {Object} Returns `object`.\r\n */\r\n\r\n\r\nfunction baseSet(object, path, value, customizer) {\r\n  if (!isObject(object)) {\r\n    return object;\r\n  }\r\n\r\n  path = castPath(path, object);\r\n  var index = -1,\r\n      length = path.length,\r\n      lastIndex = length - 1,\r\n      nested = object;\r\n\r\n  while (nested != null && ++index < length) {\r\n    var key = toKey(path[index]),\r\n        newValue = value;\r\n\r\n    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\r\n      return object;\r\n    }\r\n\r\n    if (index != lastIndex) {\r\n      var objValue = nested[key];\r\n      newValue = customizer ? customizer(objValue, key, nested) : undefined;\r\n\r\n      if (newValue === undefined) {\r\n        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};\r\n      }\r\n    }\r\n\r\n    assignValue(nested, key, newValue);\r\n    nested = nested[key];\r\n  }\r\n\r\n  return object;\r\n}\r\n\r\nmodule.exports = baseSet;\r\n\r\n/***/ }),\r\n/* 240 */\r\n/***/ (function(module, exports, __nested_webpack_require_252249__) {\r\n\r\nvar baseHasIn = __nested_webpack_require_252249__(241),\r\n    hasPath = __nested_webpack_require_252249__(242);\r\n/**\r\n * Checks if `path` is a direct or inherited property of `object`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Object\r\n * @param {Object} object The object to query.\r\n * @param {Array|string} path The path to check.\r\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\r\n * @example\r\n *\r\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\r\n *\r\n * _.hasIn(object, 'a');\r\n * // => true\r\n *\r\n * _.hasIn(object, 'a.b');\r\n * // => true\r\n *\r\n * _.hasIn(object, ['a', 'b']);\r\n * // => true\r\n *\r\n * _.hasIn(object, 'b');\r\n * // => false\r\n */\r\n\r\n\r\nfunction hasIn(object, path) {\r\n  return object != null && hasPath(object, path, baseHasIn);\r\n}\r\n\r\nmodule.exports = hasIn;\r\n\r\n/***/ }),\r\n/* 241 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * The base implementation of `_.hasIn` without support for deep paths.\r\n *\r\n * @private\r\n * @param {Object} [object] The object to query.\r\n * @param {Array|string} key The key to check.\r\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\r\n */\r\nfunction baseHasIn(object, key) {\r\n  return object != null && key in Object(object);\r\n}\r\n\r\nmodule.exports = baseHasIn;\r\n\r\n/***/ }),\r\n/* 242 */\r\n/***/ (function(module, exports, __nested_webpack_require_253574__) {\r\n\r\nvar castPath = __nested_webpack_require_253574__(32),\r\n    isArguments = __nested_webpack_require_253574__(30),\r\n    isArray = __nested_webpack_require_253574__(16),\r\n    isIndex = __nested_webpack_require_253574__(31),\r\n    isLength = __nested_webpack_require_253574__(40),\r\n    toKey = __nested_webpack_require_253574__(43);\r\n/**\r\n * Checks if `path` exists on `object`.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @param {Array|string} path The path to check.\r\n * @param {Function} hasFunc The function to check properties.\r\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\r\n */\r\n\r\n\r\nfunction hasPath(object, path, hasFunc) {\r\n  path = castPath(path, object);\r\n  var index = -1,\r\n      length = path.length,\r\n      result = false;\r\n\r\n  while (++index < length) {\r\n    var key = toKey(path[index]);\r\n\r\n    if (!(result = object != null && hasFunc(object, key))) {\r\n      break;\r\n    }\r\n\r\n    object = object[key];\r\n  }\r\n\r\n  if (result || ++index != length) {\r\n    return result;\r\n  }\r\n\r\n  length = object == null ? 0 : object.length;\r\n  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));\r\n}\r\n\r\nmodule.exports = hasPath;\r\n\r\n/***/ }),\r\n/* 243 */\r\n/***/ (function(module, exports, __nested_webpack_require_254795__) {\r\n\r\nvar flatten = __nested_webpack_require_254795__(244),\r\n    overRest = __nested_webpack_require_254795__(58),\r\n    setToString = __nested_webpack_require_254795__(59);\r\n/**\r\n * A specialized version of `baseRest` which flattens the rest array.\r\n *\r\n * @private\r\n * @param {Function} func The function to apply a rest parameter to.\r\n * @returns {Function} Returns the new function.\r\n */\r\n\r\n\r\nfunction flatRest(func) {\r\n  return setToString(overRest(func, undefined, flatten), func + '');\r\n}\r\n\r\nmodule.exports = flatRest;\r\n\r\n/***/ }),\r\n/* 244 */\r\n/***/ (function(module, exports, __nested_webpack_require_255356__) {\r\n\r\nvar baseFlatten = __nested_webpack_require_255356__(245);\r\n/**\r\n * Flattens `array` a single level deep.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Array\r\n * @param {Array} array The array to flatten.\r\n * @returns {Array} Returns the new flattened array.\r\n * @example\r\n *\r\n * _.flatten([1, [2, [3, [4]], 5]]);\r\n * // => [1, 2, [3, [4]], 5]\r\n */\r\n\r\n\r\nfunction flatten(array) {\r\n  var length = array == null ? 0 : array.length;\r\n  return length ? baseFlatten(array, 1) : [];\r\n}\r\n\r\nmodule.exports = flatten;\r\n\r\n/***/ }),\r\n/* 245 */\r\n/***/ (function(module, exports, __nested_webpack_require_255951__) {\r\n\r\nvar arrayPush = __nested_webpack_require_255951__(246),\r\n    isFlattenable = __nested_webpack_require_255951__(247);\r\n/**\r\n * The base implementation of `_.flatten` with support for restricting flattening.\r\n *\r\n * @private\r\n * @param {Array} array The array to flatten.\r\n * @param {number} depth The maximum recursion depth.\r\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\r\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\r\n * @param {Array} [result=[]] The initial result value.\r\n * @returns {Array} Returns the new flattened array.\r\n */\r\n\r\n\r\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\r\n  var index = -1,\r\n      length = array.length;\r\n  predicate || (predicate = isFlattenable);\r\n  result || (result = []);\r\n\r\n  while (++index < length) {\r\n    var value = array[index];\r\n\r\n    if (depth > 0 && predicate(value)) {\r\n      if (depth > 1) {\r\n        // Recursively flatten arrays (susceptible to call stack limits).\r\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\r\n      } else {\r\n        arrayPush(result, value);\r\n      }\r\n    } else if (!isStrict) {\r\n      result[result.length] = value;\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports = baseFlatten;\r\n\r\n/***/ }),\r\n/* 246 */\r\n/***/ (function(module, exports) {\r\n\r\n/**\r\n * Appends the elements of `values` to `array`.\r\n *\r\n * @private\r\n * @param {Array} array The array to modify.\r\n * @param {Array} values The values to append.\r\n * @returns {Array} Returns `array`.\r\n */\r\nfunction arrayPush(array, values) {\r\n  var index = -1,\r\n      length = values.length,\r\n      offset = array.length;\r\n\r\n  while (++index < length) {\r\n    array[offset + index] = values[index];\r\n  }\r\n\r\n  return array;\r\n}\r\n\r\nmodule.exports = arrayPush;\r\n\r\n/***/ }),\r\n/* 247 */\r\n/***/ (function(module, exports, __nested_webpack_require_257796__) {\r\n\r\nvar Symbol = __nested_webpack_require_257796__(27),\r\n    isArguments = __nested_webpack_require_257796__(30),\r\n    isArray = __nested_webpack_require_257796__(16);\r\n/** Built-in value references. */\r\n\r\n\r\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\r\n/**\r\n * Checks if `value` is a flattenable `arguments` object or array.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\r\n */\r\n\r\nfunction isFlattenable(value) {\r\n  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);\r\n}\r\n\r\nmodule.exports = isFlattenable;\r\n\r\n/***/ }),\r\n/* 248 */\r\n/***/ (function(module, exports) {\r\n\r\nfunction _isNativeFunction(fn) {\r\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\r\n}\r\n\r\nmodule.exports = _isNativeFunction, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 249 */\r\n/***/ (function(module, exports, __nested_webpack_require_258795__) {\r\n\r\nvar setPrototypeOf = __nested_webpack_require_258795__(41);\r\n\r\nvar isNativeReflectConstruct = __nested_webpack_require_258795__(250);\r\n\r\nfunction _construct(Parent, args, Class) {\r\n  if (isNativeReflectConstruct()) {\r\n    module.exports = _construct = Reflect.construct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n  } else {\r\n    module.exports = _construct = function _construct(Parent, args, Class) {\r\n      var a = [null];\r\n      a.push.apply(a, args);\r\n      var Constructor = Function.bind.apply(Parent, a);\r\n      var instance = new Constructor();\r\n      if (Class) setPrototypeOf(instance, Class.prototype);\r\n      return instance;\r\n    }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n  }\r\n\r\n  return _construct.apply(null, arguments);\r\n}\r\n\r\nmodule.exports = _construct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 250 */\r\n/***/ (function(module, exports) {\r\n\r\nfunction _isNativeReflectConstruct() {\r\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\r\n  if (Reflect.construct.sham) return false;\r\n  if (typeof Proxy === \"function\") return true;\r\n\r\n  try {\r\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\r\n    return true;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}\r\n\r\nmodule.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\r\n\r\n/***/ }),\r\n/* 251 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = determinant;\r\n/**\r\n * Calculates the determinant of a mat2\r\n *\r\n * @alias mat2.determinant\r\n * @param {mat2} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\r\n\r\nfunction determinant(a) {\r\n  return a[0] * a[3] - a[2] * a[1];\r\n}\r\n\r\n/***/ }),\r\n/* 252 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = transpose;\r\n/**\r\n * Transpose the values of a mat2\r\n *\r\n * @alias mat2.transpose\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\r\n\r\nfunction transpose(out, a) {\r\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\r\n  if (out === a) {\r\n    var a1 = a[1];\r\n    out[1] = a[2];\r\n    out[2] = a1;\r\n  } else {\r\n    out[0] = a[0];\r\n    out[1] = a[2];\r\n    out[2] = a[1];\r\n    out[3] = a[3];\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 253 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = multiply;\r\n/**\r\n * Multiplies two mat2's\r\n *\r\n * @alias mat2.multiply\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the first operand\r\n * @param {mat2} b the second operand\r\n * @returns {mat2} out\r\n */\r\n\r\nfunction multiply(out, a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3];\r\n  out[0] = a0 * b0 + a2 * b1;\r\n  out[1] = a1 * b0 + a3 * b1;\r\n  out[2] = a0 * b2 + a2 * b3;\r\n  out[3] = a1 * b2 + a3 * b3;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 254 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = identity;\r\n/**\r\n * Set a mat2 to the identity matrix\r\n *\r\n * @alias mat2.identity\r\n * @param {mat2} out the receiving matrix\r\n * @returns {mat2} out\r\n */\r\n\r\nfunction identity(out) {\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 1;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 255 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = adjoint;\r\n/**\r\n * Calculates the adjugate of a mat2\r\n *\r\n * @alias mat2.adjoint\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\r\n\r\nfunction adjoint(out, a) {\r\n  // Caching this value is nessecary if out == a\r\n  var a0 = a[0];\r\n  out[0] = a[3];\r\n  out[1] = -a[1];\r\n  out[2] = -a[2];\r\n  out[3] = a0;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 256 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = rotate;\r\n/**\r\n * Rotates a mat2 by the given angle\r\n *\r\n * @alias mat2.rotate\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2} out\r\n */\r\n\r\nfunction rotate(out, a, rad) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n  out[0] = a0 * c + a2 * s;\r\n  out[1] = a1 * c + a3 * s;\r\n  out[2] = a0 * -s + a2 * c;\r\n  out[3] = a1 * -s + a3 * c;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 257 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = invert;\r\n/**\r\n * Inverts a mat2\r\n *\r\n * @alias mat2.invert\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\r\n\r\nfunction invert(out, a) {\r\n  var a0 = a[0];\r\n  var a1 = a[1];\r\n  var a2 = a[2];\r\n  var a3 = a[3];\r\n  var det = a0 * a3 - a2 * a1;\r\n  if (!det) return null;\r\n  det = 1.0 / det;\r\n  out[0] = a3 * det;\r\n  out[1] = -a1 * det;\r\n  out[2] = -a2 * det;\r\n  out[3] = a0 * det;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 258 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = create;\r\n/**\r\n * Creates a new identity mat2\r\n *\r\n * @alias mat2.create\r\n * @returns {mat2} a new 2x2 matrix\r\n */\r\n\r\nfunction create() {\r\n  var out = new Float32Array(4);\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 1;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 259 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = scale;\r\n/**\r\n * Scales the mat2 by the dimensions in the given vec2\r\n *\r\n * @alias mat2.scale\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the matrix to rotate\r\n * @param {vec2} v the vec2 to scale the matrix by\r\n * @returns {mat2} out\r\n **/\r\n\r\nfunction scale(out, a, v) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var v0 = v[0],\r\n      v1 = v[1];\r\n  out[0] = a0 * v0;\r\n  out[1] = a1 * v0;\r\n  out[2] = a2 * v1;\r\n  out[3] = a3 * v1;\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 260 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = copy;\r\n/**\r\n * Copy the values from one mat2 to another\r\n *\r\n * @alias mat2.copy\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\r\n\r\nfunction copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  return out;\r\n}\r\n\r\n/***/ }),\r\n/* 261 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = frob;\r\n/**\r\n * Returns Frobenius norm of a mat2\r\n *\r\n * @alias mat2.frob\r\n * @param {mat2} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\r\n\r\nfunction frob(a) {\r\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));\r\n}\r\n\r\n/***/ }),\r\n/* 262 */\r\n/***/ (function(module, exports) {\r\n\r\nmodule.exports = ldu;\r\n/**\r\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\r\n *\r\n * @alias mat2.ldu\r\n * @param {mat2} L the lower triangular matrix\r\n * @param {mat2} D the diagonal matrix\r\n * @param {mat2} U the upper triangular matrix\r\n * @param {mat2} a the input matrix to factorize\r\n */\r\n\r\nfunction ldu(L, D, U, a) {\r\n  L[2] = a[2] / a[0];\r\n  U[0] = a[0];\r\n  U[1] = a[1];\r\n  U[3] = a[3] - L[2] * U[1];\r\n  return [L, D, U];\r\n}\r\n\r\n/***/ }),\r\n/* 263 */\r\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_266069__) {\r\n\r\n\"use strict\";\r\n// ESM COMPAT FLAG\r\n__nested_webpack_require_266069__.r(__webpack_exports__);\r\n\r\n// EXPORTS\r\n__nested_webpack_require_266069__.d(__webpack_exports__, \"BarcodeDecoder\", function() { return /* reexport */ barcode_decoder; });\r\n__nested_webpack_require_266069__.d(__webpack_exports__, \"Readers\", function() { return /* reexport */ reader_namespaceObject; });\r\n__nested_webpack_require_266069__.d(__webpack_exports__, \"CameraAccess\", function() { return /* reexport */ camera_access; });\r\n__nested_webpack_require_266069__.d(__webpack_exports__, \"ImageDebug\", function() { return /* reexport */ image_debug[\"a\" /* default */]; });\r\n__nested_webpack_require_266069__.d(__webpack_exports__, \"ImageWrapper\", function() { return /* reexport */ image_wrapper[\"a\" /* default */]; });\r\n__nested_webpack_require_266069__.d(__webpack_exports__, \"ResultCollector\", function() { return /* reexport */ result_collector; });\r\n\r\n// NAMESPACE OBJECT: ./src/reader/index.ts\r\nvar reader_namespaceObject = {};\r\n__nested_webpack_require_266069__.r(reader_namespaceObject);\r\n__nested_webpack_require_266069__.d(reader_namespaceObject, \"BarcodeReader\", function() { return barcode_reader; });\r\n__nested_webpack_require_266069__.d(reader_namespaceObject, \"TwoOfFiveReader\", function() { return _2of5_reader; });\r\n__nested_webpack_require_266069__.d(reader_namespaceObject, \"NewCodabarReader\", function() { return codabar_reader; });\r\n__nested_webpack_require_266069__.d(reader_namespaceObject, \"Code128Reader\", function() { return code_128_reader; });\r\n__nested_webpack_require_266069__.d(reader_namespaceObject, \"Code32Reader\", function() { return code_32_reader; });\r\n__nested_webpack_require_266069__.d(reader_namespaceObject, \"Code39Reader\", function() { return code_39_reader; });\r\n__nested_webpack_require_266069__.d(reader_namespaceObject, \"Code39VINReader\", function() { return code_39_vin_reader; });\r\n__nested_webpack_require_266069__.d(reader_namespaceObject, \"Code93Reader\", function() { return code_93_reader; });\r\n__nested_webpack_require_266069__.d(reader_namespaceObject, \"EAN2Reader\", function() { return ean_2_reader; });\r\n__nested_webpack_require_266069__.d(reader_namespaceObject, \"EAN5Reader\", function() { return ean_5_reader; });\r\n__nested_webpack_require_266069__.d(reader_namespaceObject, \"EAN8Reader\", function() { return ean_8_reader; });\r\n__nested_webpack_require_266069__.d(reader_namespaceObject, \"EANReader\", function() { return ean_reader; });\r\n__nested_webpack_require_266069__.d(reader_namespaceObject, \"I2of5Reader\", function() { return i2of5_reader; });\r\n__nested_webpack_require_266069__.d(reader_namespaceObject, \"UPCEReader\", function() { return upc_e_reader; });\r\n__nested_webpack_require_266069__.d(reader_namespaceObject, \"UPCReader\", function() { return upc_reader; });\r\n\r\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js\r\nvar helpers_typeof = __nested_webpack_require_266069__(20);\r\nvar typeof_default = /*#__PURE__*/__nested_webpack_require_266069__.n(helpers_typeof);\r\n\r\n// EXTERNAL MODULE: ./node_modules/lodash/merge.js\r\nvar merge = __nested_webpack_require_266069__(17);\r\nvar merge_default = /*#__PURE__*/__nested_webpack_require_266069__.n(merge);\r\n\r\n// EXTERNAL MODULE: ./src/common/typedefs.js\r\nvar typedefs = __nested_webpack_require_266069__(152);\r\n\r\n// EXTERNAL MODULE: ./src/common/image_wrapper.ts\r\nvar image_wrapper = __nested_webpack_require_266069__(12);\r\n\r\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js\r\nvar asyncToGenerator = __nested_webpack_require_266069__(13);\r\nvar asyncToGenerator_default = /*#__PURE__*/__nested_webpack_require_266069__.n(asyncToGenerator);\r\n\r\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js\r\nvar regenerator = __nested_webpack_require_266069__(8);\r\nvar regenerator_default = /*#__PURE__*/__nested_webpack_require_266069__.n(regenerator);\r\n\r\n// EXTERNAL MODULE: ./src/common/image_debug.ts\r\nvar image_debug = __nested_webpack_require_266069__(10);\r\n\r\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js\r\nvar classCallCheck = __nested_webpack_require_266069__(3);\r\nvar classCallCheck_default = /*#__PURE__*/__nested_webpack_require_266069__.n(classCallCheck);\r\n\r\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js\r\nvar createClass = __nested_webpack_require_266069__(4);\r\nvar createClass_default = /*#__PURE__*/__nested_webpack_require_266069__.n(createClass);\r\n\r\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/assertThisInitialized.js\r\nvar assertThisInitialized = __nested_webpack_require_266069__(1);\r\nvar assertThisInitialized_default = /*#__PURE__*/__nested_webpack_require_266069__.n(assertThisInitialized);\r\n\r\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js\r\nvar inherits = __nested_webpack_require_266069__(6);\r\nvar inherits_default = /*#__PURE__*/__nested_webpack_require_266069__.n(inherits);\r\n\r\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\r\nvar possibleConstructorReturn = __nested_webpack_require_266069__(5);\r\nvar possibleConstructorReturn_default = /*#__PURE__*/__nested_webpack_require_266069__.n(possibleConstructorReturn);\r\n\r\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js\r\nvar getPrototypeOf = __nested_webpack_require_266069__(2);\r\nvar getPrototypeOf_default = /*#__PURE__*/__nested_webpack_require_266069__.n(getPrototypeOf);\r\n\r\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js\r\nvar defineProperty = __nested_webpack_require_266069__(0);\r\nvar defineProperty_default = /*#__PURE__*/__nested_webpack_require_266069__.n(defineProperty);\r\n\r\n// EXTERNAL MODULE: ./src/common/array_helper.ts\r\nvar array_helper = __nested_webpack_require_266069__(11);\r\n\r\n// CONCATENATED MODULE: ./src/reader/barcode_reader.ts\r\n\r\n\r\n\r\n\r\n/* eslint-disable no-unused-vars */\r\n\r\n/* eslint-disable class-methods-use-this */\r\n// eslint-disable-next-line import/no-cycle\r\n // for some reason this throws a shadow error on itself?!\r\n// eslint-disable-next-line no-shadow\r\n\r\nvar BarcodeDirection;\r\n\r\n(function (BarcodeDirection) {\r\n  BarcodeDirection[BarcodeDirection[\"Forward\"] = 1] = \"Forward\";\r\n  BarcodeDirection[BarcodeDirection[\"Reverse\"] = -1] = \"Reverse\";\r\n})(BarcodeDirection || (BarcodeDirection = {}));\r\n\r\nvar barcode_reader_BarcodeReader = /*#__PURE__*/function () {\r\n  function BarcodeReader(config, supplements) {\r\n    classCallCheck_default()(this, BarcodeReader);\r\n\r\n    defineProperty_default()(this, \"_row\", []);\r\n\r\n    defineProperty_default()(this, \"config\", {});\r\n\r\n    defineProperty_default()(this, \"supplements\", []);\r\n\r\n    defineProperty_default()(this, \"SINGLE_CODE_ERROR\", 0);\r\n\r\n    defineProperty_default()(this, \"FORMAT\", 'unknown');\r\n\r\n    defineProperty_default()(this, \"CONFIG_KEYS\", {});\r\n\r\n    this._row = [];\r\n    this.config = config || {};\r\n\r\n    if (supplements) {\r\n      this.supplements = supplements;\r\n    }\r\n  }\r\n\r\n  createClass_default()(BarcodeReader, [{\r\n    key: \"_nextUnset\",\r\n    value: function _nextUnset(line) {\r\n      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\r\n\r\n      for (var i = start; i < line.length; i++) {\r\n        if (!line[i]) return i;\r\n      }\r\n\r\n      return line.length;\r\n    }\r\n  }, {\r\n    key: \"_matchPattern\",\r\n    value: function _matchPattern(counter, code) {\r\n      var maxSingleError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.SINGLE_CODE_ERROR || 1;\r\n      var error = 0;\r\n      var singleError = 0;\r\n      var sum = 0;\r\n      var modulo = 0;\r\n      var barWidth = 0;\r\n      var count = 0;\r\n      var scaled = 0;\r\n\r\n      for (var i = 0; i < counter.length; i++) {\r\n        sum += counter[i];\r\n        modulo += code[i];\r\n      }\r\n\r\n      if (sum < modulo) {\r\n        return Number.MAX_VALUE;\r\n      }\r\n\r\n      barWidth = sum / modulo; // eslint-disable-next-line no-param-reassign\r\n\r\n      maxSingleError *= barWidth;\r\n\r\n      for (var _i = 0; _i < counter.length; _i++) {\r\n        count = counter[_i];\r\n        scaled = code[_i] * barWidth;\r\n        singleError = Math.abs(count - scaled) / scaled;\r\n\r\n        if (singleError > maxSingleError) {\r\n          return Number.MAX_VALUE;\r\n        }\r\n\r\n        error += singleError;\r\n      }\r\n\r\n      return error / modulo;\r\n    }\r\n  }, {\r\n    key: \"_nextSet\",\r\n    value: function _nextSet(line) {\r\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\r\n\r\n      for (var i = offset; i < line.length; i++) {\r\n        if (line[i]) return i;\r\n      }\r\n\r\n      return line.length;\r\n    }\r\n  }, {\r\n    key: \"_correctBars\",\r\n    value: function _correctBars(counter, correction, indices) {\r\n      var length = indices.length;\r\n      var tmp = 0;\r\n\r\n      while (length--) {\r\n        tmp = counter[indices[length]] * (1 - (1 - correction) / 2);\r\n\r\n        if (tmp > 1) {\r\n          // eslint-disable-next-line no-param-reassign\r\n          counter[indices[length]] = tmp;\r\n        }\r\n      }\r\n    }\r\n  }, {\r\n    key: \"decodePattern\",\r\n    value: function decodePattern(pattern) {\r\n      // console.warn('* decodePattern', pattern);\r\n      this._row = pattern; // console.warn('* decodePattern calling decode', typeof this, this.constructor, this.FORMAT, JSON.stringify(this));\r\n\r\n      var result = this.decode(); // console.warn('* first result=', result);\r\n\r\n      if (result === null) {\r\n        this._row.reverse();\r\n\r\n        result = this.decode(); // console.warn('* reversed result=', result);\r\n\r\n        if (result) {\r\n          result.direction = BarcodeDirection.Reverse;\r\n          result.start = this._row.length - result.start;\r\n          result.end = this._row.length - result.end;\r\n        }\r\n      } else {\r\n        result.direction = BarcodeDirection.Forward;\r\n      }\r\n\r\n      if (result) {\r\n        result.format = this.FORMAT;\r\n      } // console.warn('* returning', result);\r\n\r\n\r\n      return result;\r\n    }\r\n  }, {\r\n    key: \"_matchRange\",\r\n    value: function _matchRange(start, end, value) {\r\n      // eslint-disable-next-line no-param-reassign\r\n      start = start < 0 ? 0 : start;\r\n      var i;\r\n\r\n      for (i = start; i < end; i++) {\r\n        if (this._row[i] !== value) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return true;\r\n    }\r\n  }, {\r\n    key: \"_fillCounters\",\r\n    value: function _fillCounters() {\r\n      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._nextUnset(this._row);\r\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._row.length;\r\n      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\r\n      var counters = [];\r\n      var counterPos = 0;\r\n      counters[counterPos] = 0;\r\n\r\n      for (var i = offset; i < end; i++) {\r\n        // eslint-disable-next-line no-bitwise\r\n        if (this._row[i] ^ (isWhite ? 1 : 0)) {\r\n          counters[counterPos]++;\r\n        } else {\r\n          counterPos++;\r\n          counters[counterPos] = 1; // eslint-disable-next-line no-param-reassign\r\n\r\n          isWhite = !isWhite;\r\n        }\r\n      }\r\n\r\n      return counters;\r\n    }\r\n  }, {\r\n    key: \"_toCounters\",\r\n    value: function _toCounters(start, counters) {\r\n      var numCounters = counters.length;\r\n      var end = this._row.length;\r\n      var isWhite = !this._row[start];\r\n      var counterPos = 0;\r\n      array_helper[\"a\" /* default */].init(counters, 0);\r\n\r\n      for (var i = start; i < end; i++) {\r\n        // eslint-disable-next-line no-bitwise\r\n        if (this._row[i] ^ (isWhite ? 1 : 0)) {\r\n          // eslint-disable-next-line no-param-reassign\r\n          counters[counterPos]++;\r\n        } else {\r\n          counterPos++;\r\n\r\n          if (counterPos === numCounters) {\r\n            break;\r\n          } else {\r\n            // eslint-disable-next-line no-param-reassign\r\n            counters[counterPos] = 1;\r\n            isWhite = !isWhite;\r\n          }\r\n        }\r\n      }\r\n\r\n      return counters;\r\n    } // override/implement this in your custom readers.\r\n\r\n  }, {\r\n    key: \"decodeImage\",\r\n    value: function decodeImage(imageWrapper) {\r\n      // eslint-disable-next-line no-void\r\n      void imageWrapper;\r\n      return null;\r\n    }\r\n  }], [{\r\n    key: \"Exception\",\r\n    get: function get() {\r\n      return {\r\n        StartNotFoundException: 'Start-Info was not found!',\r\n        CodeNotFoundException: 'Code could not be found!',\r\n        PatternNotFoundException: 'Pattern could not be found!'\r\n      };\r\n    }\r\n  }]);\r\n\r\n  return BarcodeReader;\r\n}();\r\n/* harmony default export */ var barcode_reader = (barcode_reader_BarcodeReader);\r\n// CONCATENATED MODULE: ./src/reader/2of5_reader.ts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }\r\n\r\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\n\r\nvar N = 1;\r\nvar W = 3;\r\nvar START_PATTERN = [W, N, W, N, N, N];\r\nvar STOP_PATTERN = [W, N, N, N, W];\r\nvar CODE_PATTERN = [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]];\r\nvar START_PATTERN_LENGTH = START_PATTERN.reduce(function (sum, val) {\r\n  return sum + val;\r\n}, 0);\r\n\r\nvar _2of5_reader_TwoOfFiveReader = /*#__PURE__*/function (_BarcodeReader) {\r\n  inherits_default()(TwoOfFiveReader, _BarcodeReader);\r\n\r\n  var _super = _createSuper(TwoOfFiveReader);\r\n\r\n  function TwoOfFiveReader() {\r\n    var _this;\r\n\r\n    classCallCheck_default()(this, TwoOfFiveReader);\r\n\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n\r\n    _this = _super.call.apply(_super, [this].concat(args));\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"barSpaceRatio\", [1, 1]);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", '2of5');\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"SINGLE_CODE_ERROR\", 0.78);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"AVG_CODE_ERROR\", 0.30);\r\n\r\n    return _this;\r\n  }\r\n\r\n  createClass_default()(TwoOfFiveReader, [{\r\n    key: \"_findPattern\",\r\n    value: function _findPattern(pattern, offset) {\r\n      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\r\n      var counter = [];\r\n      var counterPos = 0;\r\n      var bestMatch = {\r\n        error: Number.MAX_VALUE,\r\n        code: -1,\r\n        start: 0,\r\n        end: 0\r\n      };\r\n      var sum = 0;\r\n      var error = 0;\r\n      var epsilon = this.AVG_CODE_ERROR;\r\n\r\n      if (!offset) {\r\n        offset = this._nextSet(this._row);\r\n      }\r\n\r\n      for (var i = 0; i < pattern.length; i++) {\r\n        counter[i] = 0;\r\n      }\r\n\r\n      for (var _i = offset; _i < this._row.length; _i++) {\r\n        if (this._row[_i] ^ (isWhite ? 1 : 0)) {\r\n          counter[counterPos]++;\r\n        } else {\r\n          if (counterPos === counter.length - 1) {\r\n            sum = 0;\r\n\r\n            for (var j = 0; j < counter.length; j++) {\r\n              sum += counter[j];\r\n            }\r\n\r\n            error = this._matchPattern(counter, pattern);\r\n\r\n            if (error < epsilon) {\r\n              bestMatch.error = error;\r\n              bestMatch.start = _i - sum;\r\n              bestMatch.end = _i;\r\n              return bestMatch;\r\n            }\r\n\r\n            if (tryHarder) {\r\n              for (var _j = 0; _j < counter.length - 2; _j++) {\r\n                counter[_j] = counter[_j + 2];\r\n              }\r\n\r\n              counter[counter.length - 2] = 0;\r\n              counter[counter.length - 1] = 0;\r\n              counterPos--;\r\n            } else {\r\n              return null;\r\n            }\r\n          } else {\r\n            counterPos++;\r\n          }\r\n\r\n          counter[counterPos] = 1;\r\n          isWhite = !isWhite;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"_findStart\",\r\n    value: function _findStart() {\r\n      var startInfo = null;\r\n\r\n      var offset = this._nextSet(this._row);\r\n\r\n      var narrowBarWidth = 1;\r\n      var leadingWhitespaceStart = 0;\r\n\r\n      while (!startInfo) {\r\n        startInfo = this._findPattern(START_PATTERN, offset, false, true);\r\n\r\n        if (!startInfo) {\r\n          return null;\r\n        }\r\n\r\n        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / START_PATTERN_LENGTH);\r\n        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;\r\n\r\n        if (leadingWhitespaceStart >= 0) {\r\n          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {\r\n            return startInfo;\r\n          }\r\n        }\r\n\r\n        offset = startInfo.end;\r\n        startInfo = null;\r\n      }\r\n\r\n      return startInfo;\r\n    }\r\n  }, {\r\n    key: \"_verifyTrailingWhitespace\",\r\n    value: function _verifyTrailingWhitespace(endInfo) {\r\n      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;\r\n\r\n      if (trailingWhitespaceEnd < this._row.length) {\r\n        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {\r\n          return endInfo;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"_findEnd\",\r\n    value: function _findEnd() {\r\n      // TODO: reverse, followed by some calcs, followed by another reverse? really?\r\n      this._row.reverse();\r\n\r\n      var offset = this._nextSet(this._row);\r\n\r\n      var endInfo = this._findPattern(STOP_PATTERN, offset, false, true);\r\n\r\n      this._row.reverse();\r\n\r\n      if (endInfo === null) {\r\n        return null;\r\n      } // reverse numbers\r\n\r\n\r\n      var tmp = endInfo.start;\r\n      endInfo.start = this._row.length - endInfo.end;\r\n      endInfo.end = this._row.length - tmp;\r\n      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;\r\n    }\r\n  }, {\r\n    key: \"_verifyCounterLength\",\r\n    value: function _verifyCounterLength(counters) {\r\n      return counters.length % 10 === 0;\r\n    }\r\n  }, {\r\n    key: \"_decodeCode\",\r\n    value: function _decodeCode(counter) {\r\n      var epsilon = this.AVG_CODE_ERROR;\r\n      var bestMatch = {\r\n        error: Number.MAX_VALUE,\r\n        code: -1,\r\n        start: 0,\r\n        end: 0\r\n      };\r\n\r\n      for (var code = 0; code < CODE_PATTERN.length; code++) {\r\n        var error = this._matchPattern(counter, CODE_PATTERN[code]);\r\n\r\n        if (error < bestMatch.error) {\r\n          bestMatch.code = code;\r\n          bestMatch.error = error;\r\n        }\r\n      }\r\n\r\n      if (bestMatch.error < epsilon) {\r\n        return bestMatch;\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"_decodePayload\",\r\n    value: function _decodePayload(counters, result, decodedCodes) {\r\n      var pos = 0;\r\n      var counterLength = counters.length;\r\n      var counter = [0, 0, 0, 0, 0];\r\n      var code = null;\r\n\r\n      while (pos < counterLength) {\r\n        for (var i = 0; i < 5; i++) {\r\n          counter[i] = counters[pos] * this.barSpaceRatio[0];\r\n          pos += 2;\r\n        }\r\n\r\n        code = this._decodeCode(counter);\r\n\r\n        if (!code) {\r\n          return null;\r\n        }\r\n\r\n        result.push(\"\".concat(code.code));\r\n        decodedCodes.push(code);\r\n      }\r\n\r\n      return code;\r\n    }\r\n  }, {\r\n    key: \"decode\",\r\n    value: function decode(row, start) {\r\n      var startInfo = this._findStart();\r\n\r\n      if (!startInfo) {\r\n        return null;\r\n      }\r\n\r\n      var endInfo = this._findEnd();\r\n\r\n      if (!endInfo) {\r\n        return null;\r\n      }\r\n\r\n      var counters = this._fillCounters(startInfo.end, endInfo.start, false);\r\n\r\n      if (!this._verifyCounterLength(counters)) {\r\n        return null;\r\n      }\r\n\r\n      var decodedCodes = [];\r\n      decodedCodes.push(startInfo);\r\n      var result = [];\r\n\r\n      var code = this._decodePayload(counters, result, decodedCodes);\r\n\r\n      if (!code) {\r\n        return null;\r\n      }\r\n\r\n      if (result.length < 5) {\r\n        return null;\r\n      }\r\n\r\n      decodedCodes.push(endInfo);\r\n      return {\r\n        code: result.join(''),\r\n        start: startInfo.start,\r\n        end: endInfo.end,\r\n        startInfo: startInfo,\r\n        decodedCodes: decodedCodes,\r\n        format: this.FORMAT\r\n      };\r\n    }\r\n  }]);\r\n\r\n  return TwoOfFiveReader;\r\n}(barcode_reader);\r\n\r\n/* harmony default export */ var _2of5_reader = (_2of5_reader_TwoOfFiveReader);\r\n// CONCATENATED MODULE: ./src/reader/codabar_reader.ts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction codabar_reader_createSuper(Derived) { var hasNativeReflectConstruct = codabar_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }\r\n\r\nfunction codabar_reader_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\n // const ALPHABETH_STRING = '0123456789-$:/.+ABCD';\r\n\r\nvar ALPHABET = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 36, 58, 47, 46, 43, 65, 66, 67, 68];\r\nvar CHARACTER_ENCODINGS = [0x003, 0x006, 0x009, 0x060, 0x012, 0x042, 0x021, 0x024, 0x030, 0x048, 0x00c, 0x018, 0x045, 0x051, 0x054, 0x015, 0x01A, 0x029, 0x00B, 0x00E];\r\nvar START_END = [0x01A, 0x029, 0x00B, 0x00E];\r\nvar MIN_ENCODED_CHARS = 4;\r\nvar MAX_ACCEPTABLE = 2.0;\r\nvar PADDING = 1.5;\r\n;\r\n;\r\n\r\nvar codabar_reader_NewCodabarReader = /*#__PURE__*/function (_BarcodeReader) {\r\n  inherits_default()(NewCodabarReader, _BarcodeReader);\r\n\r\n  var _super = codabar_reader_createSuper(NewCodabarReader);\r\n\r\n  function NewCodabarReader() {\r\n    var _this;\r\n\r\n    classCallCheck_default()(this, NewCodabarReader);\r\n\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n\r\n    _this = _super.call.apply(_super, [this].concat(args));\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"_counters\", []);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", 'codabar');\r\n\r\n    return _this;\r\n  }\r\n\r\n  createClass_default()(NewCodabarReader, [{\r\n    key: \"_computeAlternatingThreshold\",\r\n    value: function _computeAlternatingThreshold(offset, end) {\r\n      var min = Number.MAX_VALUE;\r\n      var max = 0;\r\n      var counter = 0;\r\n\r\n      for (var i = offset; i < end; i += 2) {\r\n        counter = this._counters[i];\r\n\r\n        if (counter > max) {\r\n          max = counter;\r\n        }\r\n\r\n        if (counter < min) {\r\n          min = counter;\r\n        }\r\n      }\r\n\r\n      return (min + max) / 2.0 | 0;\r\n    }\r\n  }, {\r\n    key: \"_toPattern\",\r\n    value: function _toPattern(offset) {\r\n      var numCounters = 7;\r\n      var end = offset + numCounters;\r\n\r\n      if (end > this._counters.length) {\r\n        return -1;\r\n      }\r\n\r\n      var barThreshold = this._computeAlternatingThreshold(offset, end);\r\n\r\n      var spaceThreshold = this._computeAlternatingThreshold(offset + 1, end);\r\n\r\n      var bitmask = 1 << numCounters - 1;\r\n      var threshold = 0;\r\n      var pattern = 0;\r\n\r\n      for (var i = 0; i < numCounters; i++) {\r\n        threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;\r\n\r\n        if (this._counters[offset + i] > threshold) {\r\n          pattern |= bitmask;\r\n        }\r\n\r\n        bitmask >>= 1;\r\n      }\r\n\r\n      return pattern;\r\n    }\r\n  }, {\r\n    key: \"_isStartEnd\",\r\n    value: function _isStartEnd(pattern) {\r\n      for (var i = 0; i < START_END.length; i++) {\r\n        if (START_END[i] === pattern) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    }\r\n  }, {\r\n    key: \"_sumCounters\",\r\n    value: function _sumCounters(start, end) {\r\n      var sum = 0;\r\n\r\n      for (var i = start; i < end; i++) {\r\n        sum += this._counters[i];\r\n      }\r\n\r\n      return sum;\r\n    }\r\n  }, {\r\n    key: \"_findStart\",\r\n    value: function _findStart() {\r\n      var start = this._nextUnset(this._row);\r\n\r\n      var end = start;\r\n\r\n      for (var i = 1; i < this._counters.length; i++) {\r\n        var pattern = this._toPattern(i);\r\n\r\n        if (pattern !== -1 && this._isStartEnd(pattern)) {\r\n          // TODO: Look for whitespace ahead\r\n          start += this._sumCounters(0, i);\r\n          end = start + this._sumCounters(i, i + 8);\r\n          return {\r\n            start: start,\r\n            end: end,\r\n            startCounter: i,\r\n            endCounter: i + 8\r\n          };\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"_patternToChar\",\r\n    value: function _patternToChar(pattern) {\r\n      for (var i = 0; i < CHARACTER_ENCODINGS.length; i++) {\r\n        if (CHARACTER_ENCODINGS[i] === pattern) {\r\n          return String.fromCharCode(ALPHABET[i]);\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"_calculatePatternLength\",\r\n    value: function _calculatePatternLength(offset) {\r\n      var sum = 0;\r\n\r\n      for (var i = offset; i < offset + 7; i++) {\r\n        sum += this._counters[i];\r\n      }\r\n\r\n      return sum;\r\n    }\r\n  }, {\r\n    key: \"_verifyWhitespace\",\r\n    value: function _verifyWhitespace(startCounter, endCounter) {\r\n      if (startCounter - 1 <= 0 || this._counters[startCounter - 1] >= this._calculatePatternLength(startCounter) / 2.0) {\r\n        if (endCounter + 8 >= this._counters.length || this._counters[endCounter + 7] >= this._calculatePatternLength(endCounter) / 2.0) {\r\n          return true;\r\n        }\r\n      }\r\n\r\n      return false;\r\n    }\r\n  }, {\r\n    key: \"_charToPattern\",\r\n    value: function _charToPattern(_char) {\r\n      var charCode = _char.charCodeAt(0);\r\n\r\n      for (var i = 0; i < ALPHABET.length; i++) {\r\n        if (ALPHABET[i] === charCode) {\r\n          return CHARACTER_ENCODINGS[i];\r\n        }\r\n      }\r\n\r\n      return 0x0;\r\n    }\r\n  }, {\r\n    key: \"_thresholdResultPattern\",\r\n    value: function _thresholdResultPattern(result, startCounter) {\r\n      var categorization = {\r\n        space: {\r\n          narrow: {\r\n            size: 0,\r\n            counts: 0,\r\n            min: 0,\r\n            max: Number.MAX_VALUE\r\n          },\r\n          wide: {\r\n            size: 0,\r\n            counts: 0,\r\n            min: 0,\r\n            max: Number.MAX_VALUE\r\n          }\r\n        },\r\n        bar: {\r\n          narrow: {\r\n            size: 0,\r\n            counts: 0,\r\n            min: 0,\r\n            max: Number.MAX_VALUE\r\n          },\r\n          wide: {\r\n            size: 0,\r\n            counts: 0,\r\n            min: 0,\r\n            max: Number.MAX_VALUE\r\n          }\r\n        }\r\n      };\r\n      var pos = startCounter;\r\n      var pattern;\r\n\r\n      for (var i = 0; i < result.length; i++) {\r\n        pattern = this._charToPattern(result[i]);\r\n\r\n        for (var j = 6; j >= 0; j--) {\r\n          var kind = (j & 1) === 2 ? categorization.bar : categorization.space;\r\n          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;\r\n          cat.size += this._counters[pos + j];\r\n          cat.counts++;\r\n          pattern >>= 1;\r\n        }\r\n\r\n        pos += 8;\r\n      }\r\n\r\n      ['space', 'bar'].forEach(function (key) {\r\n        var newkind = categorization[key];\r\n        newkind.wide.min = Math.floor((newkind.narrow.size / newkind.narrow.counts + newkind.wide.size / newkind.wide.counts) / 2);\r\n        newkind.narrow.max = Math.ceil(newkind.wide.min);\r\n        newkind.wide.max = Math.ceil((newkind.wide.size * MAX_ACCEPTABLE + PADDING) / newkind.wide.counts);\r\n      });\r\n      return categorization;\r\n    }\r\n  }, {\r\n    key: \"_validateResult\",\r\n    value: function _validateResult(result, startCounter) {\r\n      var thresholds = this._thresholdResultPattern(result, startCounter);\r\n\r\n      var pos = startCounter;\r\n      var pattern;\r\n\r\n      for (var i = 0; i < result.length; i++) {\r\n        pattern = this._charToPattern(result[i]);\r\n\r\n        for (var j = 6; j >= 0; j--) {\r\n          var kind = (j & 1) === 0 ? thresholds.bar : thresholds.space;\r\n          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;\r\n          var size = this._counters[pos + j];\r\n\r\n          if (size < cat.min || size > cat.max) {\r\n            return false;\r\n          }\r\n\r\n          pattern >>= 1;\r\n        }\r\n\r\n        pos += 8;\r\n      }\r\n\r\n      return true;\r\n    }\r\n  }, {\r\n    key: \"decode\",\r\n    value: function decode(row, start) {\r\n      this._counters = this._fillCounters();\r\n      start = this._findStart();\r\n\r\n      if (!start) {\r\n        return null;\r\n      }\r\n\r\n      var nextStart = start.startCounter;\r\n      var result = [];\r\n      var pattern;\r\n\r\n      do {\r\n        pattern = this._toPattern(nextStart);\r\n\r\n        if (pattern < 0) {\r\n          return null;\r\n        }\r\n\r\n        var decodedChar = this._patternToChar(pattern);\r\n\r\n        if (decodedChar === null) {\r\n          return null;\r\n        }\r\n\r\n        result.push(decodedChar);\r\n        nextStart += 8;\r\n\r\n        if (result.length > 1 && this._isStartEnd(pattern)) {\r\n          break;\r\n        }\r\n      } while (nextStart < this._counters.length); // verify end\r\n\r\n\r\n      if (result.length - 2 < MIN_ENCODED_CHARS || !this._isStartEnd(pattern)) {\r\n        return null;\r\n      } // verify end white space\r\n\r\n\r\n      if (!this._verifyWhitespace(start.startCounter, nextStart - 8)) {\r\n        return null;\r\n      }\r\n\r\n      if (!this._validateResult(result, start.startCounter)) {\r\n        return null;\r\n      }\r\n\r\n      nextStart = nextStart > this._counters.length ? this._counters.length : nextStart;\r\n\r\n      var end = start.start + this._sumCounters(start.startCounter, nextStart - 8);\r\n\r\n      return {\r\n        code: result.join(''),\r\n        start: start.start,\r\n        end: end,\r\n        startInfo: start,\r\n        decodedCodes: result,\r\n        format: this.FORMAT // TODO: i think it should not be required to return format from this, as barcode_reader force sets the format anyway\r\n\r\n      };\r\n    }\r\n  }]);\r\n\r\n  return NewCodabarReader;\r\n}(barcode_reader);\r\n\r\n/* harmony default export */ var codabar_reader = (codabar_reader_NewCodabarReader);\r\n// CONCATENATED MODULE: ./src/reader/code_128_reader.ts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction code_128_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_128_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }\r\n\r\nfunction code_128_reader_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\n\r\n\r\nvar code_128_reader_Code128Reader = /*#__PURE__*/function (_BarcodeReader) {\r\n  inherits_default()(Code128Reader, _BarcodeReader);\r\n\r\n  var _super = code_128_reader_createSuper(Code128Reader);\r\n\r\n  function Code128Reader() {\r\n    var _this;\r\n\r\n    classCallCheck_default()(this, Code128Reader);\r\n\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n\r\n    _this = _super.call.apply(_super, [this].concat(args));\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"CODE_SHIFT\", 98);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"CODE_C\", 99);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"CODE_B\", 100);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"CODE_A\", 101);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"START_CODE_A\", 103);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"START_CODE_B\", 104);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"START_CODE_C\", 105);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"STOP_CODE\", 106);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"CODE_PATTERN\", [[2, 1, 2, 2, 2, 2], [2, 2, 2, 1, 2, 2], [2, 2, 2, 2, 2, 1], [1, 2, 1, 2, 2, 3], [1, 2, 1, 3, 2, 2], [1, 3, 1, 2, 2, 2], [1, 2, 2, 2, 1, 3], [1, 2, 2, 3, 1, 2], [1, 3, 2, 2, 1, 2], [2, 2, 1, 2, 1, 3], [2, 2, 1, 3, 1, 2], [2, 3, 1, 2, 1, 2], [1, 1, 2, 2, 3, 2], [1, 2, 2, 1, 3, 2], [1, 2, 2, 2, 3, 1], [1, 1, 3, 2, 2, 2], [1, 2, 3, 1, 2, 2], [1, 2, 3, 2, 2, 1], [2, 2, 3, 2, 1, 1], [2, 2, 1, 1, 3, 2], [2, 2, 1, 2, 3, 1], [2, 1, 3, 2, 1, 2], [2, 2, 3, 1, 1, 2], [3, 1, 2, 1, 3, 1], [3, 1, 1, 2, 2, 2], [3, 2, 1, 1, 2, 2], [3, 2, 1, 2, 2, 1], [3, 1, 2, 2, 1, 2], [3, 2, 2, 1, 1, 2], [3, 2, 2, 2, 1, 1], [2, 1, 2, 1, 2, 3], [2, 1, 2, 3, 2, 1], [2, 3, 2, 1, 2, 1], [1, 1, 1, 3, 2, 3], [1, 3, 1, 1, 2, 3], [1, 3, 1, 3, 2, 1], [1, 1, 2, 3, 1, 3], [1, 3, 2, 1, 1, 3], [1, 3, 2, 3, 1, 1], [2, 1, 1, 3, 1, 3], [2, 3, 1, 1, 1, 3], [2, 3, 1, 3, 1, 1], [1, 1, 2, 1, 3, 3], [1, 1, 2, 3, 3, 1], [1, 3, 2, 1, 3, 1], [1, 1, 3, 1, 2, 3], [1, 1, 3, 3, 2, 1], [1, 3, 3, 1, 2, 1], [3, 1, 3, 1, 2, 1], [2, 1, 1, 3, 3, 1], [2, 3, 1, 1, 3, 1], [2, 1, 3, 1, 1, 3], [2, 1, 3, 3, 1, 1], [2, 1, 3, 1, 3, 1], [3, 1, 1, 1, 2, 3], [3, 1, 1, 3, 2, 1], [3, 3, 1, 1, 2, 1], [3, 1, 2, 1, 1, 3], [3, 1, 2, 3, 1, 1], [3, 3, 2, 1, 1, 1], [3, 1, 4, 1, 1, 1], [2, 2, 1, 4, 1, 1], [4, 3, 1, 1, 1, 1], [1, 1, 1, 2, 2, 4], [1, 1, 1, 4, 2, 2], [1, 2, 1, 1, 2, 4], [1, 2, 1, 4, 2, 1], [1, 4, 1, 1, 2, 2], [1, 4, 1, 2, 2, 1], [1, 1, 2, 2, 1, 4], [1, 1, 2, 4, 1, 2], [1, 2, 2, 1, 1, 4], [1, 2, 2, 4, 1, 1], [1, 4, 2, 1, 1, 2], [1, 4, 2, 2, 1, 1], [2, 4, 1, 2, 1, 1], [2, 2, 1, 1, 1, 4], [4, 1, 3, 1, 1, 1], [2, 4, 1, 1, 1, 2], [1, 3, 4, 1, 1, 1], [1, 1, 1, 2, 4, 2], [1, 2, 1, 1, 4, 2], [1, 2, 1, 2, 4, 1], [1, 1, 4, 2, 1, 2], [1, 2, 4, 1, 1, 2], [1, 2, 4, 2, 1, 1], [4, 1, 1, 2, 1, 2], [4, 2, 1, 1, 1, 2], [4, 2, 1, 2, 1, 1], [2, 1, 2, 1, 4, 1], [2, 1, 4, 1, 2, 1], [4, 1, 2, 1, 2, 1], [1, 1, 1, 1, 4, 3], [1, 1, 1, 3, 4, 1], [1, 3, 1, 1, 4, 1], [1, 1, 4, 1, 1, 3], [1, 1, 4, 3, 1, 1], [4, 1, 1, 1, 1, 3], [4, 1, 1, 3, 1, 1], [1, 1, 3, 1, 4, 1], [1, 1, 4, 1, 3, 1], [3, 1, 1, 1, 4, 1], [4, 1, 1, 1, 3, 1], [2, 1, 1, 4, 1, 2], [2, 1, 1, 2, 1, 4], [2, 1, 1, 2, 3, 2], [2, 3, 3, 1, 1, 1, 2]]);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"SINGLE_CODE_ERROR\", 0.64);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"AVG_CODE_ERROR\", 0.30);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", 'code_128');\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"MODULE_INDICES\", {\r\n      bar: [0, 2, 4],\r\n      space: [1, 3, 5]\r\n    });\r\n\r\n    return _this;\r\n  }\r\n\r\n  createClass_default()(Code128Reader, [{\r\n    key: \"_decodeCode\",\r\n    value: function _decodeCode(start, correction) {\r\n      var bestMatch = {\r\n        error: Number.MAX_VALUE,\r\n        code: -1,\r\n        start: start,\r\n        end: start,\r\n        correction: {\r\n          bar: 1,\r\n          space: 1\r\n        }\r\n      };\r\n      var counter = [0, 0, 0, 0, 0, 0];\r\n      var offset = start;\r\n      var isWhite = !this._row[offset];\r\n      var counterPos = 0;\r\n\r\n      for (var i = offset; i < this._row.length; i++) {\r\n        if (this._row[i] ^ (isWhite ? 1 : 0)) {\r\n          counter[counterPos]++;\r\n        } else {\r\n          if (counterPos === counter.length - 1) {\r\n            if (correction) {\r\n              this._correct(counter, correction);\r\n            }\r\n\r\n            for (var code = 0; code < this.CODE_PATTERN.length; code++) {\r\n              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);\r\n\r\n              if (error < bestMatch.error) {\r\n                bestMatch.code = code;\r\n                bestMatch.error = error;\r\n              }\r\n            }\r\n\r\n            bestMatch.end = i;\r\n\r\n            if (bestMatch.code === -1 || bestMatch.error > this.AVG_CODE_ERROR) {\r\n              return null;\r\n            }\r\n\r\n            if (this.CODE_PATTERN[bestMatch.code]) {\r\n              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);\r\n              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);\r\n            }\r\n\r\n            return bestMatch;\r\n          } else {\r\n            counterPos++;\r\n          }\r\n\r\n          counter[counterPos] = 1;\r\n          isWhite = !isWhite;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"_correct\",\r\n    value: function _correct(counter, correction) {\r\n      this._correctBars(counter, correction.bar, this.MODULE_INDICES.bar);\r\n\r\n      this._correctBars(counter, correction.space, this.MODULE_INDICES.space);\r\n    }\r\n  }, {\r\n    key: \"_findStart\",\r\n    value: // TODO: _findStart and decodeCode share similar code, can we re-use some?\r\n    function _findStart() {\r\n      var counter = [0, 0, 0, 0, 0, 0];\r\n\r\n      var offset = this._nextSet(this._row);\r\n\r\n      var bestMatch = {\r\n        error: Number.MAX_VALUE,\r\n        code: -1,\r\n        start: 0,\r\n        end: 0,\r\n        correction: {\r\n          bar: 1,\r\n          space: 1\r\n        }\r\n      };\r\n      var isWhite = false;\r\n      var counterPos = 0;\r\n\r\n      for (var i = offset; i < this._row.length; i++) {\r\n        if (this._row[i] ^ (isWhite ? 1 : 0)) {\r\n          counter[counterPos]++;\r\n        } else {\r\n          if (counterPos === counter.length - 1) {\r\n            var sum = counter.reduce(function (prev, next) {\r\n              return prev + next;\r\n            }, 0);\r\n\r\n            for (var code = this.START_CODE_A; code <= this.START_CODE_C; code++) {\r\n              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);\r\n\r\n              if (error < bestMatch.error) {\r\n                bestMatch.code = code;\r\n                bestMatch.error = error;\r\n              }\r\n            }\r\n\r\n            if (bestMatch.error < this.AVG_CODE_ERROR) {\r\n              bestMatch.start = i - sum;\r\n              bestMatch.end = i;\r\n              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);\r\n              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);\r\n              return bestMatch;\r\n            }\r\n\r\n            for (var j = 0; j < 4; j++) {\r\n              counter[j] = counter[j + 2];\r\n            }\r\n\r\n            counter[4] = 0;\r\n            counter[5] = 0;\r\n            counterPos--;\r\n          } else {\r\n            counterPos++;\r\n          }\r\n\r\n          counter[counterPos] = 1;\r\n          isWhite = !isWhite;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"decode\",\r\n    value: function decode(row, start) {\r\n      var _this2 = this;\r\n\r\n      var startInfo = this._findStart();\r\n\r\n      if (startInfo === null) {\r\n        return null;\r\n      } // var self = this,\r\n      //     done = false,\r\n      //     result = [],\r\n      //     multiplier = 0,\r\n      //     checksum = 0,\r\n      //     codeset,\r\n      //     rawResult = [],\r\n      //     decodedCodes = [],\r\n      //     shiftNext = false,\r\n      //     unshift,\r\n      //     removeLastCharacter = true;\r\n\r\n\r\n      var code = {\r\n        code: startInfo.code,\r\n        start: startInfo.start,\r\n        end: startInfo.end,\r\n        correction: {\r\n          bar: startInfo.correction.bar,\r\n          space: startInfo.correction.space\r\n        }\r\n      };\r\n      var decodedCodes = [];\r\n      decodedCodes.push(code);\r\n      var checksum = code.code;\r\n\r\n      var codeset = function (c) {\r\n        switch (c) {\r\n          case _this2.START_CODE_A:\r\n            return _this2.CODE_A;\r\n\r\n          case _this2.START_CODE_B:\r\n            return _this2.CODE_B;\r\n\r\n          case _this2.START_CODE_C:\r\n            return _this2.CODE_C;\r\n\r\n          default:\r\n            return null;\r\n        }\r\n      }(code.code);\r\n\r\n      var done = false;\r\n      var shiftNext = false;\r\n      var unshift = shiftNext;\r\n      var removeLastCharacter = true;\r\n      var multiplier = 0;\r\n      var rawResult = [];\r\n      var result = []; // TODO: i think this should be string only, but it creates problems if it is\r\n\r\n      while (!done) {\r\n        unshift = shiftNext;\r\n        shiftNext = false;\r\n        code = this._decodeCode(code.end, code.correction);\r\n\r\n        if (code !== null) {\r\n          if (code.code !== this.STOP_CODE) {\r\n            removeLastCharacter = true;\r\n          }\r\n\r\n          if (code.code !== this.STOP_CODE) {\r\n            rawResult.push(code.code);\r\n            multiplier++;\r\n            checksum += multiplier * code.code;\r\n          }\r\n\r\n          decodedCodes.push(code);\r\n\r\n          switch (codeset) {\r\n            case this.CODE_A:\r\n              if (code.code < 64) {\r\n                result.push(String.fromCharCode(32 + code.code));\r\n              } else if (code.code < 96) {\r\n                result.push(String.fromCharCode(code.code - 64));\r\n              } else {\r\n                if (code.code !== this.STOP_CODE) {\r\n                  removeLastCharacter = false;\r\n                }\r\n\r\n                switch (code.code) {\r\n                  case this.CODE_SHIFT:\r\n                    shiftNext = true;\r\n                    codeset = this.CODE_B;\r\n                    break;\r\n\r\n                  case this.CODE_B:\r\n                    codeset = this.CODE_B;\r\n                    break;\r\n\r\n                  case this.CODE_C:\r\n                    codeset = this.CODE_C;\r\n                    break;\r\n\r\n                  case this.STOP_CODE:\r\n                    done = true;\r\n                    break;\r\n                }\r\n              }\r\n\r\n              break;\r\n\r\n            case this.CODE_B:\r\n              if (code.code < 96) {\r\n                result.push(String.fromCharCode(32 + code.code));\r\n              } else {\r\n                if (code.code !== this.STOP_CODE) {\r\n                  removeLastCharacter = false;\r\n                }\r\n\r\n                switch (code.code) {\r\n                  case this.CODE_SHIFT:\r\n                    shiftNext = true;\r\n                    codeset = this.CODE_A;\r\n                    break;\r\n\r\n                  case this.CODE_A:\r\n                    codeset = this.CODE_A;\r\n                    break;\r\n\r\n                  case this.CODE_C:\r\n                    codeset = this.CODE_C;\r\n                    break;\r\n\r\n                  case this.STOP_CODE:\r\n                    done = true;\r\n                    break;\r\n                }\r\n              }\r\n\r\n              break;\r\n\r\n            case this.CODE_C:\r\n              if (code.code < 100) {\r\n                result.push(code.code < 10 ? '0' + code.code : code.code);\r\n              } else {\r\n                if (code.code !== this.STOP_CODE) {\r\n                  removeLastCharacter = false;\r\n                }\r\n\r\n                switch (code.code) {\r\n                  case this.CODE_A:\r\n                    codeset = this.CODE_A;\r\n                    break;\r\n\r\n                  case this.CODE_B:\r\n                    codeset = this.CODE_B;\r\n                    break;\r\n\r\n                  case this.STOP_CODE:\r\n                    done = true;\r\n                    break;\r\n                }\r\n              }\r\n\r\n              break;\r\n          }\r\n        } else {\r\n          done = true;\r\n        }\r\n\r\n        if (unshift) {\r\n          codeset = codeset === this.CODE_A ? this.CODE_B : this.CODE_A;\r\n        }\r\n      }\r\n\r\n      if (code === null) {\r\n        return null;\r\n      }\r\n\r\n      code.end = this._nextUnset(this._row, code.end);\r\n\r\n      if (!this._verifyTrailingWhitespace(code)) {\r\n        return null;\r\n      }\r\n\r\n      checksum -= multiplier * rawResult[rawResult.length - 1];\r\n\r\n      if (checksum % 103 !== rawResult[rawResult.length - 1]) {\r\n        return null;\r\n      }\r\n\r\n      if (!result.length) {\r\n        return null;\r\n      } // remove last code from result (checksum)\r\n\r\n\r\n      if (removeLastCharacter) {\r\n        result.splice(result.length - 1, 1);\r\n      }\r\n\r\n      return {\r\n        code: result.join(''),\r\n        start: startInfo.start,\r\n        end: code.end,\r\n        codeset: codeset,\r\n        startInfo: startInfo,\r\n        decodedCodes: decodedCodes,\r\n        endInfo: code,\r\n        format: this.FORMAT\r\n      };\r\n    }\r\n  }, {\r\n    key: \"_verifyTrailingWhitespace\",\r\n    value: function _verifyTrailingWhitespace(endInfo) {\r\n      var self = this,\r\n          trailingWhitespaceEnd;\r\n      trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;\r\n\r\n      if (trailingWhitespaceEnd < self._row.length) {\r\n        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {\r\n          return endInfo;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"calculateCorrection\",\r\n    value: function calculateCorrection(expected, normalized, indices) {\r\n      var length = indices.length,\r\n          sumNormalized = 0,\r\n          sumExpected = 0;\r\n\r\n      while (length--) {\r\n        sumExpected += expected[indices[length]];\r\n        sumNormalized += normalized[indices[length]];\r\n      }\r\n\r\n      return sumExpected / sumNormalized;\r\n    }\r\n  }]);\r\n\r\n  return Code128Reader;\r\n}(barcode_reader);\r\n\r\n/* harmony default export */ var code_128_reader = (code_128_reader_Code128Reader);\r\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/get.js\r\nvar get = __nested_webpack_require_266069__(14);\r\nvar get_default = /*#__PURE__*/__nested_webpack_require_266069__.n(get);\r\n\r\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js\r\nvar toConsumableArray = __nested_webpack_require_266069__(33);\r\nvar toConsumableArray_default = /*#__PURE__*/__nested_webpack_require_266069__.n(toConsumableArray);\r\n\r\n// CONCATENATED MODULE: ./src/reader/code_39_reader.ts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction code_39_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }\r\n\r\nfunction code_39_reader_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\n/* eslint-disable class-methods-use-this */\r\n\r\n\r\nvar ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%';\r\nvar code_39_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(ALPHABETH_STRING).map(function (_char) {\r\n  return _char.charCodeAt(0);\r\n}));\r\nvar code_39_reader_CHARACTER_ENCODINGS = new Uint16Array([0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064, 0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C, 0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016, 0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x094, 0x0A8, 0x0A2, 0x08A, 0x02A]);\r\nvar ASTERISK = 0x094;\r\n\r\nvar code_39_reader_Code39Reader = /*#__PURE__*/function (_BarcodeReader) {\r\n  inherits_default()(Code39Reader, _BarcodeReader);\r\n\r\n  var _super = code_39_reader_createSuper(Code39Reader);\r\n\r\n  function Code39Reader() {\r\n    var _this;\r\n\r\n    classCallCheck_default()(this, Code39Reader);\r\n\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n\r\n    _this = _super.call.apply(_super, [this].concat(args));\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", 'code_39');\r\n\r\n    return _this;\r\n  }\r\n\r\n  createClass_default()(Code39Reader, [{\r\n    key: \"_findStart\",\r\n    value: function _findStart() {\r\n      var offset = this._nextSet(this._row);\r\n\r\n      var patternStart = offset;\r\n      var counter = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);\r\n      var counterPos = 0;\r\n      var isWhite = false;\r\n\r\n      for (var i = offset; i < this._row.length; i++) {\r\n        // eslint-disable-next-line no-bitwise\r\n        if (this._row[i] ^ (isWhite ? 1 : 0)) {\r\n          counter[counterPos]++;\r\n        } else {\r\n          if (counterPos === counter.length - 1) {\r\n            // find start pattern\r\n            if (this._toPattern(counter) === ASTERISK) {\r\n              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));\r\n\r\n              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {\r\n                return {\r\n                  start: patternStart,\r\n                  end: i\r\n                };\r\n              }\r\n            }\r\n\r\n            patternStart += counter[0] + counter[1];\r\n\r\n            for (var j = 0; j < 7; j++) {\r\n              counter[j] = counter[j + 2];\r\n            }\r\n\r\n            counter[7] = 0;\r\n            counter[8] = 0;\r\n            counterPos--;\r\n          } else {\r\n            counterPos++;\r\n          }\r\n\r\n          counter[counterPos] = 1;\r\n          isWhite = !isWhite;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"_toPattern\",\r\n    value: function _toPattern(counters) {\r\n      var numCounters = counters.length;\r\n      var maxNarrowWidth = 0;\r\n      var numWideBars = numCounters;\r\n      var wideBarWidth = 0;\r\n\r\n      while (numWideBars > 3) {\r\n        maxNarrowWidth = this._findNextWidth(counters, maxNarrowWidth);\r\n        numWideBars = 0;\r\n        var pattern = 0;\r\n\r\n        for (var i = 0; i < numCounters; i++) {\r\n          if (counters[i] > maxNarrowWidth) {\r\n            // eslint-disable-next-line no-bitwise\r\n            pattern |= 1 << numCounters - 1 - i;\r\n            numWideBars++;\r\n            wideBarWidth += counters[i];\r\n          }\r\n        }\r\n\r\n        if (numWideBars === 3) {\r\n          for (var _i = 0; _i < numCounters && numWideBars > 0; _i++) {\r\n            if (counters[_i] > maxNarrowWidth) {\r\n              numWideBars--;\r\n\r\n              if (counters[_i] * 2 >= wideBarWidth) {\r\n                return -1;\r\n              }\r\n            }\r\n          }\r\n\r\n          return pattern;\r\n        }\r\n      }\r\n\r\n      return -1;\r\n    }\r\n  }, {\r\n    key: \"_findNextWidth\",\r\n    value: function _findNextWidth(counters, current) {\r\n      var minWidth = Number.MAX_VALUE;\r\n\r\n      for (var i = 0; i < counters.length; i++) {\r\n        if (counters[i] < minWidth && counters[i] > current) {\r\n          minWidth = counters[i];\r\n        }\r\n      }\r\n\r\n      return minWidth;\r\n    }\r\n  }, {\r\n    key: \"_patternToChar\",\r\n    value: function _patternToChar(pattern) {\r\n      for (var i = 0; i < code_39_reader_CHARACTER_ENCODINGS.length; i++) {\r\n        if (code_39_reader_CHARACTER_ENCODINGS[i] === pattern) {\r\n          return String.fromCharCode(code_39_reader_ALPHABET[i]);\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"_verifyTrailingWhitespace\",\r\n    value: function _verifyTrailingWhitespace(lastStart, nextStart, counters) {\r\n      var patternSize = array_helper[\"a\" /* default */].sum(counters);\r\n      var trailingWhitespaceEnd = nextStart - lastStart - patternSize;\r\n\r\n      if (trailingWhitespaceEnd * 3 >= patternSize) {\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    }\r\n  }, {\r\n    key: \"decode\",\r\n    value: function decode() {\r\n      var counters = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);\r\n      var result = [];\r\n\r\n      var start = this._findStart();\r\n\r\n      if (!start) {\r\n        return null;\r\n      }\r\n\r\n      var nextStart = this._nextSet(this._row, start.end);\r\n\r\n      var decodedChar;\r\n      var lastStart;\r\n\r\n      do {\r\n        counters = this._toCounters(nextStart, counters);\r\n\r\n        var pattern = this._toPattern(counters);\r\n\r\n        if (pattern < 0) {\r\n          return null;\r\n        }\r\n\r\n        decodedChar = this._patternToChar(pattern);\r\n\r\n        if (decodedChar === null) {\r\n          return null;\r\n        }\r\n\r\n        result.push(decodedChar);\r\n        lastStart = nextStart;\r\n        nextStart += array_helper[\"a\" /* default */].sum(counters);\r\n        nextStart = this._nextSet(this._row, nextStart);\r\n      } while (decodedChar !== '*');\r\n\r\n      result.pop();\r\n\r\n      if (!result.length) {\r\n        return null;\r\n      }\r\n\r\n      if (!this._verifyTrailingWhitespace(lastStart, nextStart, counters)) {\r\n        return null;\r\n      }\r\n\r\n      return {\r\n        code: result.join(''),\r\n        start: start.start,\r\n        end: nextStart,\r\n        startInfo: start,\r\n        decodedCodes: result,\r\n        format: this.FORMAT\r\n      };\r\n    }\r\n  }]);\r\n\r\n  return Code39Reader;\r\n}(barcode_reader);\r\n\r\n/* harmony default export */ var code_39_reader = (code_39_reader_Code39Reader);\r\n// CONCATENATED MODULE: ./src/reader/code_32_reader.ts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction code_32_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_32_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }\r\n\r\nfunction code_32_reader_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\n\r\nvar patterns = {\r\n  AEIO: /[AEIO]/g,\r\n  AZ09: /[A-Z0-9]/\r\n};\r\nvar code32set = '0123456789BCDFGHJKLMNPQRSTUVWXYZ';\r\n\r\nvar code_32_reader_Code32Reader = /*#__PURE__*/function (_Code39Reader) {\r\n  inherits_default()(Code32Reader, _Code39Reader);\r\n\r\n  var _super = code_32_reader_createSuper(Code32Reader);\r\n\r\n  function Code32Reader() {\r\n    var _this;\r\n\r\n    classCallCheck_default()(this, Code32Reader);\r\n\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n\r\n    _this = _super.call.apply(_super, [this].concat(args));\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", 'code_32_reader');\r\n\r\n    return _this;\r\n  }\r\n\r\n  createClass_default()(Code32Reader, [{\r\n    key: \"_decodeCode32\",\r\n    value: function _decodeCode32(code) {\r\n      if (/[^0-9BCDFGHJKLMNPQRSTUVWXYZ]/.test(code)) {\r\n        return null;\r\n      }\r\n\r\n      var res = 0;\r\n\r\n      for (var i = 0; i < code.length; i++) {\r\n        res = res * 32 + code32set.indexOf(code[i]);\r\n      }\r\n\r\n      var code32 = \"\".concat(res);\r\n\r\n      if (code32.length < 9) {\r\n        code32 = ('000000000' + code32).slice(-9);\r\n      }\r\n\r\n      return 'A' + code32;\r\n    } // TODO (this was todo in original repo, no text was there. sorry.)\r\n\r\n  }, {\r\n    key: \"_checkChecksum\",\r\n    value: function _checkChecksum(code) {\r\n      return !!code;\r\n    }\r\n  }, {\r\n    key: \"decode\",\r\n    value: function decode() {\r\n      var result = get_default()(getPrototypeOf_default()(Code32Reader.prototype), \"decode\", this).call(this);\r\n\r\n      if (!result) {\r\n        return null;\r\n      }\r\n\r\n      var code = result.code;\r\n\r\n      if (!code) {\r\n        return null;\r\n      }\r\n\r\n      code = code.replace(patterns.AEIO, '');\r\n\r\n      if (!this._checkChecksum(code)) {\r\n        return null;\r\n      }\r\n\r\n      var code32 = this._decodeCode32(code);\r\n\r\n      if (!code32) {\r\n        return null;\r\n      }\r\n\r\n      result.code = code32;\r\n      return result;\r\n    }\r\n  }]);\r\n\r\n  return Code32Reader;\r\n}(code_39_reader);\r\n\r\n/* harmony default export */ var code_32_reader = (code_32_reader_Code32Reader);\r\n// CONCATENATED MODULE: ./src/reader/code_39_vin_reader.ts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction code_39_vin_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_vin_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }\r\n\r\nfunction code_39_vin_reader_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\n/* eslint-disable class-methods-use-this */\r\n\r\nvar code_39_vin_reader_patterns = {\r\n  IOQ: /[IOQ]/g,\r\n  AZ09: /[A-Z0-9]{17}/\r\n};\r\n\r\nvar code_39_vin_reader_Code39VINReader = /*#__PURE__*/function (_Code39Reader) {\r\n  inherits_default()(Code39VINReader, _Code39Reader);\r\n\r\n  var _super = code_39_vin_reader_createSuper(Code39VINReader);\r\n\r\n  function Code39VINReader() {\r\n    var _this;\r\n\r\n    classCallCheck_default()(this, Code39VINReader);\r\n\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n\r\n    _this = _super.call.apply(_super, [this].concat(args));\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", 'code_39_vin');\r\n\r\n    return _this;\r\n  }\r\n\r\n  createClass_default()(Code39VINReader, [{\r\n    key: \"_checkChecksum\",\r\n    value: // TODO (this was todo in original repo, no text was there. sorry.)\r\n    function _checkChecksum(code) {\r\n      return !!code;\r\n    } // Cribbed from:\r\n    // https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/client/result/VINResultParser.java\r\n\r\n  }, {\r\n    key: \"decode\",\r\n    value: function decode() {\r\n      var result = get_default()(getPrototypeOf_default()(Code39VINReader.prototype), \"decode\", this).call(this);\r\n\r\n      if (!result) {\r\n        return null;\r\n      }\r\n\r\n      var code = result.code;\r\n\r\n      if (!code) {\r\n        return null;\r\n      }\r\n\r\n      code = code.replace(code_39_vin_reader_patterns.IOQ, '');\r\n\r\n      if (!code.match(code_39_vin_reader_patterns.AZ09)) {\r\n        if (true) {\r\n          console.log('Failed AZ09 pattern code:', code);\r\n        }\r\n\r\n        return null;\r\n      }\r\n\r\n      if (!this._checkChecksum(code)) {\r\n        return null;\r\n      }\r\n\r\n      result.code = code;\r\n      return result;\r\n    }\r\n  }]);\r\n\r\n  return Code39VINReader;\r\n}(code_39_reader);\r\n\r\n/* harmony default export */ var code_39_vin_reader = (code_39_vin_reader_Code39VINReader);\r\n// CONCATENATED MODULE: ./src/reader/code_93_reader.ts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction code_93_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_93_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }\r\n\r\nfunction code_93_reader_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\n\r\n\r\nvar code_93_reader_ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*';\r\nvar code_93_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(code_93_reader_ALPHABETH_STRING).map(function (_char) {\r\n  return _char.charCodeAt(0);\r\n}));\r\nvar code_93_reader_CHARACTER_ENCODINGS = new Uint16Array([0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A, 0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134, 0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6, 0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A, 0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE, 0x126, 0x1DA, 0x1D6, 0x132, 0x15E]);\r\nvar code_93_reader_ASTERISK = 0x15E;\r\n\r\nvar code_93_reader_Code93Reader = /*#__PURE__*/function (_BarcodeReader) {\r\n  inherits_default()(Code93Reader, _BarcodeReader);\r\n\r\n  var _super = code_93_reader_createSuper(Code93Reader);\r\n\r\n  function Code93Reader() {\r\n    var _this;\r\n\r\n    classCallCheck_default()(this, Code93Reader);\r\n\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n\r\n    _this = _super.call.apply(_super, [this].concat(args));\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", 'code_93');\r\n\r\n    return _this;\r\n  }\r\n\r\n  createClass_default()(Code93Reader, [{\r\n    key: \"_patternToChar\",\r\n    value: function _patternToChar(pattern) {\r\n      for (var i = 0; i < code_93_reader_CHARACTER_ENCODINGS.length; i++) {\r\n        if (code_93_reader_CHARACTER_ENCODINGS[i] === pattern) {\r\n          return String.fromCharCode(code_93_reader_ALPHABET[i]);\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"_toPattern\",\r\n    value: function _toPattern(counters) {\r\n      var numCounters = counters.length;\r\n      var sum = counters.reduce(function (prev, next) {\r\n        return prev + next;\r\n      }, 0);\r\n      var pattern = 0;\r\n\r\n      for (var i = 0; i < numCounters; i++) {\r\n        var normalized = Math.round(counters[i] * 9 / sum);\r\n\r\n        if (normalized < 1 || normalized > 4) {\r\n          return -1;\r\n        }\r\n\r\n        if ((i & 1) === 0) {\r\n          for (var j = 0; j < normalized; j++) {\r\n            pattern = pattern << 1 | 1;\r\n          }\r\n        } else {\r\n          pattern <<= normalized;\r\n        }\r\n      }\r\n\r\n      return pattern;\r\n    }\r\n  }, {\r\n    key: \"_findStart\",\r\n    value: function _findStart() {\r\n      var offset = this._nextSet(this._row);\r\n\r\n      var patternStart = offset;\r\n      var counter = new Uint16Array([0, 0, 0, 0, 0, 0]);\r\n      var counterPos = 0;\r\n      var isWhite = false;\r\n\r\n      for (var i = offset; i < this._row.length; i++) {\r\n        if (this._row[i] ^ (isWhite ? 1 : 0)) {\r\n          counter[counterPos]++;\r\n        } else {\r\n          if (counterPos === counter.length - 1) {\r\n            // find start pattern\r\n            if (this._toPattern(counter) === code_93_reader_ASTERISK) {\r\n              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));\r\n\r\n              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {\r\n                return {\r\n                  start: patternStart,\r\n                  end: i\r\n                };\r\n              }\r\n            }\r\n\r\n            patternStart += counter[0] + counter[1];\r\n\r\n            for (var j = 0; j < 4; j++) {\r\n              counter[j] = counter[j + 2];\r\n            }\r\n\r\n            counter[4] = 0;\r\n            counter[5] = 0;\r\n            counterPos--;\r\n          } else {\r\n            counterPos++;\r\n          }\r\n\r\n          counter[counterPos] = 1;\r\n          isWhite = !isWhite;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"_verifyEnd\",\r\n    value: function _verifyEnd(lastStart, nextStart) {\r\n      if (lastStart === nextStart || !this._row[nextStart]) {\r\n        return false;\r\n      }\r\n\r\n      return true;\r\n    }\r\n  }, {\r\n    key: \"_decodeExtended\",\r\n    value: function _decodeExtended(charArray) {\r\n      var length = charArray.length;\r\n      var result = [];\r\n\r\n      for (var i = 0; i < length; i++) {\r\n        var _char2 = charArray[i];\r\n\r\n        if (_char2 >= 'a' && _char2 <= 'd') {\r\n          if (i > length - 2) {\r\n            return null;\r\n          }\r\n\r\n          var nextChar = charArray[++i];\r\n          var nextCharCode = nextChar.charCodeAt(0);\r\n          var decodedChar = void 0;\r\n\r\n          switch (_char2) {\r\n            case 'a':\r\n              if (nextChar >= 'A' && nextChar <= 'Z') {\r\n                decodedChar = String.fromCharCode(nextCharCode - 64);\r\n              } else {\r\n                return null;\r\n              }\r\n\r\n              break;\r\n\r\n            case 'b':\r\n              if (nextChar >= 'A' && nextChar <= 'E') {\r\n                decodedChar = String.fromCharCode(nextCharCode - 38);\r\n              } else if (nextChar >= 'F' && nextChar <= 'J') {\r\n                decodedChar = String.fromCharCode(nextCharCode - 11);\r\n              } else if (nextChar >= 'K' && nextChar <= 'O') {\r\n                decodedChar = String.fromCharCode(nextCharCode + 16);\r\n              } else if (nextChar >= 'P' && nextChar <= 'S') {\r\n                decodedChar = String.fromCharCode(nextCharCode + 43);\r\n              } else if (nextChar >= 'T' && nextChar <= 'Z') {\r\n                decodedChar = String.fromCharCode(127);\r\n              } else {\r\n                return null;\r\n              }\r\n\r\n              break;\r\n\r\n            case 'c':\r\n              if (nextChar >= 'A' && nextChar <= 'O') {\r\n                decodedChar = String.fromCharCode(nextCharCode - 32);\r\n              } else if (nextChar === 'Z') {\r\n                decodedChar = ':';\r\n              } else {\r\n                return null;\r\n              }\r\n\r\n              break;\r\n\r\n            case 'd':\r\n              if (nextChar >= 'A' && nextChar <= 'Z') {\r\n                decodedChar = String.fromCharCode(nextCharCode + 32);\r\n              } else {\r\n                return null;\r\n              }\r\n\r\n              break;\r\n\r\n            default:\r\n              console.warn('* code_93_reader _decodeExtended hit default case, this may be an error', decodedChar);\r\n              return null;\r\n          }\r\n\r\n          result.push(decodedChar);\r\n        } else {\r\n          result.push(_char2);\r\n        }\r\n      }\r\n\r\n      return result;\r\n    }\r\n  }, {\r\n    key: \"_matchCheckChar\",\r\n    value: function _matchCheckChar(charArray, index, maxWeight) {\r\n      var arrayToCheck = charArray.slice(0, index);\r\n      var length = arrayToCheck.length;\r\n      var weightedSums = arrayToCheck.reduce(function (sum, _char3, i) {\r\n        var weight = (i * -1 + (length - 1)) % maxWeight + 1;\r\n        var value = code_93_reader_ALPHABET.indexOf(_char3.charCodeAt(0));\r\n        return sum + weight * value;\r\n      }, 0);\r\n      var checkChar = code_93_reader_ALPHABET[weightedSums % 47];\r\n      return checkChar === charArray[index].charCodeAt(0);\r\n    }\r\n  }, {\r\n    key: \"_verifyChecksums\",\r\n    value: function _verifyChecksums(charArray) {\r\n      return this._matchCheckChar(charArray, charArray.length - 2, 20) && this._matchCheckChar(charArray, charArray.length - 1, 15);\r\n    }\r\n  }, {\r\n    key: \"decode\",\r\n    value: function decode(row, start) {\r\n      start = this._findStart();\r\n\r\n      if (!start) {\r\n        return null;\r\n      }\r\n\r\n      var counters = new Uint16Array([0, 0, 0, 0, 0, 0]);\r\n      var result = [];\r\n\r\n      var nextStart = this._nextSet(this._row, start.end);\r\n\r\n      var lastStart;\r\n      var decodedChar;\r\n\r\n      do {\r\n        counters = this._toCounters(nextStart, counters);\r\n\r\n        var pattern = this._toPattern(counters);\r\n\r\n        if (pattern < 0) {\r\n          return null;\r\n        }\r\n\r\n        decodedChar = this._patternToChar(pattern);\r\n\r\n        if (decodedChar === null) {\r\n          return null;\r\n        }\r\n\r\n        result.push(decodedChar);\r\n        lastStart = nextStart;\r\n        nextStart += array_helper[\"a\" /* default */].sum(counters);\r\n        nextStart = this._nextSet(this._row, nextStart);\r\n      } while (decodedChar !== '*');\r\n\r\n      result.pop();\r\n\r\n      if (!result.length) {\r\n        return null;\r\n      }\r\n\r\n      if (!this._verifyEnd(lastStart, nextStart)) {\r\n        return null;\r\n      }\r\n\r\n      if (!this._verifyChecksums(result)) {\r\n        return null;\r\n      }\r\n\r\n      result = result.slice(0, result.length - 2); // yes, this is an assign inside an if.\r\n\r\n      if ((result = this._decodeExtended(result)) === null) {\r\n        return null;\r\n      }\r\n\r\n      return {\r\n        code: result.join(''),\r\n        start: start.start,\r\n        end: nextStart,\r\n        startInfo: start,\r\n        decodedCodes: result,\r\n        format: this.FORMAT\r\n      };\r\n    }\r\n  }]);\r\n\r\n  return Code93Reader;\r\n}(barcode_reader);\r\n\r\n/* harmony default export */ var code_93_reader = (code_93_reader_Code93Reader);\r\n// CONCATENATED MODULE: ./src/reader/ean_reader.ts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\r\n\r\nfunction ean_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }\r\n\r\nfunction ean_reader_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\n\r\n // const CODE_L_START = 0;\r\n\r\nvar CODE_G_START = 10;\r\n\r\nvar ean_reader_START_PATTERN = [1, 1, 1];\r\nvar MIDDLE_PATTERN = [1, 1, 1, 1, 1];\r\n\r\nvar EXTENSION_START_PATTERN = [1, 1, 2];\r\nvar ean_reader_CODE_PATTERN = [[3, 2, 1, 1], [2, 2, 2, 1], [2, 1, 2, 2], [1, 4, 1, 1], [1, 1, 3, 2], [1, 2, 3, 1], [1, 1, 1, 4], [1, 3, 1, 2], [1, 2, 1, 3], [3, 1, 1, 2], [1, 1, 2, 3], [1, 2, 2, 2], [2, 2, 1, 2], [1, 1, 4, 1], [2, 3, 1, 1], [1, 3, 2, 1], [4, 1, 1, 1], [2, 1, 3, 1], [3, 1, 2, 1], [2, 1, 1, 3]];\r\nvar CODE_FREQUENCY = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26]; // const SINGLE_CODE_ERROR = 0.70;\r\n\r\nvar AVG_CODE_ERROR = 0.48;\r\n\r\nvar ean_reader_EANReader = /*#__PURE__*/function (_BarcodeReader) {\r\n  inherits_default()(EANReader, _BarcodeReader);\r\n\r\n  var _super = ean_reader_createSuper(EANReader);\r\n\r\n  // TODO: does this need to be in the class?\r\n  function EANReader(config, supplements) {\r\n    var _this;\r\n\r\n    classCallCheck_default()(this, EANReader);\r\n\r\n    _this = _super.call(this, merge_default()({\r\n      supplements: []\r\n    }, config), supplements);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", 'ean_13');\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"SINGLE_CODE_ERROR\", 0.70);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"STOP_PATTERN\", [1, 1, 1]);\r\n\r\n    return _this;\r\n  }\r\n\r\n  createClass_default()(EANReader, [{\r\n    key: \"_findPattern\",\r\n    value: function _findPattern(pattern, offset, isWhite, tryHarder) {\r\n      var counter = new Array(pattern.length).fill(0);\r\n      var bestMatch = {\r\n        error: Number.MAX_VALUE,\r\n        start: 0,\r\n        end: 0\r\n      };\r\n      var epsilon = AVG_CODE_ERROR; // console.warn('* findPattern', pattern, offset, isWhite, tryHarder, epsilon);\r\n\r\n      var counterPos = 0;\r\n\r\n      if (!offset) {\r\n        offset = this._nextSet(this._row);\r\n      }\r\n\r\n      var found = false;\r\n\r\n      for (var i = offset; i < this._row.length; i++) {\r\n        // console.warn(`* loop i=${offset} len=${this._row.length} isWhite=${isWhite} counterPos=${counterPos}`);\r\n        if (this._row[i] ^ (isWhite ? 1 : 0)) {\r\n          counter[counterPos] += 1;\r\n        } else {\r\n          if (counterPos === counter.length - 1) {\r\n            var error = this._matchPattern(counter, pattern); // console.warn('* matchPattern', error, counter, pattern);\r\n\r\n\r\n            if (error < epsilon && bestMatch.error && error < bestMatch.error) {\r\n              found = true;\r\n              bestMatch.error = error;\r\n              bestMatch.start = i - counter.reduce(function (sum, value) {\r\n                return sum + value;\r\n              }, 0);\r\n              bestMatch.end = i; // console.warn('* return bestMatch', JSON.stringify(bestMatch));\r\n\r\n              return bestMatch;\r\n            }\r\n\r\n            if (tryHarder) {\r\n              for (var j = 0; j < counter.length - 2; j++) {\r\n                counter[j] = counter[j + 2];\r\n              }\r\n\r\n              counter[counter.length - 2] = 0;\r\n              counter[counter.length - 1] = 0;\r\n              counterPos--;\r\n            }\r\n          } else {\r\n            counterPos++;\r\n          }\r\n\r\n          counter[counterPos] = 1;\r\n          isWhite = !isWhite;\r\n        }\r\n      }\r\n\r\n      if (found) {// console.warn('* return bestMatch', JSON.stringify(bestMatch));\r\n      } else {// console.warn('* return null');\r\n      }\r\n\r\n      return found ? bestMatch : null;\r\n    } // TODO: findPattern and decodeCode appear to share quite similar code, can it be reduced?\r\n\r\n  }, {\r\n    key: \"_decodeCode\",\r\n    value: function _decodeCode(start, coderange) {\r\n      // console.warn('* decodeCode', start, coderange);\r\n      var counter = [0, 0, 0, 0];\r\n      var offset = start;\r\n      var bestMatch = {\r\n        error: Number.MAX_VALUE,\r\n        code: -1,\r\n        start: start,\r\n        end: start\r\n      };\r\n      var epsilon = AVG_CODE_ERROR;\r\n      var isWhite = !this._row[offset];\r\n      var counterPos = 0;\r\n\r\n      if (!coderange) {\r\n        // console.warn('* decodeCode before length');\r\n        coderange = ean_reader_CODE_PATTERN.length; // console.warn('* decodeCode after length');\r\n      }\r\n\r\n      var found = false;\r\n\r\n      for (var i = offset; i < this._row.length; i++) {\r\n        if (this._row[i] ^ (isWhite ? 1 : 0)) {\r\n          counter[counterPos]++;\r\n        } else {\r\n          if (counterPos === counter.length - 1) {\r\n            for (var code = 0; code < coderange; code++) {\r\n              var error = this._matchPattern(counter, ean_reader_CODE_PATTERN[code]);\r\n\r\n              bestMatch.end = i;\r\n\r\n              if (error < bestMatch.error) {\r\n                bestMatch.code = code;\r\n                bestMatch.error = error;\r\n              }\r\n            }\r\n\r\n            if (bestMatch.error > epsilon) {\r\n              // console.warn('* return null');\r\n              return null;\r\n            } // console.warn('* return bestMatch', JSON.stringify(bestMatch));\r\n\r\n\r\n            return bestMatch;\r\n          } else {\r\n            counterPos++;\r\n          }\r\n\r\n          counter[counterPos] = 1;\r\n          isWhite = !isWhite;\r\n        }\r\n      }\r\n\r\n      return found ? bestMatch : null;\r\n    }\r\n  }, {\r\n    key: \"_findStart\",\r\n    value: function _findStart() {\r\n      // console.warn('* findStart');\r\n      var offset = this._nextSet(this._row);\r\n\r\n      var startInfo = null;\r\n\r\n      while (!startInfo) {\r\n        startInfo = this._findPattern(ean_reader_START_PATTERN, offset, false, true); // console.warn('* startInfo=', JSON.stringify(startInfo));\r\n\r\n        if (!startInfo) {\r\n          return null;\r\n        }\r\n\r\n        var leadingWhitespaceStart = startInfo.start - (startInfo.end - startInfo.start);\r\n\r\n        if (leadingWhitespaceStart >= 0) {\r\n          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {\r\n            // console.warn('* returning startInfo');\r\n            return startInfo;\r\n          }\r\n        }\r\n\r\n        offset = startInfo.end;\r\n        startInfo = null;\r\n      } // console.warn('* returning null');\r\n\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"_calculateFirstDigit\",\r\n    value: function _calculateFirstDigit(codeFrequency) {\r\n      // console.warn('* calculateFirstDigit', codeFrequency);\r\n      for (var i = 0; i < CODE_FREQUENCY.length; i++) {\r\n        if (codeFrequency === CODE_FREQUENCY[i]) {\r\n          // console.warn('* returning', i);\r\n          return i;\r\n        }\r\n      } // console.warn('* return null');\r\n\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"_decodePayload\",\r\n    value: function _decodePayload(inCode, result, decodedCodes) {\r\n      // console.warn('* decodePayload', inCode, result, decodedCodes);\r\n      var outCode = _objectSpread({}, inCode);\r\n\r\n      var codeFrequency = 0x0;\r\n\r\n      for (var i = 0; i < 6; i++) {\r\n        outCode = this._decodeCode(outCode.end); // console.warn('* decodeCode=', outCode);\r\n\r\n        if (!outCode) {\r\n          // console.warn('* return null');\r\n          return null;\r\n        }\r\n\r\n        if (outCode.code >= CODE_G_START) {\r\n          outCode.code -= CODE_G_START;\r\n          codeFrequency |= 1 << 5 - i;\r\n        } else {\r\n          codeFrequency |= 0 << 5 - i;\r\n        }\r\n\r\n        result.push(outCode.code);\r\n        decodedCodes.push(outCode);\r\n      }\r\n\r\n      var firstDigit = this._calculateFirstDigit(codeFrequency); // console.warn('* firstDigit=', firstDigit);\r\n\r\n\r\n      if (firstDigit === null) {\r\n        // console.warn('* return null');\r\n        return null;\r\n      }\r\n\r\n      result.unshift(firstDigit);\r\n\r\n      var middlePattern = this._findPattern(MIDDLE_PATTERN, outCode.end, true, false); // console.warn('* findPattern=', JSON.stringify(middlePattern));\r\n\r\n\r\n      if (middlePattern === null || !middlePattern.end) {\r\n        // console.warn('* return null');\r\n        return null;\r\n      }\r\n\r\n      decodedCodes.push(middlePattern);\r\n\r\n      for (var _i = 0; _i < 6; _i++) {\r\n        middlePattern = this._decodeCode(middlePattern.end, CODE_G_START); // console.warn('* decodeCode=', JSON.stringify(middlePattern));\r\n\r\n        if (!middlePattern) {\r\n          // console.warn('* return null');\r\n          return null;\r\n        }\r\n\r\n        decodedCodes.push(middlePattern);\r\n        result.push(middlePattern.code);\r\n      } // console.warn('* end code=', JSON.stringify(middlePattern));\r\n      // console.warn('* end result=', JSON.stringify(result));\r\n      // console.warn('* end decodedCodes=', decodedCodes);\r\n\r\n\r\n      return middlePattern;\r\n    }\r\n  }, {\r\n    key: \"_verifyTrailingWhitespace\",\r\n    value: function _verifyTrailingWhitespace(endInfo) {\r\n      // console.warn('* verifyTrailingWhitespace', JSON.stringify(endInfo));\r\n      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start);\r\n\r\n      if (trailingWhitespaceEnd < this._row.length) {\r\n        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {\r\n          // console.warn('* returning', JSON.stringify(endInfo));\r\n          return endInfo;\r\n        }\r\n      } // console.warn('* return null');\r\n\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"_findEnd\",\r\n    value: function _findEnd(offset, isWhite) {\r\n      // console.warn('* findEnd', offset, isWhite);\r\n      var endInfo = this._findPattern(this.STOP_PATTERN, offset, isWhite, false);\r\n\r\n      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;\r\n    }\r\n  }, {\r\n    key: \"_checksum\",\r\n    value: function _checksum(result) {\r\n      // console.warn('* _checksum', result);\r\n      var sum = 0;\r\n\r\n      for (var i = result.length - 2; i >= 0; i -= 2) {\r\n        sum += result[i];\r\n      }\r\n\r\n      sum *= 3;\r\n\r\n      for (var _i2 = result.length - 1; _i2 >= 0; _i2 -= 2) {\r\n        sum += result[_i2];\r\n      } // console.warn('* end checksum', sum % 10 === 0);\r\n\r\n\r\n      return sum % 10 === 0;\r\n    }\r\n  }, {\r\n    key: \"_decodeExtensions\",\r\n    value: function _decodeExtensions(offset) {\r\n      var start = this._nextSet(this._row, offset);\r\n\r\n      var startInfo = this._findPattern(EXTENSION_START_PATTERN, start, false, false);\r\n\r\n      if (startInfo === null) {\r\n        return null;\r\n      } // console.warn('* decodeExtensions', this.supplements);\r\n      // console.warn('* there are ', this.supplements.length, ' supplements');\r\n\r\n\r\n      for (var i = 0; i < this.supplements.length; i++) {\r\n        // console.warn('* extensions loop', i, this.supplements[i], this.supplements[i]._decode);\r\n        try {\r\n          var result = this.supplements[i].decode(this._row, startInfo.end); // console.warn('* decode result=', result);\r\n\r\n          if (result !== null) {\r\n            return {\r\n              code: result.code,\r\n              start: start,\r\n              startInfo: startInfo,\r\n              end: result.end,\r\n              decodedCodes: result.decodedCodes,\r\n              format: this.supplements[i].FORMAT\r\n            };\r\n          }\r\n        } catch (err) {\r\n          console.error('* decodeExtensions error in ', this.supplements[i], ': ', err);\r\n        }\r\n      } // console.warn('* end decodeExtensions');\r\n\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"decode\",\r\n    value: function decode(row, start) {\r\n      // console.warn('* decode', row);\r\n      // console.warn('* decode', start);\r\n      var result = new Array();\r\n      var decodedCodes = new Array();\r\n      var resultInfo = {};\r\n\r\n      var startInfo = this._findStart();\r\n\r\n      if (!startInfo) {\r\n        return null;\r\n      }\r\n\r\n      var code = {\r\n        start: startInfo.start,\r\n        end: startInfo.end\r\n      };\r\n      decodedCodes.push(code);\r\n      code = this._decodePayload(code, result, decodedCodes);\r\n\r\n      if (!code) {\r\n        return null;\r\n      }\r\n\r\n      code = this._findEnd(code.end, false);\r\n\r\n      if (!code) {\r\n        return null;\r\n      }\r\n\r\n      decodedCodes.push(code); // Checksum\r\n\r\n      if (!this._checksum(result)) {\r\n        return null;\r\n      } // console.warn('* this.supplements=', this.supplements);\r\n\r\n\r\n      if (this.supplements.length > 0) {\r\n        var supplement = this._decodeExtensions(code.end); // console.warn('* decodeExtensions returns', supplement);\r\n\r\n\r\n        if (!supplement) {\r\n          return null;\r\n        }\r\n\r\n        if (!supplement.decodedCodes) {\r\n          return null;\r\n        }\r\n\r\n        var lastCode = supplement.decodedCodes[supplement.decodedCodes.length - 1];\r\n        var endInfo = {\r\n          start: lastCode.start + ((lastCode.end - lastCode.start) / 2 | 0),\r\n          end: lastCode.end\r\n        };\r\n\r\n        if (!this._verifyTrailingWhitespace(endInfo)) {\r\n          return null;\r\n        }\r\n\r\n        resultInfo = {\r\n          supplement: supplement,\r\n          code: result.join('') + supplement.code\r\n        };\r\n      }\r\n\r\n      return _objectSpread(_objectSpread({\r\n        code: result.join(''),\r\n        start: startInfo.start,\r\n        end: code.end,\r\n        startInfo: startInfo,\r\n        decodedCodes: decodedCodes\r\n      }, resultInfo), {}, {\r\n        format: this.FORMAT\r\n      });\r\n    }\r\n  }]);\r\n\r\n  return EANReader;\r\n}(barcode_reader);\r\n\r\n/* harmony default export */ var ean_reader = (ean_reader_EANReader);\r\n// CONCATENATED MODULE: ./src/reader/ean_2_reader.ts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction ean_2_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_2_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }\r\n\r\nfunction ean_2_reader_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\n\r\n\r\nvar ean_2_reader_EAN2Reader = /*#__PURE__*/function (_EANReader) {\r\n  inherits_default()(EAN2Reader, _EANReader);\r\n\r\n  var _super = ean_2_reader_createSuper(EAN2Reader);\r\n\r\n  function EAN2Reader() {\r\n    var _this;\r\n\r\n    classCallCheck_default()(this, EAN2Reader);\r\n\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n\r\n    _this = _super.call.apply(_super, [this].concat(args));\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", 'ean_2');\r\n\r\n    return _this;\r\n  }\r\n\r\n  createClass_default()(EAN2Reader, [{\r\n    key: \"decode\",\r\n    value: function decode(row, start) {\r\n      if (row) {\r\n        this._row = row;\r\n      }\r\n\r\n      var codeFrequency = 0;\r\n      var offset = start;\r\n      var end = this._row.length;\r\n      var result = [];\r\n      var decodedCodes = [];\r\n      var code = null;\r\n\r\n      if (offset === undefined) {\r\n        return null;\r\n      }\r\n\r\n      for (var i = 0; i < 2 && offset < end; i++) {\r\n        code = this._decodeCode(offset);\r\n\r\n        if (!code) {\r\n          return null;\r\n        }\r\n\r\n        decodedCodes.push(code);\r\n        result.push(code.code % 10);\r\n\r\n        if (code.code >= CODE_G_START) {\r\n          codeFrequency |= 1 << 1 - i;\r\n        }\r\n\r\n        if (i !== 1) {\r\n          offset = this._nextSet(this._row, code.end);\r\n          offset = this._nextUnset(this._row, offset);\r\n        }\r\n      }\r\n\r\n      if (result.length !== 2 || parseInt(result.join('')) % 4 !== codeFrequency) {\r\n        return null;\r\n      }\r\n\r\n      var startInfo = this._findStart();\r\n\r\n      return {\r\n        code: result.join(''),\r\n        decodedCodes: decodedCodes,\r\n        end: code.end,\r\n        format: this.FORMAT,\r\n        startInfo: startInfo,\r\n        start: startInfo.start\r\n      };\r\n    }\r\n  }]);\r\n\r\n  return EAN2Reader;\r\n}(ean_reader);\r\n\r\n;\r\n/* harmony default export */ var ean_2_reader = (ean_2_reader_EAN2Reader);\r\n// CONCATENATED MODULE: ./src/reader/ean_5_reader.ts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction ean_5_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }\r\n\r\nfunction ean_5_reader_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\n\r\nvar CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];\r\n\r\nfunction determineCheckDigit(codeFrequency) {\r\n  for (var i = 0; i < 10; i++) {\r\n    if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {\r\n      return i;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction extensionChecksum(result) {\r\n  var length = result.length;\r\n  var sum = 0;\r\n\r\n  for (var i = length - 2; i >= 0; i -= 2) {\r\n    sum += result[i];\r\n  }\r\n\r\n  sum *= 3;\r\n\r\n  for (var _i = length - 1; _i >= 0; _i -= 2) {\r\n    sum += result[_i];\r\n  }\r\n\r\n  sum *= 3;\r\n  return sum % 10;\r\n}\r\n\r\nvar ean_5_reader_EAN5Reader = /*#__PURE__*/function (_EANReader) {\r\n  inherits_default()(EAN5Reader, _EANReader);\r\n\r\n  var _super = ean_5_reader_createSuper(EAN5Reader);\r\n\r\n  function EAN5Reader() {\r\n    var _this;\r\n\r\n    classCallCheck_default()(this, EAN5Reader);\r\n\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n\r\n    _this = _super.call.apply(_super, [this].concat(args));\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", 'ean_5');\r\n\r\n    return _this;\r\n  }\r\n\r\n  createClass_default()(EAN5Reader, [{\r\n    key: \"decode\",\r\n    value: function decode(row, start) {\r\n      if (start === undefined) {\r\n        return null;\r\n      }\r\n\r\n      if (row) {\r\n        this._row = row;\r\n      }\r\n\r\n      var codeFrequency = 0;\r\n      var offset = start;\r\n      var end = this._row.length;\r\n      var code = null;\r\n      var result = [];\r\n      var decodedCodes = [];\r\n\r\n      for (var i = 0; i < 5 && offset < end; i++) {\r\n        code = this._decodeCode(offset);\r\n\r\n        if (!code) {\r\n          return null;\r\n        }\r\n\r\n        decodedCodes.push(code);\r\n        result.push(code.code % 10);\r\n\r\n        if (code.code >= CODE_G_START) {\r\n          codeFrequency |= 1 << 4 - i;\r\n        }\r\n\r\n        if (i !== 4) {\r\n          offset = this._nextSet(this._row, code.end);\r\n          offset = this._nextUnset(this._row, offset);\r\n        }\r\n      }\r\n\r\n      if (result.length !== 5) {\r\n        return null;\r\n      }\r\n\r\n      if (extensionChecksum(result) !== determineCheckDigit(codeFrequency)) {\r\n        return null;\r\n      }\r\n\r\n      var startInfo = this._findStart();\r\n\r\n      return {\r\n        code: result.join(''),\r\n        decodedCodes: decodedCodes,\r\n        end: code.end,\r\n        format: this.FORMAT,\r\n        startInfo: startInfo,\r\n        start: startInfo.start\r\n      };\r\n    }\r\n  }]);\r\n\r\n  return EAN5Reader;\r\n}(ean_reader);\r\n\r\n;\r\n/* harmony default export */ var ean_5_reader = (ean_5_reader_EAN5Reader);\r\n// CONCATENATED MODULE: ./src/reader/ean_8_reader.ts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction ean_8_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_8_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }\r\n\r\nfunction ean_8_reader_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\n\r\n\r\nvar ean_8_reader_EAN8Reader = /*#__PURE__*/function (_EANReader) {\r\n  inherits_default()(EAN8Reader, _EANReader);\r\n\r\n  var _super = ean_8_reader_createSuper(EAN8Reader);\r\n\r\n  function EAN8Reader() {\r\n    var _this;\r\n\r\n    classCallCheck_default()(this, EAN8Reader);\r\n\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n\r\n    _this = _super.call.apply(_super, [this].concat(args));\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", 'ean_8');\r\n\r\n    return _this;\r\n  }\r\n\r\n  createClass_default()(EAN8Reader, [{\r\n    key: \"_decodePayload\",\r\n    value: function _decodePayload(inCode, result, decodedCodes) {\r\n      var code = inCode;\r\n\r\n      for (var i = 0; i < 4; i++) {\r\n        code = this._decodeCode(code.end, CODE_G_START);\r\n\r\n        if (!code) {\r\n          return null;\r\n        }\r\n\r\n        result.push(code.code);\r\n        decodedCodes.push(code);\r\n      }\r\n\r\n      code = this._findPattern(MIDDLE_PATTERN, code.end, true, false);\r\n\r\n      if (code === null) {\r\n        return null;\r\n      }\r\n\r\n      decodedCodes.push(code);\r\n\r\n      for (var _i = 0; _i < 4; _i++) {\r\n        code = this._decodeCode(code.end, CODE_G_START);\r\n\r\n        if (!code) {\r\n          return null;\r\n        }\r\n\r\n        decodedCodes.push(code);\r\n        result.push(code.code);\r\n      }\r\n\r\n      return code;\r\n    }\r\n  }]);\r\n\r\n  return EAN8Reader;\r\n}(ean_reader);\r\n\r\n/* harmony default export */ var ean_8_reader = (ean_8_reader_EAN8Reader);\r\n// CONCATENATED MODULE: ./src/reader/i2of5_reader.ts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction i2of5_reader_createSuper(Derived) { var hasNativeReflectConstruct = i2of5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }\r\n\r\nfunction i2of5_reader_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\n// TODO: i2of5_reader and 2of5_reader share very similar code, make use of that\r\n\r\n\r\nvar i2of5_reader_N = 1;\r\nvar i2of5_reader_W = 3;\r\n\r\nvar i2of5_reader_I2of5Reader = /*#__PURE__*/function (_BarcodeReader) {\r\n  inherits_default()(I2of5Reader, _BarcodeReader);\r\n\r\n  var _super = i2of5_reader_createSuper(I2of5Reader);\r\n\r\n  function I2of5Reader(opts) {\r\n    var _this;\r\n\r\n    classCallCheck_default()(this, I2of5Reader);\r\n\r\n    _this = _super.call(this, merge_default()({\r\n      normalizeBarSpaceWidth: false\r\n    }, opts));\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"barSpaceRatio\", [1, 1]);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"SINGLE_CODE_ERROR\", 0.78);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"AVG_CODE_ERROR\", 0.38);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"START_PATTERN\", [i2of5_reader_N, i2of5_reader_N, i2of5_reader_N, i2of5_reader_N]);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"STOP_PATTERN\", [i2of5_reader_N, i2of5_reader_N, i2of5_reader_W]);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"CODE_PATTERN\", [[i2of5_reader_N, i2of5_reader_N, i2of5_reader_W, i2of5_reader_W, i2of5_reader_N], [i2of5_reader_W, i2of5_reader_N, i2of5_reader_N, i2of5_reader_N, i2of5_reader_W], [i2of5_reader_N, i2of5_reader_W, i2of5_reader_N, i2of5_reader_N, i2of5_reader_W], [i2of5_reader_W, i2of5_reader_W, i2of5_reader_N, i2of5_reader_N, i2of5_reader_N], [i2of5_reader_N, i2of5_reader_N, i2of5_reader_W, i2of5_reader_N, i2of5_reader_W], [i2of5_reader_W, i2of5_reader_N, i2of5_reader_W, i2of5_reader_N, i2of5_reader_N], [i2of5_reader_N, i2of5_reader_W, i2of5_reader_W, i2of5_reader_N, i2of5_reader_N], [i2of5_reader_N, i2of5_reader_N, i2of5_reader_N, i2of5_reader_W, i2of5_reader_W], [i2of5_reader_W, i2of5_reader_N, i2of5_reader_N, i2of5_reader_W, i2of5_reader_N], [i2of5_reader_N, i2of5_reader_W, i2of5_reader_N, i2of5_reader_W, i2of5_reader_N]]);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"MAX_CORRECTION_FACTOR\", 5);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", 'i2of5');\r\n\r\n    if (opts.normalizeBarSpaceWidth) {\r\n      _this.SINGLE_CODE_ERROR = 0.38;\r\n      _this.AVG_CODE_ERROR = 0.09;\r\n    }\r\n\r\n    _this.config = opts;\r\n    return possibleConstructorReturn_default()(_this, assertThisInitialized_default()(_this));\r\n  }\r\n\r\n  createClass_default()(I2of5Reader, [{\r\n    key: \"_matchPattern\",\r\n    value: function _matchPattern(counter, code) {\r\n      if (this.config.normalizeBarSpaceWidth) {\r\n        var counterSum = [0, 0];\r\n        var codeSum = [0, 0];\r\n        var correction = [0, 0];\r\n        var correctionRatio = this.MAX_CORRECTION_FACTOR;\r\n        var correctionRatioInverse = 1 / correctionRatio;\r\n\r\n        for (var i = 0; i < counter.length; i++) {\r\n          counterSum[i % 2] += counter[i];\r\n          codeSum[i % 2] += code[i];\r\n        }\r\n\r\n        correction[0] = codeSum[0] / counterSum[0];\r\n        correction[1] = codeSum[1] / counterSum[1];\r\n        correction[0] = Math.max(Math.min(correction[0], correctionRatio), correctionRatioInverse);\r\n        correction[1] = Math.max(Math.min(correction[1], correctionRatio), correctionRatioInverse);\r\n        this.barSpaceRatio = correction;\r\n\r\n        for (var _i = 0; _i < counter.length; _i++) {\r\n          counter[_i] *= this.barSpaceRatio[_i % 2];\r\n        }\r\n      }\r\n\r\n      return get_default()(getPrototypeOf_default()(I2of5Reader.prototype), \"_matchPattern\", this).call(this, counter, code);\r\n    }\r\n  }, {\r\n    key: \"_findPattern\",\r\n    value: function _findPattern(pattern, offset) {\r\n      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\r\n      var counter = new Array(pattern.length).fill(0);\r\n      var counterPos = 0;\r\n      var bestMatch = {\r\n        error: Number.MAX_VALUE,\r\n        start: 0,\r\n        end: 0\r\n      };\r\n      var epsilon = this.AVG_CODE_ERROR;\r\n      isWhite = isWhite || false;\r\n      tryHarder = tryHarder || false;\r\n\r\n      if (!offset) {\r\n        offset = this._nextSet(this._row);\r\n      }\r\n\r\n      for (var i = offset; i < this._row.length; i++) {\r\n        if (this._row[i] ^ (isWhite ? 1 : 0)) {\r\n          counter[counterPos]++;\r\n        } else {\r\n          if (counterPos === counter.length - 1) {\r\n            var sum = counter.reduce(function (prev, next) {\r\n              return prev + next;\r\n            }, 0);\r\n\r\n            var error = this._matchPattern(counter, pattern);\r\n\r\n            if (error < epsilon) {\r\n              bestMatch.error = error;\r\n              bestMatch.start = i - sum;\r\n              bestMatch.end = i;\r\n              return bestMatch;\r\n            }\r\n\r\n            if (tryHarder) {\r\n              for (var j = 0; j < counter.length - 2; j++) {\r\n                counter[j] = counter[j + 2];\r\n              }\r\n\r\n              counter[counter.length - 2] = 0;\r\n              counter[counter.length - 1] = 0;\r\n              counterPos--;\r\n            } else {\r\n              return null;\r\n            }\r\n          } else {\r\n            counterPos++;\r\n          }\r\n\r\n          counter[counterPos] = 1;\r\n          isWhite = !isWhite;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"_findStart\",\r\n    value: function _findStart() {\r\n      var leadingWhitespaceStart = 0;\r\n\r\n      var offset = this._nextSet(this._row);\r\n\r\n      var startInfo = null;\r\n      var narrowBarWidth = 1;\r\n\r\n      while (!startInfo) {\r\n        startInfo = this._findPattern(this.START_PATTERN, offset, false, true);\r\n\r\n        if (!startInfo) {\r\n          return null;\r\n        }\r\n\r\n        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / 4);\r\n        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 10;\r\n\r\n        if (leadingWhitespaceStart >= 0) {\r\n          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {\r\n            return startInfo;\r\n          }\r\n        }\r\n\r\n        offset = startInfo.end;\r\n        startInfo = null;\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"_verifyTrailingWhitespace\",\r\n    value: function _verifyTrailingWhitespace(endInfo) {\r\n      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;\r\n\r\n      if (trailingWhitespaceEnd < this._row.length) {\r\n        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {\r\n          return endInfo;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"_findEnd\",\r\n    value: function _findEnd() {\r\n      this._row.reverse();\r\n\r\n      var endInfo = this._findPattern(this.STOP_PATTERN);\r\n\r\n      this._row.reverse();\r\n\r\n      if (endInfo === null) {\r\n        return null;\r\n      } // reverse numbers\r\n\r\n\r\n      var tmp = endInfo.start;\r\n      endInfo.start = this._row.length - endInfo.end;\r\n      endInfo.end = this._row.length - tmp;\r\n      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;\r\n    }\r\n  }, {\r\n    key: \"_decodePair\",\r\n    value: function _decodePair(counterPair) {\r\n      var codes = [];\r\n\r\n      for (var i = 0; i < counterPair.length; i++) {\r\n        var code = this._decodeCode(counterPair[i]);\r\n\r\n        if (!code) {\r\n          return null;\r\n        }\r\n\r\n        codes.push(code);\r\n      }\r\n\r\n      return codes;\r\n    }\r\n  }, {\r\n    key: \"_decodeCode\",\r\n    value: function _decodeCode(counter) {\r\n      var epsilon = this.AVG_CODE_ERROR;\r\n      var bestMatch = {\r\n        error: Number.MAX_VALUE,\r\n        code: -1,\r\n        start: 0,\r\n        end: 0\r\n      };\r\n\r\n      for (var code = 0; code < this.CODE_PATTERN.length; code++) {\r\n        var error = this._matchPattern(counter, this.CODE_PATTERN[code]);\r\n\r\n        if (error < bestMatch.error) {\r\n          bestMatch.code = code;\r\n          bestMatch.error = error;\r\n        }\r\n      }\r\n\r\n      if (bestMatch.error < epsilon) {\r\n        return bestMatch;\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }, {\r\n    key: \"_decodePayload\",\r\n    value: function _decodePayload(counters, result, decodedCodes) {\r\n      var pos = 0;\r\n      var counterLength = counters.length;\r\n      var counterPair = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]];\r\n      var codes = null;\r\n\r\n      while (pos < counterLength) {\r\n        for (var i = 0; i < 5; i++) {\r\n          counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];\r\n          counterPair[1][i] = counters[pos + 1] * this.barSpaceRatio[1];\r\n          pos += 2;\r\n        }\r\n\r\n        codes = this._decodePair(counterPair);\r\n\r\n        if (!codes) {\r\n          return null;\r\n        }\r\n\r\n        for (var _i2 = 0; _i2 < codes.length; _i2++) {\r\n          result.push(codes[_i2].code + '');\r\n          decodedCodes.push(codes[_i2]);\r\n        }\r\n      }\r\n\r\n      return codes;\r\n    }\r\n  }, {\r\n    key: \"_verifyCounterLength\",\r\n    value: function _verifyCounterLength(counters) {\r\n      return counters.length % 10 === 0;\r\n    }\r\n  }, {\r\n    key: \"decode\",\r\n    value: function decode(row, start) {\r\n      var result = new Array();\r\n      var decodedCodes = new Array();\r\n\r\n      var startInfo = this._findStart();\r\n\r\n      if (!startInfo) {\r\n        return null;\r\n      }\r\n\r\n      decodedCodes.push(startInfo);\r\n\r\n      var endInfo = this._findEnd();\r\n\r\n      if (!endInfo) {\r\n        return null;\r\n      }\r\n\r\n      var counters = this._fillCounters(startInfo.end, endInfo.start, false);\r\n\r\n      if (!this._verifyCounterLength(counters)) {\r\n        return null;\r\n      }\r\n\r\n      var code = this._decodePayload(counters, result, decodedCodes);\r\n\r\n      if (!code) {\r\n        return null;\r\n      }\r\n\r\n      if (result.length % 2 !== 0 || result.length < 6) {\r\n        return null;\r\n      }\r\n\r\n      decodedCodes.push(endInfo);\r\n      return {\r\n        code: result.join(''),\r\n        start: startInfo.start,\r\n        end: endInfo.end,\r\n        startInfo: startInfo,\r\n        decodedCodes: decodedCodes,\r\n        format: this.FORMAT\r\n      };\r\n    }\r\n  }]);\r\n\r\n  return I2of5Reader;\r\n}(barcode_reader);\r\n\r\n/* harmony default export */ var i2of5_reader = (i2of5_reader_I2of5Reader);\r\n// CONCATENATED MODULE: ./src/reader/upc_e_reader.ts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction upc_e_reader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction upc_e_reader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? upc_e_reader_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : upc_e_reader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\r\n\r\nfunction upc_e_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_e_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }\r\n\r\nfunction upc_e_reader_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\n\r\n\r\nvar upc_e_reader_UPCEReader = /*#__PURE__*/function (_EANReader) {\r\n  inherits_default()(UPCEReader, _EANReader);\r\n\r\n  var _super = upc_e_reader_createSuper(UPCEReader);\r\n\r\n  function UPCEReader() {\r\n    var _this;\r\n\r\n    classCallCheck_default()(this, UPCEReader);\r\n\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n\r\n    _this = _super.call.apply(_super, [this].concat(args));\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"CODE_FREQUENCY\", [[56, 52, 50, 49, 44, 38, 35, 42, 41, 37], [7, 11, 13, 14, 19, 25, 28, 21, 22, 26]]);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"STOP_PATTERN\", [1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7]);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", 'upc_e');\r\n\r\n    return _this;\r\n  }\r\n\r\n  createClass_default()(UPCEReader, [{\r\n    key: \"_decodePayload\",\r\n    value: function _decodePayload(inCode, result, decodedCodes) {\r\n      var outCode = upc_e_reader_objectSpread({}, inCode);\r\n\r\n      var codeFrequency = 0x0;\r\n\r\n      for (var i = 0; i < 6; i++) {\r\n        outCode = this._decodeCode(outCode.end);\r\n\r\n        if (!outCode) {\r\n          return null;\r\n        }\r\n\r\n        if (outCode.code >= CODE_G_START) {\r\n          outCode.code = outCode.code - CODE_G_START;\r\n          codeFrequency |= 1 << 5 - i;\r\n        }\r\n\r\n        result.push(outCode.code);\r\n        decodedCodes.push(outCode);\r\n      }\r\n\r\n      if (!this._determineParity(codeFrequency, result)) {\r\n        return null;\r\n      }\r\n\r\n      return outCode;\r\n    }\r\n  }, {\r\n    key: \"_determineParity\",\r\n    value: function _determineParity(codeFrequency, result) {\r\n      for (var nrSystem = 0; nrSystem < this.CODE_FREQUENCY.length; nrSystem++) {\r\n        for (var i = 0; i < this.CODE_FREQUENCY[nrSystem].length; i++) {\r\n          if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {\r\n            result.unshift(nrSystem);\r\n            result.push(i);\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n\r\n      return false;\r\n    }\r\n  }, {\r\n    key: \"_convertToUPCA\",\r\n    value: function _convertToUPCA(result) {\r\n      var upca = [result[0]];\r\n      var lastDigit = result[result.length - 2];\r\n\r\n      if (lastDigit <= 2) {\r\n        upca = upca.concat(result.slice(1, 3)).concat([lastDigit, 0, 0, 0, 0]).concat(result.slice(3, 6));\r\n      } else if (lastDigit === 3) {\r\n        upca = upca.concat(result.slice(1, 4)).concat([0, 0, 0, 0, 0]).concat(result.slice(4, 6));\r\n      } else if (lastDigit === 4) {\r\n        upca = upca.concat(result.slice(1, 5)).concat([0, 0, 0, 0, 0, result[5]]);\r\n      } else {\r\n        upca = upca.concat(result.slice(1, 6)).concat([0, 0, 0, 0, lastDigit]);\r\n      }\r\n\r\n      upca.push(result[result.length - 1]);\r\n      return upca;\r\n    }\r\n  }, {\r\n    key: \"_checksum\",\r\n    value: function _checksum(result) {\r\n      return get_default()(getPrototypeOf_default()(UPCEReader.prototype), \"_checksum\", this).call(this, this._convertToUPCA(result));\r\n    }\r\n  }, {\r\n    key: \"_findEnd\",\r\n    value: function _findEnd(offset, isWhite) {\r\n      return get_default()(getPrototypeOf_default()(UPCEReader.prototype), \"_findEnd\", this).call(this, offset, true);\r\n    }\r\n  }, {\r\n    key: \"_verifyTrailingWhitespace\",\r\n    value: function _verifyTrailingWhitespace(endInfo) {\r\n      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;\r\n\r\n      if (trailingWhitespaceEnd < this._row.length) {\r\n        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {\r\n          return endInfo;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }]);\r\n\r\n  return UPCEReader;\r\n}(ean_reader);\r\n\r\n/* harmony default export */ var upc_e_reader = (upc_e_reader_UPCEReader);\r\n// CONCATENATED MODULE: ./src/reader/upc_reader.ts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction upc_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }\r\n\r\nfunction upc_reader_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\n\r\n\r\nvar upc_reader_UPCReader = /*#__PURE__*/function (_EANReader) {\r\n  inherits_default()(UPCReader, _EANReader);\r\n\r\n  var _super = upc_reader_createSuper(UPCReader);\r\n\r\n  function UPCReader() {\r\n    var _this;\r\n\r\n    classCallCheck_default()(this, UPCReader);\r\n\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n\r\n    _this = _super.call.apply(_super, [this].concat(args));\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"FORMAT\", 'upc_a');\r\n\r\n    return _this;\r\n  }\r\n\r\n  createClass_default()(UPCReader, [{\r\n    key: \"decode\",\r\n    value: function decode(row, start) {\r\n      var result = ean_reader.prototype.decode.call(this);\r\n\r\n      if (result && result.code && result.code.length === 13 && result.code.charAt(0) === '0') {\r\n        result.code = result.code.substring(1);\r\n        return result;\r\n      }\r\n\r\n      return null;\r\n    }\r\n  }]);\r\n\r\n  return UPCReader;\r\n}(ean_reader);\r\n\r\n/* harmony default export */ var upc_reader = (upc_reader_UPCReader);\r\n// CONCATENATED MODULE: ./src/decoder/bresenham.js\r\nvar Bresenham = {};\r\nvar Slope = {\r\n  DIR: {\r\n    UP: 1,\r\n    DOWN: -1\r\n  }\r\n};\r\n/**\r\n * Scans a line of the given image from point p1 to p2 and returns a result object containing\r\n * gray-scale values (0-255) of the underlying pixels in addition to the min\r\n * and max values.\r\n * @param {Object} imageWrapper\r\n * @param {Object} p1 The start point {x,y}\r\n * @param {Object} p2 The end point {x,y}\r\n * @returns {line, min, max}\r\n */\r\n\r\nBresenham.getBarcodeLine = function (imageWrapper, p1, p2) {\r\n  /* eslint-disable no-bitwise */\r\n  var x0 = p1.x | 0;\r\n  var y0 = p1.y | 0;\r\n  var x1 = p2.x | 0;\r\n  var y1 = p2.y | 0;\r\n  /* eslint-disable no-bitwise */\r\n\r\n  var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);\r\n  var error;\r\n  var y;\r\n  var tmp;\r\n  var x;\r\n  var line = [];\r\n  var imageData = imageWrapper.data;\r\n  var width = imageWrapper.size.x;\r\n  var val;\r\n  var min = 255;\r\n  var max = 0;\r\n\r\n  function read(a, b) {\r\n    val = imageData[b * width + a];\r\n    min = val < min ? val : min;\r\n    max = val > max ? val : max;\r\n    line.push(val);\r\n  }\r\n\r\n  if (steep) {\r\n    tmp = x0;\r\n    x0 = y0;\r\n    y0 = tmp;\r\n    tmp = x1;\r\n    x1 = y1;\r\n    y1 = tmp;\r\n  }\r\n\r\n  if (x0 > x1) {\r\n    tmp = x0;\r\n    x0 = x1;\r\n    x1 = tmp;\r\n    tmp = y0;\r\n    y0 = y1;\r\n    y1 = tmp;\r\n  }\r\n\r\n  var deltaX = x1 - x0;\r\n  var deltaY = Math.abs(y1 - y0);\r\n  error = deltaX / 2 | 0;\r\n  y = y0;\r\n  var yStep = y0 < y1 ? 1 : -1;\r\n\r\n  for (x = x0; x < x1; x++) {\r\n    if (steep) {\r\n      read(y, x);\r\n    } else {\r\n      read(x, y);\r\n    }\r\n\r\n    error -= deltaY;\r\n\r\n    if (error < 0) {\r\n      y += yStep;\r\n      error += deltaX;\r\n    }\r\n  }\r\n\r\n  return {\r\n    line: line,\r\n    min: min,\r\n    max: max\r\n  };\r\n};\r\n/**\r\n * Converts the result from getBarcodeLine into a binary representation\r\n * also considering the frequency and slope of the signal for more robust results\r\n * @param {Object} result {line, min, max}\r\n */\r\n\r\n\r\nBresenham.toBinaryLine = function (result) {\r\n  var min = result.min;\r\n  var max = result.max;\r\n  var line = result.line;\r\n  var slope;\r\n  var slope2;\r\n  var center = min + (max - min) / 2;\r\n  var extrema = [];\r\n  var currentDir;\r\n  var dir;\r\n  var threshold = (max - min) / 12;\r\n  var rThreshold = -threshold;\r\n  var i;\r\n  var j; // 1. find extrema\r\n\r\n  currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;\r\n  extrema.push({\r\n    pos: 0,\r\n    val: line[0]\r\n  });\r\n\r\n  for (i = 0; i < line.length - 2; i++) {\r\n    slope = line[i + 1] - line[i];\r\n    slope2 = line[i + 2] - line[i + 1];\r\n\r\n    if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {\r\n      dir = Slope.DIR.DOWN;\r\n    } else if (slope + slope2 > threshold && line[i + 1] > center * 0.5) {\r\n      dir = Slope.DIR.UP;\r\n    } else {\r\n      dir = currentDir;\r\n    }\r\n\r\n    if (currentDir !== dir) {\r\n      extrema.push({\r\n        pos: i,\r\n        val: line[i]\r\n      });\r\n      currentDir = dir;\r\n    }\r\n  }\r\n\r\n  extrema.push({\r\n    pos: line.length,\r\n    val: line[line.length - 1]\r\n  });\r\n\r\n  for (j = extrema[0].pos; j < extrema[1].pos; j++) {\r\n    line[j] = line[j] > center ? 0 : 1;\r\n  } // iterate over extrema and convert to binary based on avg between minmax\r\n\r\n\r\n  for (i = 1; i < extrema.length - 1; i++) {\r\n    if (extrema[i + 1].val > extrema[i].val) {\r\n      threshold = extrema[i].val + (extrema[i + 1].val - extrema[i].val) / 3 * 2 | 0;\r\n    } else {\r\n      threshold = extrema[i + 1].val + (extrema[i].val - extrema[i + 1].val) / 3 | 0;\r\n    }\r\n\r\n    for (j = extrema[i].pos; j < extrema[i + 1].pos; j++) {\r\n      line[j] = line[j] > threshold ? 0 : 1;\r\n    }\r\n  }\r\n\r\n  return {\r\n    line: line,\r\n    threshold: threshold\r\n  };\r\n};\r\n/**\r\n * Used for development only\r\n */\r\n\r\n\r\nBresenham.debug = {\r\n  printFrequency: function printFrequency(line, canvas) {\r\n    var i;\r\n    var ctx = canvas.getContext('2d'); // eslint-disable-next-line no-param-reassign\r\n\r\n    canvas.width = line.length; // eslint-disable-next-line no-param-reassign\r\n\r\n    canvas.height = 256;\r\n    ctx.beginPath();\r\n    ctx.strokeStyle = 'blue';\r\n\r\n    for (i = 0; i < line.length; i++) {\r\n      ctx.moveTo(i, 255);\r\n      ctx.lineTo(i, 255 - line[i]);\r\n    }\r\n\r\n    ctx.stroke();\r\n    ctx.closePath();\r\n  },\r\n  printPattern: function printPattern(line, canvas) {\r\n    var ctx = canvas.getContext('2d');\r\n    var i; // eslint-disable-next-line no-param-reassign\r\n\r\n    canvas.width = line.length;\r\n    ctx.fillColor = 'black';\r\n\r\n    for (i = 0; i < line.length; i++) {\r\n      if (line[i] === 1) {\r\n        ctx.fillRect(i, 0, 1, 100);\r\n      }\r\n    }\r\n  }\r\n};\r\n/* harmony default export */ var bresenham = (Bresenham);\r\n// CONCATENATED MODULE: ./src/decoder/barcode_decoder.js\r\n\r\n\r\n\r\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\r\n\r\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\r\n\r\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\r\n\r\n\r\n\r\n/* eslint-disable import/no-cycle */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar READERS = {\r\n  code_128_reader: code_128_reader,\r\n  ean_reader: ean_reader,\r\n  ean_5_reader: ean_5_reader,\r\n  ean_2_reader: ean_2_reader,\r\n  ean_8_reader: ean_8_reader,\r\n  code_39_reader: code_39_reader,\r\n  code_39_vin_reader: code_39_vin_reader,\r\n  codabar_reader: codabar_reader,\r\n  upc_reader: upc_reader,\r\n  upc_e_reader: upc_e_reader,\r\n  i2of5_reader: i2of5_reader,\r\n  '2of5_reader': _2of5_reader,\r\n  code_93_reader: code_93_reader,\r\n  code_32_reader: code_32_reader\r\n};\r\n/* harmony default export */ var barcode_decoder = ({\r\n  registerReader: function registerReader(name, reader) {\r\n    READERS[name] = reader;\r\n  },\r\n  create: function create(config, inputImageWrapper) {\r\n    var _canvas = {\r\n      ctx: {\r\n        frequency: null,\r\n        pattern: null,\r\n        overlay: null\r\n      },\r\n      dom: {\r\n        frequency: null,\r\n        pattern: null,\r\n        overlay: null\r\n      }\r\n    };\r\n    var _barcodeReaders = [];\r\n    initCanvas();\r\n    initReaders();\r\n    initConfig();\r\n\r\n    function initCanvas() {\r\n      if (  true && typeof document !== 'undefined') {\r\n        var $debug = document.querySelector('#debug.detection');\r\n        _canvas.dom.frequency = document.querySelector('canvas.frequency');\r\n\r\n        if (!_canvas.dom.frequency) {\r\n          _canvas.dom.frequency = document.createElement('canvas');\r\n          _canvas.dom.frequency.className = 'frequency';\r\n\r\n          if ($debug) {\r\n            $debug.appendChild(_canvas.dom.frequency);\r\n          }\r\n        }\r\n\r\n        _canvas.ctx.frequency = _canvas.dom.frequency.getContext('2d');\r\n        _canvas.dom.pattern = document.querySelector('canvas.patternBuffer');\r\n\r\n        if (!_canvas.dom.pattern) {\r\n          _canvas.dom.pattern = document.createElement('canvas');\r\n          _canvas.dom.pattern.className = 'patternBuffer';\r\n\r\n          if ($debug) {\r\n            $debug.appendChild(_canvas.dom.pattern);\r\n          }\r\n        }\r\n\r\n        _canvas.ctx.pattern = _canvas.dom.pattern.getContext('2d');\r\n        _canvas.dom.overlay = document.querySelector('canvas.drawingBuffer');\r\n\r\n        if (_canvas.dom.overlay) {\r\n          _canvas.ctx.overlay = _canvas.dom.overlay.getContext('2d');\r\n        }\r\n      }\r\n    }\r\n\r\n    function initReaders() {\r\n      config.readers.forEach(function (readerConfig) {\r\n        var reader;\r\n        var configuration = {};\r\n        var supplements = [];\r\n\r\n        if (typeof_default()(readerConfig) === 'object') {\r\n          reader = readerConfig.format;\r\n          configuration = readerConfig.config;\r\n        } else if (typeof readerConfig === 'string') {\r\n          reader = readerConfig;\r\n        }\r\n\r\n        if (true) {\r\n          console.log('Before registering reader: ', reader);\r\n        }\r\n\r\n        if (configuration.supplements) {\r\n          supplements = configuration.supplements.map(function (supplement) {\r\n            return new READERS[supplement]();\r\n          });\r\n        }\r\n\r\n        try {\r\n          var readerObj = new READERS[reader](configuration, supplements);\r\n\r\n          _barcodeReaders.push(readerObj);\r\n        } catch (err) {\r\n          console.error('* Error constructing reader ', reader, err);\r\n          throw err;\r\n        }\r\n      });\r\n\r\n      if (true) {\r\n        console.log(\"Registered Readers: \".concat(_barcodeReaders.map(function (reader) {\r\n          return JSON.stringify({\r\n            format: reader.FORMAT,\r\n            config: reader.config\r\n          });\r\n        }).join(', ')));\r\n      }\r\n    }\r\n\r\n    function initConfig() {\r\n      if (  true && typeof document !== 'undefined') {\r\n        var i;\r\n        var vis = [{\r\n          node: _canvas.dom.frequency,\r\n          prop: config.debug.showFrequency\r\n        }, {\r\n          node: _canvas.dom.pattern,\r\n          prop: config.debug.showPattern\r\n        }];\r\n\r\n        for (i = 0; i < vis.length; i++) {\r\n          if (vis[i].prop === true) {\r\n            vis[i].node.style.display = 'block';\r\n          } else {\r\n            vis[i].node.style.display = 'none';\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * extend the line on both ends\r\n     * @param {Array} line\r\n     * @param {Number} angle\r\n     */\r\n\r\n\r\n    function getExtendedLine(line, angle, ext) {\r\n      function extendLine(amount) {\r\n        var extension = {\r\n          y: amount * Math.sin(angle),\r\n          x: amount * Math.cos(angle)\r\n        };\r\n        /* eslint-disable no-param-reassign */\r\n\r\n        line[0].y -= extension.y;\r\n        line[0].x -= extension.x;\r\n        line[1].y += extension.y;\r\n        line[1].x += extension.x;\r\n        /* eslint-enable no-param-reassign */\r\n      } // check if inside image\r\n\r\n\r\n      extendLine(ext);\r\n\r\n      while (ext > 1 && (!inputImageWrapper.inImageWithBorder(line[0]) || !inputImageWrapper.inImageWithBorder(line[1]))) {\r\n        // eslint-disable-next-line no-param-reassign\r\n        ext -= Math.ceil(ext / 2);\r\n        extendLine(-ext);\r\n      }\r\n\r\n      return line;\r\n    }\r\n\r\n    function getLine(box) {\r\n      return [{\r\n        x: (box[1][0] - box[0][0]) / 2 + box[0][0],\r\n        y: (box[1][1] - box[0][1]) / 2 + box[0][1]\r\n      }, {\r\n        x: (box[3][0] - box[2][0]) / 2 + box[2][0],\r\n        y: (box[3][1] - box[2][1]) / 2 + box[2][1]\r\n      }];\r\n    }\r\n\r\n    function tryDecode(line) {\r\n      var result = null;\r\n      var i;\r\n      var barcodeLine = bresenham.getBarcodeLine(inputImageWrapper, line[0], line[1]);\r\n\r\n      if (  true && config.debug.showFrequency) {\r\n        image_debug[\"a\" /* default */].drawPath(line, {\r\n          x: 'x',\r\n          y: 'y'\r\n        }, _canvas.ctx.overlay, {\r\n          color: 'red',\r\n          lineWidth: 3\r\n        });\r\n        bresenham.debug.printFrequency(barcodeLine.line, _canvas.dom.frequency);\r\n      }\r\n\r\n      bresenham.toBinaryLine(barcodeLine);\r\n\r\n      if (  true && config.debug.showPattern) {\r\n        bresenham.debug.printPattern(barcodeLine.line, _canvas.dom.pattern);\r\n      }\r\n\r\n      for (i = 0; i < _barcodeReaders.length && result === null; i++) {\r\n        result = _barcodeReaders[i].decodePattern(barcodeLine.line);\r\n      }\r\n\r\n      if (result === null) {\r\n        return null;\r\n      }\r\n\r\n      return {\r\n        codeResult: result,\r\n        barcodeLine: barcodeLine\r\n      };\r\n    }\r\n    /**\r\n     * This method slices the given area apart and tries to detect a barcode-pattern\r\n     * for each slice. It returns the decoded barcode, or null if nothing was found\r\n     * @param {Array} box\r\n     * @param {Array} line\r\n     * @param {Number} lineAngle\r\n     */\r\n\r\n\r\n    function tryDecodeBruteForce(box, line, lineAngle) {\r\n      var sideLength = Math.sqrt(Math.pow(box[1][0] - box[0][0], 2) + Math.pow(box[1][1] - box[0][1], 2));\r\n      var i;\r\n      var slices = 16;\r\n      var result = null;\r\n      var dir;\r\n      var extension;\r\n      var xdir = Math.sin(lineAngle);\r\n      var ydir = Math.cos(lineAngle);\r\n\r\n      for (i = 1; i < slices && result === null; i++) {\r\n        // move line perpendicular to angle\r\n        // eslint-disable-next-line no-mixed-operators\r\n        dir = sideLength / slices * i * (i % 2 === 0 ? -1 : 1);\r\n        extension = {\r\n          y: dir * xdir,\r\n          x: dir * ydir\r\n        };\r\n        /* eslint-disable no-param-reassign */\r\n\r\n        line[0].y += extension.x;\r\n        line[0].x -= extension.y;\r\n        line[1].y += extension.x;\r\n        line[1].x -= extension.y;\r\n        /* eslint-enable no-param-reassign */\r\n\r\n        result = tryDecode(line);\r\n      }\r\n\r\n      return result;\r\n    }\r\n\r\n    function getLineLength(line) {\r\n      return Math.sqrt(Math.pow(Math.abs(line[1].y - line[0].y), 2) + Math.pow(Math.abs(line[1].x - line[0].x), 2));\r\n    }\r\n\r\n    function _decodeFromImage2(_x) {\r\n      return _decodeFromImage.apply(this, arguments);\r\n    }\r\n    /**\r\n     * With the help of the configured readers (Code128 or EAN) this function tries to detect a\r\n     * valid barcode pattern within the given area.\r\n     * @param {Object} box The area to search in\r\n     * @returns {Object} the result {codeResult, line, angle, pattern, threshold}\r\n     */\r\n\r\n\r\n    function _decodeFromImage() {\r\n      _decodeFromImage = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee2(imageWrapper) {\r\n        var result, _iterator, _step, reader;\r\n\r\n        return regenerator_default.a.wrap(function _callee2$(_context2) {\r\n          while (1) {\r\n            switch (_context2.prev = _context2.next) {\r\n              case 0:\r\n                result = null;\r\n                _iterator = _createForOfIteratorHelper(_barcodeReaders);\r\n                _context2.prev = 2;\r\n\r\n                _iterator.s();\r\n\r\n              case 4:\r\n                if ((_step = _iterator.n()).done) {\r\n                  _context2.next = 14;\r\n                  break;\r\n                }\r\n\r\n                reader = _step.value;\r\n\r\n                if (!reader.decodeImage) {\r\n                  _context2.next = 12;\r\n                  break;\r\n                }\r\n\r\n                _context2.next = 9;\r\n                return reader.decodeImage(imageWrapper);\r\n\r\n              case 9:\r\n                result = _context2.sent;\r\n\r\n                if (!result) {\r\n                  _context2.next = 12;\r\n                  break;\r\n                }\r\n\r\n                return _context2.abrupt(\"break\", 14);\r\n\r\n              case 12:\r\n                _context2.next = 4;\r\n                break;\r\n\r\n              case 14:\r\n                _context2.next = 19;\r\n                break;\r\n\r\n              case 16:\r\n                _context2.prev = 16;\r\n                _context2.t0 = _context2[\"catch\"](2);\r\n\r\n                _iterator.e(_context2.t0);\r\n\r\n              case 19:\r\n                _context2.prev = 19;\r\n\r\n                _iterator.f();\r\n\r\n                return _context2.finish(19);\r\n\r\n              case 22:\r\n                return _context2.abrupt(\"return\", result);\r\n\r\n              case 23:\r\n              case \"end\":\r\n                return _context2.stop();\r\n            }\r\n          }\r\n        }, _callee2, null, [[2, 16, 19, 22]]);\r\n      }));\r\n      return _decodeFromImage.apply(this, arguments);\r\n    }\r\n\r\n    function _decodeFromBoundingBox(box) {\r\n      var line;\r\n      var ctx = _canvas.ctx.overlay;\r\n      var result;\r\n\r\n      if (true) {\r\n        if (config.debug.drawBoundingBox && ctx) {\r\n          image_debug[\"a\" /* default */].drawPath(box, {\r\n            x: 0,\r\n            y: 1\r\n          }, ctx, {\r\n            color: 'blue',\r\n            lineWidth: 2\r\n          });\r\n        }\r\n      }\r\n\r\n      line = getLine(box);\r\n      var lineLength = getLineLength(line);\r\n      var lineAngle = Math.atan2(line[1].y - line[0].y, line[1].x - line[0].x);\r\n      line = getExtendedLine(line, lineAngle, Math.floor(lineLength * 0.1));\r\n\r\n      if (line === null) {\r\n        return null;\r\n      }\r\n\r\n      result = tryDecode(line);\r\n\r\n      if (result === null) {\r\n        result = tryDecodeBruteForce(box, line, lineAngle);\r\n      }\r\n\r\n      if (result === null) {\r\n        return null;\r\n      }\r\n\r\n      if (  true && result && config.debug.drawScanline && ctx) {\r\n        image_debug[\"a\" /* default */].drawPath(line, {\r\n          x: 'x',\r\n          y: 'y'\r\n        }, ctx, {\r\n          color: 'red',\r\n          lineWidth: 3\r\n        });\r\n      }\r\n\r\n      return {\r\n        codeResult: result.codeResult,\r\n        line: line,\r\n        angle: lineAngle,\r\n        pattern: result.barcodeLine.line,\r\n        threshold: result.barcodeLine.threshold\r\n      };\r\n    }\r\n\r\n    return {\r\n      decodeFromBoundingBox: function decodeFromBoundingBox(box) {\r\n        return _decodeFromBoundingBox(box);\r\n      },\r\n      decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {\r\n        var i;\r\n        var result;\r\n        var barcodes = [];\r\n        var multiple = config.multiple;\r\n\r\n        for (i = 0; i < boxes.length; i++) {\r\n          var box = boxes[i];\r\n          result = _decodeFromBoundingBox(box) || {};\r\n          result.box = box;\r\n\r\n          if (multiple) {\r\n            barcodes.push(result);\r\n          } else if (result.codeResult) {\r\n            return result;\r\n          }\r\n        }\r\n\r\n        return {\r\n          barcodes: barcodes\r\n        };\r\n      },\r\n      decodeFromImage: function decodeFromImage(imageWrapperIn) {\r\n        return asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {\r\n          var result;\r\n          return regenerator_default.a.wrap(function _callee$(_context) {\r\n            while (1) {\r\n              switch (_context.prev = _context.next) {\r\n                case 0:\r\n                  _context.next = 2;\r\n                  return _decodeFromImage2(imageWrapperIn);\r\n\r\n                case 2:\r\n                  result = _context.sent;\r\n                  return _context.abrupt(\"return\", result);\r\n\r\n                case 4:\r\n                case \"end\":\r\n                  return _context.stop();\r\n              }\r\n            }\r\n          }, _callee);\r\n        }))();\r\n      },\r\n      registerReader: function registerReader(name, reader) {\r\n        if (READERS[name]) {\r\n          throw new Error('cannot register existing reader', name);\r\n        }\r\n\r\n        READERS[name] = reader;\r\n      },\r\n      setReaders: function setReaders(readers) {\r\n        // eslint-disable-next-line no-param-reassign\r\n        config.readers = readers;\r\n        _barcodeReaders.length = 0;\r\n        initReaders();\r\n      }\r\n    };\r\n  }\r\n});\r\n// CONCATENATED MODULE: ./src/reader/index.ts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// CONCATENATED MODULE: ./src/common/events.ts\r\n/* harmony default export */ var events = ((function EventInterface() {\r\n  var events = {};\r\n\r\n  function getEvent(eventName) {\r\n    if (!events[eventName]) {\r\n      events[eventName] = {\r\n        subscribers: []\r\n      };\r\n    }\r\n\r\n    return events[eventName];\r\n  }\r\n\r\n  function clearEvents() {\r\n    events = {};\r\n  }\r\n\r\n  function publishSubscription(subscription, data) {\r\n    if (subscription.async) {\r\n      setTimeout(function () {\r\n        subscription.callback(data);\r\n      }, 4);\r\n    } else {\r\n      subscription.callback(data);\r\n    }\r\n  }\r\n\r\n  function _subscribe(event, callback, async) {\r\n    var subscription;\r\n\r\n    if (typeof callback === 'function') {\r\n      subscription = {\r\n        callback: callback,\r\n        async: async\r\n      };\r\n    } else {\r\n      subscription = callback;\r\n\r\n      if (!subscription.callback) {\r\n        throw new Error('Callback was not specified on options');\r\n      }\r\n    }\r\n\r\n    getEvent(event).subscribers.push(subscription);\r\n  }\r\n\r\n  return {\r\n    subscribe: function subscribe(event, callback, async) {\r\n      return _subscribe(event, callback, async);\r\n    },\r\n    publish: function publish(eventName, data) {\r\n      var event = getEvent(eventName);\r\n      var subscribers = event.subscribers; // Publish one-time subscriptions\r\n\r\n      subscribers.filter(function (subscriber) {\r\n        return !!subscriber.once;\r\n      }).forEach(function (subscriber) {\r\n        publishSubscription(subscriber, data);\r\n      }); // remove them from the subscriber\r\n\r\n      event.subscribers = subscribers.filter(function (subscriber) {\r\n        return !subscriber.once;\r\n      }); // publish the rest\r\n\r\n      event.subscribers.forEach(function (subscriber) {\r\n        publishSubscription(subscriber, data);\r\n      });\r\n    },\r\n    once: function once(event, callback) {\r\n      var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n\r\n      _subscribe(event, {\r\n        callback: callback,\r\n        async: async,\r\n        once: true\r\n      });\r\n    },\r\n    unsubscribe: function unsubscribe(eventName, callback) {\r\n      if (eventName) {\r\n        var _event = getEvent(eventName);\r\n\r\n        if (_event && callback) {\r\n          _event.subscribers = _event.subscribers.filter(function (subscriber) {\r\n            return subscriber.callback !== callback;\r\n          });\r\n        } else {\r\n          _event.subscribers = [];\r\n        }\r\n      } else {\r\n        clearEvents();\r\n      }\r\n    }\r\n  };\r\n})());\r\n// EXTERNAL MODULE: ./node_modules/lodash/pick.js\r\nvar pick = __nested_webpack_require_266069__(85);\r\nvar pick_default = /*#__PURE__*/__nested_webpack_require_266069__.n(pick);\r\n\r\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/wrapNativeSuper.js\r\nvar wrapNativeSuper = __nested_webpack_require_266069__(86);\r\nvar wrapNativeSuper_default = /*#__PURE__*/__nested_webpack_require_266069__.n(wrapNativeSuper);\r\n\r\n// CONCATENATED MODULE: ./src/quagga/Exception.ts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction Exception_createSuper(Derived) { var hasNativeReflectConstruct = Exception_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }\r\n\r\nfunction Exception_isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\r\n\r\nvar Exception_Exception = /*#__PURE__*/function (_Error) {\r\n  inherits_default()(Exception, _Error);\r\n\r\n  var _super = Exception_createSuper(Exception);\r\n\r\n  function Exception(m, code) {\r\n    var _this;\r\n\r\n    classCallCheck_default()(this, Exception);\r\n\r\n    _this = _super.call(this, m);\r\n\r\n    defineProperty_default()(assertThisInitialized_default()(_this), \"code\", void 0);\r\n\r\n    _this.code = code;\r\n    Object.setPrototypeOf(assertThisInitialized_default()(_this), Exception.prototype);\r\n    return _this;\r\n  }\r\n\r\n  return createClass_default()(Exception);\r\n}( /*#__PURE__*/wrapNativeSuper_default()(Error));\r\n\r\n\r\n// CONCATENATED MODULE: ./src/common/mediaDevices.ts\r\n\r\nvar ERROR_DESC = 'This may mean that the user has declined camera access, or the browser does not support media APIs. If you are running in iOS, you must use Safari.';\r\nfunction enumerateDevices() {\r\n  try {\r\n    return navigator.mediaDevices.enumerateDevices();\r\n  } catch (err) {\r\n    var error = new Exception_Exception(\"enumerateDevices is not defined. \".concat(ERROR_DESC), -1);\r\n    return Promise.reject(error);\r\n  }\r\n}\r\nfunction getUserMedia(constraints) {\r\n  try {\r\n    return navigator.mediaDevices.getUserMedia(constraints);\r\n  } catch (err) {\r\n    var error = new Exception_Exception(\"getUserMedia is not defined. \".concat(ERROR_DESC), -1);\r\n    return Promise.reject(error);\r\n  }\r\n}\r\n// CONCATENATED MODULE: ./src/input/camera_access.ts\r\n\r\n\r\n// TODO: when this file was written years ago, HTMLMediaElement.play() did not return a useful value\r\n// to let us know when the video started playing.  Now, it does.  So, we shouldn't need to run this\r\n// odd waitForVideo() function that polls to see if the video has started.\r\n\r\n\r\n\r\nvar streamRef;\r\n\r\nfunction waitForVideo(video) {\r\n  return new Promise(function (resolve, reject) {\r\n    var attempts = 10;\r\n\r\n    function checkVideo() {\r\n      if (attempts > 0) {\r\n        if (video.videoWidth > 10 && video.videoHeight > 10) {\r\n          if (true) {\r\n            console.log(\"* dev: checkVideo found \".concat(video.videoWidth, \"px x \").concat(video.videoHeight, \"px\"));\r\n          }\r\n\r\n          resolve();\r\n        } else {\r\n          window.setTimeout(checkVideo, 500);\r\n        }\r\n      } else {\r\n        reject(new Exception_Exception('Unable to play video stream. Is webcam working?', -1)); // TODO: add error code\r\n      }\r\n\r\n      attempts--;\r\n    }\r\n\r\n    checkVideo();\r\n  });\r\n}\r\n/**\r\n * Tries to attach the camera-stream to a given video-element\r\n * and calls the callback function when the content is ready\r\n * @param {Object} constraints\r\n * @param {Object} video\r\n */\r\n\r\n\r\nfunction initCamera(_x, _x2) {\r\n  return _initCamera.apply(this, arguments);\r\n}\r\n\r\nfunction _initCamera() {\r\n  _initCamera = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee4(video, constraints) {\r\n    var stream;\r\n    return regenerator_default.a.wrap(function _callee4$(_context4) {\r\n      while (1) {\r\n        switch (_context4.prev = _context4.next) {\r\n          case 0:\r\n            _context4.next = 2;\r\n            return getUserMedia(constraints);\r\n\r\n          case 2:\r\n            stream = _context4.sent;\r\n            streamRef = stream;\r\n\r\n            if (!video) {\r\n              _context4.next = 11;\r\n              break;\r\n            }\r\n\r\n            video.setAttribute('autoplay', 'true');\r\n            video.setAttribute('muted', 'true');\r\n            video.setAttribute('playsinline', 'true'); // not listed on MDN...\r\n            // eslint-disable-next-line no-param-reassign\r\n\r\n            video.srcObject = stream;\r\n            video.addEventListener('loadedmetadata', function () {\r\n              video.play()[\"catch\"](function (err) {\r\n                console.warn('* Error while trying to play video stream:', err);\r\n              });\r\n            });\r\n            return _context4.abrupt(\"return\", waitForVideo(video));\r\n\r\n          case 11:\r\n            return _context4.abrupt(\"return\", Promise.resolve());\r\n\r\n          case 12:\r\n          case \"end\":\r\n            return _context4.stop();\r\n        }\r\n      }\r\n    }, _callee4);\r\n  }));\r\n  return _initCamera.apply(this, arguments);\r\n}\r\n\r\nfunction deprecatedConstraints(videoConstraints) {\r\n  var normalized = pick_default()(videoConstraints, ['width', 'height', 'facingMode', 'aspectRatio', 'deviceId']);\r\n\r\n  if (typeof videoConstraints.minAspectRatio !== 'undefined' && videoConstraints.minAspectRatio > 0) {\r\n    normalized.aspectRatio = videoConstraints.minAspectRatio;\r\n    console.log('WARNING: Constraint \\'minAspectRatio\\' is deprecated; Use \\'aspectRatio\\' instead');\r\n  }\r\n\r\n  if (typeof videoConstraints.facing !== 'undefined') {\r\n    normalized.facingMode = videoConstraints.facing;\r\n    console.log('WARNING: Constraint \\'facing\\' is deprecated. Use \\'facingMode\\' instead\\'');\r\n  }\r\n\r\n  return normalized;\r\n} // TODO: #192 I don't think there's any good reason pickConstraints should return a Promise,\r\n// I think it was just that way so it could be chained to other functions that did return a Promise.\r\n// That's not necessary with async functions being a thing, so that should be fixed.\r\n\r\n\r\nfunction pickConstraints() {\r\n  var videoConstraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n  var video = deprecatedConstraints(videoConstraints);\r\n\r\n  if (video && video.deviceId && video.facingMode) {\r\n    delete video.facingMode;\r\n  }\r\n\r\n  return Promise.resolve({\r\n    audio: false,\r\n    video: video\r\n  });\r\n}\r\n\r\nfunction enumerateVideoDevices() {\r\n  return _enumerateVideoDevices.apply(this, arguments);\r\n}\r\n\r\nfunction _enumerateVideoDevices() {\r\n  _enumerateVideoDevices = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee5() {\r\n    var devices;\r\n    return regenerator_default.a.wrap(function _callee5$(_context5) {\r\n      while (1) {\r\n        switch (_context5.prev = _context5.next) {\r\n          case 0:\r\n            _context5.next = 2;\r\n            return enumerateDevices();\r\n\r\n          case 2:\r\n            devices = _context5.sent;\r\n            return _context5.abrupt(\"return\", devices.filter(function (device) {\r\n              return device.kind === 'videoinput';\r\n            }));\r\n\r\n          case 4:\r\n          case \"end\":\r\n            return _context5.stop();\r\n        }\r\n      }\r\n    }, _callee5);\r\n  }));\r\n  return _enumerateVideoDevices.apply(this, arguments);\r\n}\r\n\r\nfunction getActiveTrack() {\r\n  if (!streamRef) {\r\n    return null;\r\n  }\r\n\r\n  var tracks = streamRef.getVideoTracks();\r\n  return tracks && tracks !== null && tracks !== void 0 && tracks.length ? tracks[0] : null;\r\n}\r\n/**\r\n * Used for accessing information about the active stream track and available video devices.\r\n */\r\n\r\n\r\nvar QuaggaJSCameraAccess = {\r\n  requestedVideoElement: null,\r\n  request: function request(video, videoConstraints) {\r\n    return asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {\r\n      var newConstraints;\r\n      return regenerator_default.a.wrap(function _callee$(_context) {\r\n        while (1) {\r\n          switch (_context.prev = _context.next) {\r\n            case 0:\r\n              QuaggaJSCameraAccess.requestedVideoElement = video;\r\n              _context.next = 3;\r\n              return pickConstraints(videoConstraints);\r\n\r\n            case 3:\r\n              newConstraints = _context.sent;\r\n              return _context.abrupt(\"return\", initCamera(video, newConstraints));\r\n\r\n            case 5:\r\n            case \"end\":\r\n              return _context.stop();\r\n          }\r\n        }\r\n      }, _callee);\r\n    }))();\r\n  },\r\n  release: function release() {\r\n    var tracks = streamRef && streamRef.getVideoTracks();\r\n\r\n    if (QuaggaJSCameraAccess.requestedVideoElement !== null) {\r\n      QuaggaJSCameraAccess.requestedVideoElement.pause();\r\n    }\r\n\r\n    return new Promise(function (resolve) {\r\n      setTimeout(function () {\r\n        if (tracks && tracks.length) {\r\n          tracks[0].stop();\r\n        }\r\n\r\n        streamRef = null;\r\n        QuaggaJSCameraAccess.requestedVideoElement = null;\r\n        resolve();\r\n      }, 0);\r\n    });\r\n  },\r\n  enumerateVideoDevices: enumerateVideoDevices,\r\n  getActiveStreamLabel: function getActiveStreamLabel() {\r\n    var track = getActiveTrack();\r\n    return track ? track.label : '';\r\n  },\r\n  getActiveTrack: getActiveTrack,\r\n  disableTorch: function disableTorch() {\r\n    return asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee2() {\r\n      var track;\r\n      return regenerator_default.a.wrap(function _callee2$(_context2) {\r\n        while (1) {\r\n          switch (_context2.prev = _context2.next) {\r\n            case 0:\r\n              track = getActiveTrack(); // TODO: should we acquire camera access even if there's no current camera open?\r\n              // TODO: what happens on iOS or another device where torch isn't supported at all? Should we throw an error?\r\n\r\n              if (!track) {\r\n                _context2.next = 4;\r\n                break;\r\n              }\r\n\r\n              _context2.next = 4;\r\n              return track.applyConstraints({\r\n                advanced: [{\r\n                  torch: false\r\n                }]\r\n              });\r\n\r\n            case 4:\r\n            case \"end\":\r\n              return _context2.stop();\r\n          }\r\n        }\r\n      }, _callee2);\r\n    }))();\r\n  },\r\n  enableTorch: function enableTorch() {\r\n    return asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee3() {\r\n      var track;\r\n      return regenerator_default.a.wrap(function _callee3$(_context3) {\r\n        while (1) {\r\n          switch (_context3.prev = _context3.next) {\r\n            case 0:\r\n              track = getActiveTrack(); // TODO: should we acquire camera access even if there's no current camera open?\r\n              // TODO: what happens on iOS or another device where torch isn't supported at all? Should we throw an error?\r\n\r\n              if (!track) {\r\n                _context3.next = 4;\r\n                break;\r\n              }\r\n\r\n              _context3.next = 4;\r\n              return track.applyConstraints({\r\n                advanced: [{\r\n                  torch: true\r\n                }]\r\n              });\r\n\r\n            case 4:\r\n            case \"end\":\r\n              return _context3.stop();\r\n          }\r\n        }\r\n      }, _callee3);\r\n    }))();\r\n  }\r\n};\r\n/* harmony default export */ var camera_access = (QuaggaJSCameraAccess);\r\n// CONCATENATED MODULE: ./src/analytics/result_collector.ts\r\n\r\n\r\nfunction contains(codeResult, list) {\r\n  return list && list.some(function (item) {\r\n    var keys = Object.keys(item);\r\n    return keys.every(function (key) {\r\n      return item[key] === codeResult[key];\r\n    });\r\n  });\r\n}\r\n\r\nfunction passesFilter(codeResult, filter) {\r\n  return typeof filter === 'function' ? filter(codeResult) : true;\r\n}\r\n\r\n/* harmony default export */ var result_collector = ({\r\n  create: function create(config) {\r\n    var _config$capacity;\r\n\r\n    var canvas = document.createElement('canvas');\r\n    var ctx = canvas.getContext('2d');\r\n    var results = [];\r\n    var capacity = (_config$capacity = config.capacity) !== null && _config$capacity !== void 0 ? _config$capacity : 20;\r\n    var capture = config.capture === true;\r\n\r\n    function matchesConstraints(codeResult) {\r\n      return !!capacity && codeResult && !contains(codeResult, config.blacklist) && passesFilter(codeResult, config.filter);\r\n    }\r\n\r\n    return {\r\n      addResult: function addResult(data, imageSize, codeResult) {\r\n        var result = {}; // this is 'any' to avoid having to construct a whole QuaggaJSCodeResult :|\r\n\r\n        if (matchesConstraints(codeResult)) {\r\n          capacity--;\r\n          result.codeResult = codeResult;\r\n\r\n          if (capture) {\r\n            canvas.width = imageSize.x;\r\n            canvas.height = imageSize.y;\r\n            image_debug[\"a\" /* default */].drawImage(data, imageSize, ctx);\r\n            result.frame = canvas.toDataURL();\r\n          }\r\n\r\n          results.push(result);\r\n        }\r\n      },\r\n      getResults: function getResults() {\r\n        return results;\r\n      }\r\n    };\r\n  }\r\n});\r\n// CONCATENATED MODULE: ./src/config/config.dev.ts\r\nvar DevConfig = {\r\n  inputStream: {\r\n    name: 'Live',\r\n    type: 'LiveStream',\r\n    constraints: {\r\n      width: 640,\r\n      height: 480,\r\n      // aspectRatio: 640/480, // optional\r\n      facingMode: 'environment' // or user\r\n      // deviceId: \"38745983457387598375983759834\"\r\n\r\n    },\r\n    area: {\r\n      top: '0%',\r\n      right: '0%',\r\n      left: '0%',\r\n      bottom: '0%'\r\n    },\r\n    singleChannel: false // true: only the red color-channel is read\r\n\r\n  },\r\n  locate: true,\r\n  numOfWorkers: 0,\r\n  decoder: {\r\n    readers: ['code_128_reader'],\r\n    debug: {\r\n      drawBoundingBox: false,\r\n      showFrequency: false,\r\n      drawScanline: false,\r\n      showPattern: false\r\n    }\r\n  },\r\n  locator: {\r\n    halfSample: true,\r\n    patchSize: 'medium',\r\n    // x-small, small, medium, large, x-large\r\n    debug: {\r\n      showCanvas: false,\r\n      showPatches: false,\r\n      showFoundPatches: false,\r\n      showSkeleton: false,\r\n      showLabels: false,\r\n      showPatchLabels: false,\r\n      showRemainingPatchLabels: false,\r\n      boxFromPatches: {\r\n        showTransformed: false,\r\n        showTransformedBox: false,\r\n        showBB: false\r\n      }\r\n    }\r\n  }\r\n};\r\n/* harmony default export */ var config_dev = (DevConfig);\r\n// CONCATENATED MODULE: ./src/config/config.node.ts\r\nvar NodeConfig = {\r\n  inputStream: {\r\n    type: 'ImageStream',\r\n    sequence: false,\r\n    size: 800,\r\n    area: {\r\n      top: '0%',\r\n      right: '0%',\r\n      left: '0%',\r\n      bottom: '0%'\r\n    },\r\n    singleChannel: false // true: only the red color-channel is read\r\n\r\n  },\r\n  locate: true,\r\n  numOfWorkers: 0,\r\n  decoder: {\r\n    readers: ['code_128_reader']\r\n  },\r\n  locator: {\r\n    halfSample: true,\r\n    patchSize: 'medium' // x-small, small, medium, large, x-large\r\n\r\n  }\r\n};\r\n/* harmony default export */ var config_node = (NodeConfig);\r\n// CONCATENATED MODULE: ./src/config/config.prod.ts\r\nvar ProdConfig = {\r\n  inputStream: {\r\n    name: 'Live',\r\n    type: 'LiveStream',\r\n    constraints: {\r\n      width: 640,\r\n      height: 480,\r\n      // aspectRatio: 640/480, // optional\r\n      facingMode: 'environment' // or user\r\n      // deviceId: \"38745983457387598375983759834\"\r\n\r\n    },\r\n    area: {\r\n      top: '0%',\r\n      right: '0%',\r\n      left: '0%',\r\n      bottom: '0%'\r\n    },\r\n    singleChannel: false // true: only the red color-channel is read\r\n\r\n  },\r\n  locate: true,\r\n  numOfWorkers: 4,\r\n  decoder: {\r\n    readers: ['code_128_reader']\r\n  },\r\n  locator: {\r\n    halfSample: true,\r\n    patchSize: 'medium' // x-small, small, medium, large, x-large\r\n\r\n  }\r\n};\r\n/* harmony default export */ var config_prod = (ProdConfig);\r\n// CONCATENATED MODULE: ./src/config/config.ts\r\n\r\n\r\n // @ts-ignore // TODO: this produces a bizarre typescript error\r\n// eslint-disable-next-line no-nested-ternary\r\n\r\nvar QuaggaConfig =   true ? config_dev : 0;\r\n/* harmony default export */ var config_config = (QuaggaConfig);\r\n// EXTERNAL MODULE: ./node_modules/gl-vec2/index.js\r\nvar gl_vec2 = __nested_webpack_require_266069__(7);\r\n\r\n// EXTERNAL MODULE: ./src/common/cv_utils.js + 1 modules\r\nvar cv_utils = __nested_webpack_require_266069__(9);\r\n\r\n// CONCATENATED MODULE: ./src/input/frame_grabber_browser.js\r\n// NOTE FOR ANYONE IN HERE IN THE FUTURE:\r\n// webpack.config.js replaces the frame_grabber module with THIS module when it is building for a Browser environment.\r\n\r\nvar TO_RADIANS = Math.PI / 180;\r\n\r\nfunction adjustCanvasSize(canvas, targetSize) {\r\n  if (canvas.width !== targetSize.x) {\r\n    if (true) {\r\n      console.log('WARNING: canvas-size needs to be adjusted');\r\n    }\r\n\r\n    canvas.width = targetSize.x;\r\n  }\r\n\r\n  if (canvas.height !== targetSize.y) {\r\n    if (true) {\r\n      console.log('WARNING: canvas-size needs to be adjusted');\r\n    }\r\n\r\n    canvas.height = targetSize.y;\r\n  }\r\n}\r\n\r\nvar FrameGrabber = {};\r\n\r\nFrameGrabber.create = function (inputStream, canvas) {\r\n  var _that = {};\r\n\r\n  var _streamConfig = inputStream.getConfig();\r\n\r\n  var _videoSize = Object(cv_utils[\"h\" /* imageRef */])(inputStream.getRealWidth(), inputStream.getRealHeight());\r\n\r\n  var _canvasSize = inputStream.getCanvasSize();\r\n\r\n  var _size = Object(cv_utils[\"h\" /* imageRef */])(inputStream.getWidth(), inputStream.getHeight());\r\n\r\n  var topRight = inputStream.getTopRight();\r\n  var _sx = topRight.x;\r\n  var _sy = topRight.y;\r\n\r\n  var _canvas;\r\n\r\n  var _ctx = null;\r\n  var _data = null;\r\n  _canvas = canvas || document.createElement('canvas');\r\n  _canvas.width = _canvasSize.x;\r\n  _canvas.height = _canvasSize.y;\r\n  _ctx = _canvas.getContext('2d');\r\n  _data = new Uint8Array(_size.x * _size.y);\r\n\r\n  if (true) {\r\n    console.log('FrameGrabber', JSON.stringify({\r\n      size: _size,\r\n      topRight: topRight,\r\n      videoSize: _videoSize,\r\n      canvasSize: _canvasSize\r\n    }));\r\n  }\r\n  /**\r\n   * Uses the given array as frame-buffer\r\n   */\r\n\r\n\r\n  _that.attachData = function (data) {\r\n    _data = data;\r\n  };\r\n  /**\r\n   * Returns the used frame-buffer\r\n   */\r\n\r\n\r\n  _that.getData = function () {\r\n    return _data;\r\n  };\r\n  /**\r\n   * Fetches a frame from the input-stream and puts into the frame-buffer.\r\n   * The image-data is converted to gray-scale and then half-sampled if configured.\r\n   */\r\n\r\n\r\n  _that.grab = function () {\r\n    var doHalfSample = _streamConfig.halfSample;\r\n    var frame = inputStream.getFrame();\r\n    var drawable = frame;\r\n    var drawAngle = 0;\r\n    var ctxData;\r\n\r\n    if (drawable) {\r\n      adjustCanvasSize(_canvas, _canvasSize);\r\n\r\n      if (_streamConfig.type === 'ImageStream') {\r\n        drawable = frame.img;\r\n\r\n        if (frame.tags && frame.tags.orientation) {\r\n          switch (frame.tags.orientation) {\r\n            case 6:\r\n              drawAngle = 90 * TO_RADIANS;\r\n              break;\r\n\r\n            case 8:\r\n              drawAngle = -90 * TO_RADIANS;\r\n              break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (drawAngle !== 0) {\r\n        _ctx.translate(_canvasSize.x / 2, _canvasSize.y / 2);\r\n\r\n        _ctx.rotate(drawAngle);\r\n\r\n        _ctx.drawImage(drawable, -_canvasSize.y / 2, -_canvasSize.x / 2, _canvasSize.y, _canvasSize.x);\r\n\r\n        _ctx.rotate(-drawAngle);\r\n\r\n        _ctx.translate(-_canvasSize.x / 2, -_canvasSize.y / 2);\r\n      } else {\r\n        _ctx.drawImage(drawable, 0, 0, _canvasSize.x, _canvasSize.y);\r\n      }\r\n\r\n      ctxData = _ctx.getImageData(_sx, _sy, _size.x, _size.y).data;\r\n\r\n      if (doHalfSample) {\r\n        Object(cv_utils[\"e\" /* grayAndHalfSampleFromCanvasData */])(ctxData, _size, _data);\r\n      } else {\r\n        Object(cv_utils[\"c\" /* computeGray */])(ctxData, _data, _streamConfig);\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  };\r\n\r\n  _that.getSize = function () {\r\n    return _size;\r\n  };\r\n\r\n  return _that;\r\n};\r\n\r\n/* harmony default export */ var frame_grabber_browser = (FrameGrabber);\r\n// CONCATENATED MODULE: ./src/input/exif_helper.js\r\n// NOTE: (SOME OF) THIS IS BROWSER ONLY CODE.  Node does not have 'atob' built in, nor XMLHttpRequest.\r\n// How exactly is this set of functions used in Quagga? Do we need the browser specific code? Do we\r\n// need to port any part of this that doesn't work in Node to node?\r\n// Tags scraped from https://github.com/exif-js/exif-js\r\nvar ExifTags = {\r\n  0x0112: 'orientation'\r\n};\r\nvar AvailableTags = Object.keys(ExifTags).map(function (key) {\r\n  return ExifTags[key];\r\n});\r\nfunction findTagsInObjectURL(src) {\r\n  var tags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;\r\n\r\n  if (/^blob:/i.test(src)) {\r\n    return objectURLToBlob(src).then(readToBuffer).then(function (buffer) {\r\n      return findTagsInBuffer(buffer, tags);\r\n    });\r\n  }\r\n\r\n  return Promise.resolve(null);\r\n}\r\nfunction base64ToArrayBuffer(dataUrl) {\r\n  var base64 = dataUrl.replace(/^data:([^;]+);base64,/gmi, '');\r\n  var binary = atob(base64);\r\n  var len = binary.length;\r\n  var buffer = new ArrayBuffer(len);\r\n  var view = new Uint8Array(buffer);\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    view[i] = binary.charCodeAt(i);\r\n  }\r\n\r\n  return buffer;\r\n}\r\n\r\nfunction readToBuffer(blob) {\r\n  return new Promise(function (resolve) {\r\n    var fileReader = new FileReader();\r\n\r\n    fileReader.onload = function (e) {\r\n      return resolve(e.target.result);\r\n    };\r\n\r\n    fileReader.readAsArrayBuffer(blob);\r\n  });\r\n}\r\n\r\nfunction objectURLToBlob(url) {\r\n  return new Promise(function (resolve, reject) {\r\n    var http = new XMLHttpRequest();\r\n    http.open('GET', url, true);\r\n    http.responseType = 'blob';\r\n\r\n    http.onreadystatechange = function () {\r\n      if (http.readyState === XMLHttpRequest.DONE && (http.status === 200 || http.status === 0)) {\r\n        resolve(this.response);\r\n      }\r\n    };\r\n\r\n    http.onerror = reject;\r\n    http.send();\r\n  });\r\n}\r\n\r\nfunction findTagsInBuffer(file) {\r\n  var selectedTags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;\r\n  var dataView = new DataView(file);\r\n  var length = file.byteLength;\r\n  var exifTags = selectedTags.reduce(function (result, selectedTag) {\r\n    var exifTag = Object.keys(ExifTags).filter(function (tag) {\r\n      return ExifTags[tag] === selectedTag;\r\n    })[0];\r\n\r\n    if (exifTag) {\r\n      result[exifTag] = selectedTag;\r\n    }\r\n\r\n    return result;\r\n  }, {});\r\n  var offset = 2;\r\n  var marker;\r\n\r\n  if (dataView.getUint8(0) !== 0xFF || dataView.getUint8(1) !== 0xD8) {\r\n    return false;\r\n  }\r\n\r\n  while (offset < length) {\r\n    if (dataView.getUint8(offset) !== 0xFF) {\r\n      return false;\r\n    }\r\n\r\n    marker = dataView.getUint8(offset + 1);\r\n\r\n    if (marker === 0xE1) {\r\n      return readEXIFData(dataView, offset + 4, exifTags);\r\n    }\r\n\r\n    offset += 2 + dataView.getUint16(offset + 2);\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction readEXIFData(file, start, exifTags) {\r\n  if (getStringFromBuffer(file, start, 4) !== 'Exif') {\r\n    return false;\r\n  }\r\n\r\n  var tiffOffset = start + 6;\r\n  var bigEnd;\r\n\r\n  if (file.getUint16(tiffOffset) === 0x4949) {\r\n    bigEnd = false;\r\n  } else if (file.getUint16(tiffOffset) === 0x4D4D) {\r\n    bigEnd = true;\r\n  } else {\r\n    return false;\r\n  }\r\n\r\n  if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002A) {\r\n    return false;\r\n  }\r\n\r\n  var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);\r\n\r\n  if (firstIFDOffset < 0x00000008) {\r\n    return false;\r\n  }\r\n\r\n  var tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, exifTags, bigEnd);\r\n  return tags;\r\n}\r\n\r\nfunction readTags(file, tiffStart, dirStart, strings, bigEnd) {\r\n  var entries = file.getUint16(dirStart, !bigEnd);\r\n  var tags = {};\r\n\r\n  for (var i = 0; i < entries; i++) {\r\n    var entryOffset = dirStart + i * 12 + 2;\r\n    var tag = strings[file.getUint16(entryOffset, !bigEnd)];\r\n\r\n    if (tag) {\r\n      tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);\r\n    }\r\n  }\r\n\r\n  return tags;\r\n}\r\n\r\nfunction readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {\r\n  var type = file.getUint16(entryOffset + 2, !bigEnd);\r\n  var numValues = file.getUint32(entryOffset + 4, !bigEnd);\r\n\r\n  switch (type) {\r\n    case 3:\r\n      if (numValues === 1) {\r\n        return file.getUint16(entryOffset + 8, !bigEnd);\r\n      }\r\n\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction getStringFromBuffer(buffer, start, length) {\r\n  var outstr = '';\r\n\r\n  for (var n = start; n < start + length; n++) {\r\n    outstr += String.fromCharCode(buffer.getUint8(n));\r\n  }\r\n\r\n  return outstr;\r\n}\r\n// CONCATENATED MODULE: ./src/input/image_loader.js\r\n\r\nvar ImageLoader = {};\r\n\r\nImageLoader.load = function (directory, callback, offset, size, sequence) {\r\n  var htmlImagesSrcArray = new Array(size);\r\n  var htmlImagesArray = new Array(htmlImagesSrcArray.length);\r\n  var i;\r\n  var img;\r\n  var num;\r\n\r\n  if (sequence === false) {\r\n    htmlImagesSrcArray[0] = directory;\r\n  } else {\r\n    for (i = 0; i < htmlImagesSrcArray.length; i++) {\r\n      num = offset + i;\r\n      htmlImagesSrcArray[i] = \"\".concat(directory, \"image-\").concat(\"00\".concat(num).slice(-3), \".jpg\");\r\n    }\r\n  }\r\n\r\n  htmlImagesArray.notLoaded = [];\r\n\r\n  htmlImagesArray.addImage = function (image) {\r\n    htmlImagesArray.notLoaded.push(image);\r\n  };\r\n\r\n  htmlImagesArray.loaded = function (loadedImg) {\r\n    var notloadedImgs = htmlImagesArray.notLoaded;\r\n\r\n    for (var x = 0; x < notloadedImgs.length; x++) {\r\n      if (notloadedImgs[x] === loadedImg) {\r\n        notloadedImgs.splice(x, 1);\r\n\r\n        for (var y = 0; y < htmlImagesSrcArray.length; y++) {\r\n          var imgName = htmlImagesSrcArray[y].substr(htmlImagesSrcArray[y].lastIndexOf('/'));\r\n\r\n          if (loadedImg.src.lastIndexOf(imgName) !== -1) {\r\n            htmlImagesArray[y] = {\r\n              img: loadedImg\r\n            };\r\n            break;\r\n          }\r\n        }\r\n\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (notloadedImgs.length === 0) {\r\n      if (true) {\r\n        console.log('Images loaded');\r\n      }\r\n\r\n      if (sequence === false) {\r\n        findTagsInObjectURL(directory, ['orientation']).then(function (tags) {\r\n          htmlImagesArray[0].tags = tags;\r\n          callback(htmlImagesArray);\r\n        })[\"catch\"](function (e) {\r\n          console.log(e);\r\n          callback(htmlImagesArray);\r\n        });\r\n      } else {\r\n        callback(htmlImagesArray);\r\n      }\r\n    }\r\n  };\r\n\r\n  for (i = 0; i < htmlImagesSrcArray.length; i++) {\r\n    img = new Image();\r\n    htmlImagesArray.addImage(img);\r\n    addOnloadHandler(img, htmlImagesArray);\r\n    img.src = htmlImagesSrcArray[i];\r\n  }\r\n};\r\n\r\nfunction addOnloadHandler(img, htmlImagesArray) {\r\n  img.onload = function () {\r\n    htmlImagesArray.loaded(this);\r\n  };\r\n}\r\n\r\n/* harmony default export */ var image_loader = (ImageLoader);\r\n// CONCATENATED MODULE: ./src/input/input_stream/input_stream_browser.ts\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\n\r\nvar inputStreamFactory = {\r\n  createVideoStream: function createVideoStream(video) {\r\n    var _config = null;\r\n    var _eventNames = ['canrecord', 'ended'];\r\n    var _eventHandlers = {};\r\n\r\n    var _calculatedWidth;\r\n\r\n    var _calculatedHeight;\r\n\r\n    var _topRight = {\r\n      x: 0,\r\n      y: 0,\r\n      type: 'Point'\r\n    };\r\n    var _canvasSize = {\r\n      x: 0,\r\n      y: 0,\r\n      type: 'XYSize'\r\n    };\r\n\r\n    function initSize() {\r\n      var _config2, _config3;\r\n\r\n      var width = video.videoWidth;\r\n      var height = video.videoHeight; // eslint-disable-next-line no-nested-ternary\r\n\r\n      _calculatedWidth = (_config2 = _config) !== null && _config2 !== void 0 && _config2.size ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary\r\n\r\n      _calculatedHeight = (_config3 = _config) !== null && _config3 !== void 0 && _config3.size ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;\r\n      _canvasSize.x = _calculatedWidth;\r\n      _canvasSize.y = _calculatedHeight;\r\n    }\r\n\r\n    var inputStream = {\r\n      getRealWidth: function getRealWidth() {\r\n        return video.videoWidth;\r\n      },\r\n      getRealHeight: function getRealHeight() {\r\n        return video.videoHeight;\r\n      },\r\n      getWidth: function getWidth() {\r\n        return _calculatedWidth;\r\n      },\r\n      getHeight: function getHeight() {\r\n        return _calculatedHeight;\r\n      },\r\n      setWidth: function setWidth(width) {\r\n        _calculatedWidth = width;\r\n      },\r\n      setHeight: function setHeight(height) {\r\n        _calculatedHeight = height;\r\n      },\r\n      setInputStream: function setInputStream(config) {\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n        _config = config; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n\r\n        this.setAttribute('src', typeof config.src !== 'undefined' ? config.src : '');\r\n      },\r\n      ended: function ended() {\r\n        return video.ended;\r\n      },\r\n      getConfig: function getConfig() {\r\n        return _config;\r\n      },\r\n      setAttribute: function setAttribute(name, value) {\r\n        if (video) {\r\n          video.setAttribute(name, value);\r\n        }\r\n      },\r\n      pause: function pause() {\r\n        video.pause();\r\n      },\r\n      play: function play() {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        video.play();\r\n      },\r\n      setCurrentTime: function setCurrentTime(time) {\r\n        var _config4;\r\n\r\n        if (((_config4 = _config) === null || _config4 === void 0 ? void 0 : _config4.type) !== 'LiveStream') {\r\n          this.setAttribute('currentTime', time.toString());\r\n        }\r\n      },\r\n      addEventListener: function addEventListener(event, f, bool) {\r\n        if (_eventNames.indexOf(event) !== -1) {\r\n          if (!_eventHandlers[event]) {\r\n            _eventHandlers[event] = [];\r\n          }\r\n\r\n          _eventHandlers[event].push(f);\r\n        } else {\r\n          video.addEventListener(event, f, bool);\r\n        }\r\n      },\r\n      clearEventHandlers: function clearEventHandlers() {\r\n        _eventNames.forEach(function (eventName) {\r\n          var handlers = _eventHandlers[eventName];\r\n\r\n          if (handlers && handlers.length > 0) {\r\n            handlers.forEach(function (handler) {\r\n              video.removeEventListener(eventName, handler);\r\n            });\r\n          }\r\n        });\r\n      },\r\n      trigger: function trigger(eventName, args) {\r\n        var j; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n\r\n        var handlers = _eventHandlers[eventName];\r\n\r\n        if (eventName === 'canrecord') {\r\n          initSize();\r\n        }\r\n\r\n        if (handlers && handlers.length > 0) {\r\n          for (j = 0; j < handlers.length; j++) {\r\n            handlers[j].apply(inputStream, args);\r\n          }\r\n        }\r\n      },\r\n      setTopRight: function setTopRight(topRight) {\r\n        _topRight.x = topRight.x;\r\n        _topRight.y = topRight.y;\r\n      },\r\n      getTopRight: function getTopRight() {\r\n        return _topRight;\r\n      },\r\n      setCanvasSize: function setCanvasSize(size) {\r\n        _canvasSize.x = size.x;\r\n        _canvasSize.y = size.y;\r\n      },\r\n      getCanvasSize: function getCanvasSize() {\r\n        return _canvasSize;\r\n      },\r\n      getFrame: function getFrame() {\r\n        return video;\r\n      }\r\n    };\r\n    return inputStream;\r\n  },\r\n  createLiveStream: function createLiveStream(video) {\r\n    if (video) {\r\n      video.setAttribute('autoplay', 'true');\r\n    }\r\n\r\n    var that = inputStreamFactory.createVideoStream(video);\r\n\r\n    that.ended = function ended() {\r\n      return false;\r\n    };\r\n\r\n    return that;\r\n  },\r\n  createImageStream: function createImageStream() {\r\n    var _config = null;\r\n    var width = 0;\r\n    var height = 0;\r\n    var frameIdx = 0;\r\n    var paused = true;\r\n    var loaded = false;\r\n    var imgArray = null;\r\n    var size = 0;\r\n    var offset = 1;\r\n    var baseUrl = null;\r\n    var _ended = false;\r\n    var calculatedWidth;\r\n    var calculatedHeight;\r\n    var _eventNames = ['canrecord', 'ended'];\r\n    var _eventHandlers = {};\r\n    var _topRight = {\r\n      x: 0,\r\n      y: 0,\r\n      type: 'Point'\r\n    };\r\n    var _canvasSize = {\r\n      x: 0,\r\n      y: 0,\r\n      type: 'XYSize'\r\n    };\r\n\r\n    function loadImages() {\r\n      var _config7;\r\n\r\n      loaded = false;\r\n      image_loader.load(baseUrl, function (imgs) {\r\n        var _config5, _config6;\r\n\r\n        imgArray = imgs; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n\r\n        if (imgs[0].tags && imgs[0].tags.orientation) {\r\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n          switch (imgs[0].tags.orientation) {\r\n            case 6:\r\n            case 8:\r\n              width = imgs[0].img.height;\r\n              height = imgs[0].img.width;\r\n              break;\r\n\r\n            default:\r\n              width = imgs[0].img.width;\r\n              height = imgs[0].img.height;\r\n          }\r\n        } else {\r\n          width = imgs[0].img.width;\r\n          height = imgs[0].img.height;\r\n        } // eslint-disable-next-line no-nested-ternary\r\n\r\n\r\n        calculatedWidth = (_config5 = _config) !== null && _config5 !== void 0 && _config5.size ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary\r\n\r\n        calculatedHeight = (_config6 = _config) !== null && _config6 !== void 0 && _config6.size ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;\r\n        _canvasSize.x = calculatedWidth;\r\n        _canvasSize.y = calculatedHeight;\r\n        loaded = true;\r\n        frameIdx = 0;\r\n        setTimeout(function () {\r\n          // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n          publishEvent('canrecord', []);\r\n        }, 0);\r\n      }, offset, size, (_config7 = _config) === null || _config7 === void 0 ? void 0 : _config7.sequence);\r\n    }\r\n\r\n    function publishEvent(eventName, args) {\r\n      var j;\r\n      var handlers = _eventHandlers[eventName];\r\n\r\n      if (handlers && handlers.length > 0) {\r\n        for (j = 0; j < handlers.length; j++) {\r\n          // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n          handlers[j].apply(inputStream, args); // TODO: typescript complains that any[] is not valid for a second arg for apply?!\r\n        }\r\n      }\r\n    } // TODO: any code shared with the first InputStream above should be shared not copied\r\n    // TODO: publishEvent needs access to inputStream, but inputStream needs access to publishEvent\r\n    // TODO: This is why it's a 'var', so it hoists back.  This is ugly, and should be changed.\r\n    // eslint-disable-next-line no-var,vars-on-top\r\n\r\n\r\n    var inputStream = {\r\n      trigger: publishEvent,\r\n      getWidth: function getWidth() {\r\n        return calculatedWidth;\r\n      },\r\n      getHeight: function getHeight() {\r\n        return calculatedHeight;\r\n      },\r\n      setWidth: function setWidth(newWidth) {\r\n        calculatedWidth = newWidth;\r\n      },\r\n      setHeight: function setHeight(newHeight) {\r\n        calculatedHeight = newHeight;\r\n      },\r\n      getRealWidth: function getRealWidth() {\r\n        return width;\r\n      },\r\n      getRealHeight: function getRealHeight() {\r\n        return height;\r\n      },\r\n      setInputStream: function setInputStream(stream) {\r\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n        _config = stream; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\r\n\r\n        if (stream.sequence === false) {\r\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access\r\n          baseUrl = stream.src;\r\n          size = 1;\r\n        } else {\r\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access\r\n          baseUrl = stream.src; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access\r\n\r\n          size = stream.length;\r\n        }\r\n\r\n        loadImages();\r\n      },\r\n      ended: function ended() {\r\n        return _ended;\r\n      },\r\n      setAttribute: function setAttribute() {},\r\n      getConfig: function getConfig() {\r\n        return _config;\r\n      },\r\n      pause: function pause() {\r\n        paused = true;\r\n      },\r\n      play: function play() {\r\n        paused = false;\r\n      },\r\n      setCurrentTime: function setCurrentTime(time) {\r\n        frameIdx = time;\r\n      },\r\n      addEventListener: function addEventListener(event, f) {\r\n        if (_eventNames.indexOf(event) !== -1) {\r\n          if (!_eventHandlers[event]) {\r\n            _eventHandlers[event] = [];\r\n          }\r\n\r\n          _eventHandlers[event].push(f);\r\n        }\r\n      },\r\n      clearEventHandlers: function clearEventHandlers() {\r\n        Object.keys(_eventHandlers).forEach(function (ind) {\r\n          return delete _eventHandlers[ind];\r\n        });\r\n      },\r\n      setTopRight: function setTopRight(topRight) {\r\n        _topRight.x = topRight.x;\r\n        _topRight.y = topRight.y;\r\n      },\r\n      getTopRight: function getTopRight() {\r\n        return _topRight;\r\n      },\r\n      setCanvasSize: function setCanvasSize(canvasSize) {\r\n        _canvasSize.x = canvasSize.x;\r\n        _canvasSize.y = canvasSize.y;\r\n      },\r\n      getCanvasSize: function getCanvasSize() {\r\n        return _canvasSize;\r\n      },\r\n      getFrame: function getFrame() {\r\n        var frame;\r\n\r\n        if (!loaded) {\r\n          return null;\r\n        }\r\n\r\n        if (!paused) {\r\n          var _imgArray;\r\n\r\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n          frame = (_imgArray = imgArray) === null || _imgArray === void 0 ? void 0 : _imgArray[frameIdx];\r\n\r\n          if (frameIdx < size - 1) {\r\n            frameIdx++;\r\n          } else {\r\n            setTimeout(function () {\r\n              _ended = true;\r\n              publishEvent('ended', []);\r\n            }, 0);\r\n          }\r\n        } // eslint-disable-next-line @typescript-eslint/no-unsafe-return\r\n\r\n\r\n        return frame;\r\n      }\r\n    };\r\n    return inputStream;\r\n  }\r\n};\r\n/* harmony default export */ var input_stream_browser = (inputStreamFactory);\r\n// EXTERNAL MODULE: ./src/locator/barcode_locator.js\r\nvar barcode_locator = __nested_webpack_require_266069__(23);\r\n\r\n// CONCATENATED MODULE: ./src/QuaggaContext.ts\r\n\r\n\r\n\r\nvar QuaggaContext_QuaggaContext = /*#__PURE__*/createClass_default()(function QuaggaContext() {\r\n  classCallCheck_default()(this, QuaggaContext);\r\n\r\n  defineProperty_default()(this, \"config\", void 0);\r\n\r\n  defineProperty_default()(this, \"inputStream\", void 0);\r\n\r\n  defineProperty_default()(this, \"framegrabber\", void 0);\r\n\r\n  defineProperty_default()(this, \"inputImageWrapper\", void 0);\r\n\r\n  defineProperty_default()(this, \"stopped\", false);\r\n\r\n  defineProperty_default()(this, \"boxSize\", void 0);\r\n\r\n  defineProperty_default()(this, \"resultCollector\", void 0);\r\n\r\n  defineProperty_default()(this, \"decoder\", void 0);\r\n\r\n  defineProperty_default()(this, \"workerPool\", []);\r\n\r\n  defineProperty_default()(this, \"onUIThread\", true);\r\n\r\n  defineProperty_default()(this, \"canvasContainer\", new QuaggaContext_CanvasContainer());\r\n});\r\nvar QuaggaContext_CanvasInfo = /*#__PURE__*/createClass_default()(function CanvasInfo() {\r\n  classCallCheck_default()(this, CanvasInfo);\r\n\r\n  defineProperty_default()(this, \"image\", void 0);\r\n\r\n  defineProperty_default()(this, \"overlay\", void 0);\r\n});\r\nvar QuaggaContext_CanvasContainer = /*#__PURE__*/createClass_default()(function CanvasContainer() {\r\n  classCallCheck_default()(this, CanvasContainer);\r\n\r\n  defineProperty_default()(this, \"ctx\", void 0);\r\n\r\n  defineProperty_default()(this, \"dom\", void 0);\r\n\r\n  this.ctx = new QuaggaContext_CanvasInfo();\r\n  this.dom = new QuaggaContext_CanvasInfo();\r\n});\r\n// CONCATENATED MODULE: ./src/quagga/getViewPort.ts\r\nfunction getViewPort_getViewPort(target) {\r\n  if (typeof document === 'undefined') {\r\n    return null;\r\n  } // Check if target is already a DOM element\r\n\r\n\r\n  if (target instanceof HTMLElement && target.nodeName && target.nodeType === 1) {\r\n    return target;\r\n  } // Use '#interactive.viewport' as a fallback selector (backwards compatibility)\r\n\r\n\r\n  var selector = typeof target === 'string' ? target : '#interactive.viewport';\r\n  return document.querySelector(selector);\r\n}\r\n// CONCATENATED MODULE: ./src/quagga/initBuffers.ts\r\n\r\n\r\n\r\n// TODO: need typescript def for BarcodeLocator\r\nfunction initBuffers_initBuffers(inputStream, imageWrapper, locator) {\r\n  var inputImageWrapper = imageWrapper || new image_wrapper[\"a\" /* default */]({\r\n    x: inputStream.getWidth(),\r\n    y: inputStream.getHeight(),\r\n    type: 'XYSize'\r\n  });\r\n\r\n  if (true) {\r\n    console.log(\"image wrapper size \".concat(inputImageWrapper.size));\r\n  }\r\n\r\n  var boxSize = [Object(gl_vec2[\"clone\"])([0, 0]), Object(gl_vec2[\"clone\"])([0, inputImageWrapper.size.y]), Object(gl_vec2[\"clone\"])([inputImageWrapper.size.x, inputImageWrapper.size.y]), Object(gl_vec2[\"clone\"])([inputImageWrapper.size.x, 0])];\r\n  barcode_locator[\"a\" /* default */].init(inputImageWrapper, locator);\r\n  return {\r\n    inputImageWrapper: inputImageWrapper,\r\n    boxSize: boxSize\r\n  };\r\n}\r\n// CONCATENATED MODULE: ./src/quagga/initCanvas.ts\r\n\r\n\r\nfunction findOrCreateCanvas(selector, className) {\r\n  var canvas = document.querySelector(selector);\r\n\r\n  if (!canvas) {\r\n    canvas = document.createElement('canvas');\r\n    canvas.className = className;\r\n  }\r\n\r\n  return canvas;\r\n}\r\n\r\nfunction getCanvasAndContext(selector, className) {\r\n  var canvas = findOrCreateCanvas(selector, className);\r\n  var context = canvas.getContext('2d');\r\n  return {\r\n    canvas: canvas,\r\n    context: context\r\n  };\r\n}\r\n\r\nfunction initCanvases(canvasSize) {\r\n  if (typeof document !== 'undefined') {\r\n    var image = getCanvasAndContext('canvas.imgBuffer', 'imgBuffer');\r\n    var overlay = getCanvasAndContext('canvas.drawingBuffer', 'drawingBuffer'); // eslint-disable-next-line no-multi-assign\r\n\r\n    image.canvas.width = overlay.canvas.width = canvasSize.x; // eslint-disable-next-line no-multi-assign\r\n\r\n    image.canvas.height = overlay.canvas.height = canvasSize.y;\r\n    return {\r\n      dom: {\r\n        image: image.canvas,\r\n        overlay: overlay.canvas\r\n      },\r\n      ctx: {\r\n        image: image.context,\r\n        overlay: overlay.context\r\n      }\r\n    };\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction initCanvas_initCanvas(context) {\r\n  var _context$config, _context$config$input, _context$config2, _context$config2$inpu;\r\n\r\n  var viewport = getViewPort_getViewPort(context === null || context === void 0 ? void 0 : (_context$config = context.config) === null || _context$config === void 0 ? void 0 : (_context$config$input = _context$config.inputStream) === null || _context$config$input === void 0 ? void 0 : _context$config$input.target);\r\n  var type = context === null || context === void 0 ? void 0 : (_context$config2 = context.config) === null || _context$config2 === void 0 ? void 0 : (_context$config2$inpu = _context$config2.inputStream) === null || _context$config2$inpu === void 0 ? void 0 : _context$config2$inpu.type;\r\n  if (!type) return null;\r\n  var container = initCanvases(context.inputStream.getCanvasSize());\r\n  if (!container) return {\r\n    dom: {\r\n      image: null,\r\n      overlay: null\r\n    },\r\n    ctx: {\r\n      image: null,\r\n      overlay: null\r\n    }\r\n  };\r\n  var dom = container.dom;\r\n\r\n  if (typeof document !== 'undefined') {\r\n    if (viewport) {\r\n      if (type === 'ImageStream' && !viewport.contains(dom.image)) {\r\n        viewport.appendChild(dom.image);\r\n      }\r\n\r\n      if (!viewport.contains(dom.overlay)) {\r\n        viewport.appendChild(dom.overlay);\r\n      }\r\n    }\r\n  }\r\n\r\n  return container;\r\n}\r\n// CONCATENATED MODULE: ./src/quagga/qworker.ts\r\n\r\n\r\nfunction qworker_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\r\n\r\nfunction qworker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? qworker_ownKeys(Object(source), !0).forEach(function (key) { defineProperty_default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : qworker_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\r\n\r\n/* Worker functions. These are straight from the original quagga.js file.\r\n * Not presently used, as worker support is non-functional.  Keeping them around temporarily\r\n * to refer to until it is re-implemented. We may be able to fix/use some of this.\r\n */\r\n// TODO: need a typescript interface for FrameGrabber\r\nvar workerPool = [];\r\nfunction updateWorkers(frameGrabber) {\r\n  var availableWorker;\r\n\r\n  if (workerPool.length) {\r\n    availableWorker = workerPool.filter(function (workerThread) {\r\n      return !workerThread.busy;\r\n    })[0];\r\n\r\n    if (availableWorker) {\r\n      frameGrabber.attachData(availableWorker.imageData);\r\n\r\n      if (frameGrabber.grab()) {\r\n        availableWorker.busy = true;\r\n        availableWorker.worker.postMessage({\r\n          cmd: 'process',\r\n          imageData: availableWorker.imageData\r\n        }, [availableWorker.imageData.buffer]);\r\n      }\r\n\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction configForWorker(config) {\r\n  return qworker_objectSpread(qworker_objectSpread({}, config), {}, {\r\n    inputStream: qworker_objectSpread(qworker_objectSpread({}, config.inputStream), {}, {\r\n      target: null\r\n    })\r\n  });\r\n} // @ts-ignore\r\n\r\n\r\nfunction workerInterface(factory) {\r\n  if (factory) {\r\n    var Quagga = factory()[\"default\"];\r\n\r\n    if (!Quagga) {\r\n      // @ts-ignore\r\n      self.postMessage({\r\n        'event': 'error',\r\n        message: 'Quagga could not be created'\r\n      });\r\n      return;\r\n    }\r\n  } // @ts-ignore\r\n\r\n\r\n  var imageWrapper; // @ts-ignore\r\n\r\n  function onProcessed(result) {\r\n    self.postMessage({\r\n      'event': 'processed',\r\n      // @ts-ignore\r\n      imageData: imageWrapper.data,\r\n      result: result // @ts-ignore\r\n\r\n    }, [imageWrapper.data.buffer]);\r\n  }\r\n\r\n  function workerInterfaceReady() {\r\n    self.postMessage({\r\n      'event': 'initialized',\r\n      // @ts-ignore\r\n      imageData: imageWrapper.data // @ts-ignore\r\n\r\n    }, [imageWrapper.data.buffer]);\r\n  } // @ts-ignore\r\n\r\n\r\n  self.onmessage = function (e) {\r\n    if (e.data.cmd === 'init') {\r\n      var config = e.data.config;\r\n      config.numOfWorkers = 0;\r\n      imageWrapper = new Quagga.ImageWrapper({\r\n        x: e.data.size.x,\r\n        y: e.data.size.y\r\n      }, new Uint8Array(e.data.imageData));\r\n      Quagga.init(config, workerInterfaceReady, imageWrapper);\r\n      Quagga.onProcessed(onProcessed);\r\n    } else if (e.data.cmd === 'process') {\r\n      // @ts-ignore\r\n      imageWrapper.data = new Uint8Array(e.data.imageData);\r\n      Quagga.start();\r\n    } else if (e.data.cmd === 'setReaders') {\r\n      Quagga.setReaders(e.data.readers);\r\n    } else if (e.data.cmd === 'registerReader') {\r\n      Quagga.registerReader(e.data.name, e.data.reader);\r\n    }\r\n  };\r\n}\r\n\r\nfunction generateWorkerBlob() {\r\n  var blob, factorySource;\r\n  /* jshint ignore:start */\r\n  // @ts-ignore\r\n\r\n  if (typeof __factorySource__ !== 'undefined') {\r\n    // @ts-ignore\r\n    factorySource = __factorySource__; // eslint-disable-line no-undef\r\n  }\r\n  /* jshint ignore:end */\r\n\r\n\r\n  blob = new Blob(['(' + workerInterface.toString() + ')(' + factorySource + ');'], {\r\n    type: 'text/javascript'\r\n  });\r\n  return window.URL.createObjectURL(blob);\r\n}\r\n\r\nfunction initWorker(config, inputStream, cb) {\r\n  var blobURL = generateWorkerBlob();\r\n  var worker = new Worker(blobURL);\r\n  var workerThread = {\r\n    worker: worker,\r\n    imageData: new Uint8Array(inputStream.getWidth() * inputStream.getHeight()),\r\n    busy: true\r\n  };\r\n\r\n  workerThread.worker.onmessage = function (e) {\r\n    if (e.data.event === 'initialized') {\r\n      URL.revokeObjectURL(blobURL);\r\n      workerThread.busy = false;\r\n      workerThread.imageData = new Uint8Array(e.data.imageData);\r\n\r\n      if (true) {\r\n        console.log('Worker initialized');\r\n      }\r\n\r\n      cb(workerThread);\r\n    } else if (e.data.event === 'processed') {\r\n      workerThread.imageData = new Uint8Array(e.data.imageData);\r\n      workerThread.busy = false; // TODO: how to thread publishResult into here?\r\n      // publishResult(e.data.result, workerThread.imageData);\r\n    } else if (e.data.event === 'error') {\r\n      if (true) {\r\n        console.log('Worker error: ' + e.data.message);\r\n      }\r\n    }\r\n  };\r\n\r\n  workerThread.worker.postMessage({\r\n    cmd: 'init',\r\n    size: {\r\n      x: inputStream.getWidth(),\r\n      y: inputStream.getHeight()\r\n    },\r\n    imageData: workerThread.imageData,\r\n    config: configForWorker(config)\r\n  }, [workerThread.imageData.buffer]);\r\n}\r\nfunction adjustWorkerPool(capacity, config, inputStream, cb) {\r\n  var increaseBy = capacity - workerPool.length;\r\n\r\n  if (increaseBy === 0 && cb) {\r\n    cb();\r\n  } else if (increaseBy < 0) {\r\n    var workersToTerminate = workerPool.slice(increaseBy);\r\n    workersToTerminate.forEach(function (workerThread) {\r\n      workerThread.worker.terminate();\r\n\r\n      if (true) {\r\n        console.log('Worker terminated!');\r\n      }\r\n    });\r\n    workerPool = workerPool.slice(0, increaseBy);\r\n\r\n    if (cb) {\r\n      cb();\r\n    }\r\n  } else {\r\n    var workerInitialized = function workerInitialized(workerThread) {\r\n      workerPool.push(workerThread);\r\n\r\n      if (workerPool.length >= capacity && cb) {\r\n        cb();\r\n      }\r\n    };\r\n\r\n    if (config) {\r\n      for (var i = 0; i < increaseBy; i++) {\r\n        initWorker(config, inputStream, workerInitialized);\r\n      }\r\n    }\r\n  }\r\n}\r\nfunction qworker_setReaders(readers) {\r\n  workerPool.forEach(function (workerThread) {\r\n    return workerThread.worker.postMessage({\r\n      cmd: 'setReaders',\r\n      readers: readers\r\n    });\r\n  });\r\n}\r\nfunction qworker_registerReader(name, reader) {\r\n  workerPool.forEach(function (workerThread) {\r\n    return workerThread.worker.postMessage({\r\n      cmd: 'registerReader',\r\n      name: name,\r\n      reader: reader\r\n    });\r\n  });\r\n}\r\n// CONCATENATED MODULE: ./src/quagga/setupInputStream.ts\r\n// TODO: need to create an InputStream typescript interface, so we don't have an \"any\" in the next line\r\nfunction setupInputStream() {\r\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'LiveStream';\r\n  var viewport = arguments.length > 1 ? arguments[1] : undefined;\r\n  var inputStreamFactory = arguments.length > 2 ? arguments[2] : undefined;\r\n\r\n  switch (type) {\r\n    case 'VideoStream':\r\n      {\r\n        var video = document.createElement('video');\r\n        return {\r\n          video: video,\r\n          inputStream: inputStreamFactory.createVideoStream(video)\r\n        };\r\n      }\r\n\r\n    case 'ImageStream':\r\n      return {\r\n        inputStream: inputStreamFactory.createImageStream()\r\n      };\r\n\r\n    case 'LiveStream':\r\n      {\r\n        var _video = null;\r\n\r\n        if (viewport) {\r\n          _video = viewport.querySelector('video');\r\n\r\n          if (!_video) {\r\n            _video = document.createElement('video');\r\n            viewport.appendChild(_video);\r\n          }\r\n        }\r\n\r\n        return {\r\n          video: _video,\r\n          inputStream: inputStreamFactory.createLiveStream(_video)\r\n        };\r\n      }\r\n\r\n    default:\r\n      console.error(\"* setupInputStream invalid type \".concat(type));\r\n      return {\r\n        video: null,\r\n        inputStream: null\r\n      };\r\n  }\r\n}\r\n// CONCATENATED MODULE: ./src/quagga/transform.ts\r\n/* eslint-disable no-param-reassign */\r\nfunction moveBox(box, xOffset, yOffset) {\r\n  var corner = box.length;\r\n\r\n  while (corner--) {\r\n    box[corner][0] += xOffset;\r\n    box[corner][1] += yOffset;\r\n  }\r\n}\r\nfunction moveLine(line, xOffset, yOffset) {\r\n  line[0].x += xOffset;\r\n  line[0].y += yOffset;\r\n  line[1].x += xOffset;\r\n  line[1].y += yOffset;\r\n}\r\n// CONCATENATED MODULE: ./src/quagga/quagga.ts\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar quagga_Quagga = /*#__PURE__*/function () {\r\n  function Quagga() {\r\n    var _this = this;\r\n\r\n    classCallCheck_default()(this, Quagga);\r\n\r\n    defineProperty_default()(this, \"context\", new QuaggaContext_QuaggaContext());\r\n\r\n    defineProperty_default()(this, \"canRecord\", function (callback) {\r\n      var _this$context$config;\r\n\r\n      if (!_this.context.config) {\r\n        return;\r\n      }\r\n\r\n      barcode_locator[\"a\" /* default */].checkImageConstraints(_this.context.inputStream, (_this$context$config = _this.context.config) === null || _this$context$config === void 0 ? void 0 : _this$context$config.locator);\r\n\r\n      _this.initCanvas();\r\n\r\n      _this.context.framegrabber = frame_grabber_browser.create(_this.context.inputStream, _this.context.canvasContainer.dom.image);\r\n\r\n      if (_this.context.config.numOfWorkers === undefined) {\r\n        _this.context.config.numOfWorkers = 0;\r\n      }\r\n\r\n      adjustWorkerPool(_this.context.config.numOfWorkers, _this.context.config, _this.context.inputStream, function () {\r\n        var _this$context$config2;\r\n\r\n        if (((_this$context$config2 = _this.context.config) === null || _this$context$config2 === void 0 ? void 0 : _this$context$config2.numOfWorkers) === 0) {\r\n          _this.initializeData();\r\n        }\r\n\r\n        _this.ready(callback);\r\n      });\r\n    });\r\n\r\n    defineProperty_default()(this, \"update\", function () {\r\n      if (_this.context.onUIThread) {\r\n        var workersUpdated = updateWorkers(_this.context.framegrabber);\r\n\r\n        if (!workersUpdated) {\r\n          var _this$context$inputIm;\r\n\r\n          _this.context.framegrabber.attachData((_this$context$inputIm = _this.context.inputImageWrapper) === null || _this$context$inputIm === void 0 ? void 0 : _this$context$inputIm.data);\r\n\r\n          if (_this.context.framegrabber.grab()) {\r\n            if (!workersUpdated) {\r\n              _this.locateAndDecode();\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        var _this$context$inputIm2;\r\n\r\n        _this.context.framegrabber.attachData((_this$context$inputIm2 = _this.context.inputImageWrapper) === null || _this$context$inputIm2 === void 0 ? void 0 : _this$context$inputIm2.data);\r\n\r\n        _this.context.framegrabber.grab();\r\n\r\n        _this.locateAndDecode();\r\n      }\r\n    });\r\n  }\r\n\r\n  createClass_default()(Quagga, [{\r\n    key: \"initBuffers\",\r\n    value: function initBuffers(imageWrapper) {\r\n      if (!this.context.config) {\r\n        return;\r\n      }\r\n\r\n      var _initBuffers2 = initBuffers_initBuffers(this.context.inputStream, imageWrapper, this.context.config.locator),\r\n          inputImageWrapper = _initBuffers2.inputImageWrapper,\r\n          boxSize = _initBuffers2.boxSize;\r\n\r\n      this.context.inputImageWrapper = inputImageWrapper;\r\n      this.context.boxSize = boxSize;\r\n    }\r\n  }, {\r\n    key: \"initializeData\",\r\n    value: function initializeData(imageWrapper) {\r\n      if (!this.context.config) {\r\n        return;\r\n      }\r\n\r\n      this.initBuffers(imageWrapper);\r\n      this.context.decoder = barcode_decoder.create(this.context.config.decoder, this.context.inputImageWrapper);\r\n    }\r\n  }, {\r\n    key: \"getViewPort\",\r\n    value: function getViewPort() {\r\n      if (!this.context.config || !this.context.config.inputStream) {\r\n        return null;\r\n      }\r\n\r\n      var target = this.context.config.inputStream.target;\r\n      return getViewPort_getViewPort(target);\r\n    }\r\n  }, {\r\n    key: \"ready\",\r\n    value: function ready(callback) {\r\n      this.context.inputStream.play();\r\n      callback();\r\n    }\r\n  }, {\r\n    key: \"initCanvas\",\r\n    value: function initCanvas() {\r\n      var container = initCanvas_initCanvas(this.context);\r\n\r\n      if (!container) {\r\n        return;\r\n      }\r\n\r\n      var ctx = container.ctx,\r\n          dom = container.dom;\r\n      this.context.canvasContainer.dom.image = dom.image;\r\n      this.context.canvasContainer.dom.overlay = dom.overlay;\r\n      this.context.canvasContainer.ctx.image = ctx.image;\r\n      this.context.canvasContainer.ctx.overlay = ctx.overlay;\r\n    }\r\n  }, {\r\n    key: \"initInputStream\",\r\n    value: function initInputStream(callback) {\r\n      if (!this.context.config || !this.context.config.inputStream) {\r\n        return;\r\n      }\r\n\r\n      var _this$context$config$ = this.context.config.inputStream,\r\n          inputType = _this$context$config$.type,\r\n          constraints = _this$context$config$.constraints;\r\n\r\n      var _setupInputStream = setupInputStream(inputType, this.getViewPort(), input_stream_browser),\r\n          video = _setupInputStream.video,\r\n          inputStream = _setupInputStream.inputStream;\r\n\r\n      if (inputType === 'LiveStream' && video) {\r\n        camera_access.request(video, constraints).then(function () {\r\n          return inputStream.trigger('canrecord');\r\n        })[\"catch\"](function (err) {\r\n          return callback(err);\r\n        });\r\n      }\r\n\r\n      if (inputStream) {\r\n        inputStream.setAttribute('preload', 'auto');\r\n        inputStream.setInputStream(this.context.config.inputStream);\r\n        inputStream.addEventListener('canrecord', this.canRecord.bind(undefined, callback));\r\n      }\r\n\r\n      this.context.inputStream = inputStream;\r\n    }\r\n  }, {\r\n    key: \"getBoundingBoxes\",\r\n    value: function getBoundingBoxes() {\r\n      var _this$context$config3;\r\n\r\n      return (_this$context$config3 = this.context.config) !== null && _this$context$config3 !== void 0 && _this$context$config3.locate ? barcode_locator[\"a\" /* default */].locate() : [[Object(gl_vec2[\"clone\"])(this.context.boxSize[0]), Object(gl_vec2[\"clone\"])(this.context.boxSize[1]), Object(gl_vec2[\"clone\"])(this.context.boxSize[2]), Object(gl_vec2[\"clone\"])(this.context.boxSize[3])]];\r\n    } // TODO: need a typescript type for result here.\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n\r\n  }, {\r\n    key: \"transformResult\",\r\n    value: function transformResult(result) {\r\n      var _this2 = this;\r\n\r\n      var topRight = this.context.inputStream.getTopRight();\r\n      var xOffset = topRight.x;\r\n      var yOffset = topRight.y;\r\n\r\n      if (xOffset === 0 && yOffset === 0) {\r\n        return;\r\n      }\r\n\r\n      if (result.barcodes) {\r\n        // TODO: BarcodeInfo may not be the right type here.\r\n        result.barcodes.forEach(function (barcode) {\r\n          return _this2.transformResult(barcode);\r\n        });\r\n      }\r\n\r\n      if (result.line && result.line.length === 2) {\r\n        moveLine(result.line, xOffset, yOffset);\r\n      }\r\n\r\n      if (result.box) {\r\n        moveBox(result.box, xOffset, yOffset);\r\n      }\r\n\r\n      if (result.boxes && result.boxes.length > 0) {\r\n        for (var i = 0; i < result.boxes.length; i++) {\r\n          moveBox(result.boxes[i], xOffset, yOffset);\r\n        }\r\n      }\r\n    }\r\n  }, {\r\n    key: \"addResult\",\r\n    value: function addResult(result, imageData) {\r\n      var _this3 = this;\r\n\r\n      if (!imageData || !this.context.resultCollector) {\r\n        return;\r\n      } // TODO: Figure out what data structure holds a \"barcodes\" result, if any...\r\n\r\n\r\n      if (result.barcodes) {\r\n        result.barcodes.filter(function (barcode) {\r\n          return barcode.codeResult;\r\n        }).forEach(function (barcode) {\r\n          return _this3.addResult(barcode, imageData);\r\n        });\r\n      } else if (result.codeResult) {\r\n        this.context.resultCollector.addResult(imageData, this.context.inputStream.getCanvasSize(), result.codeResult);\r\n      }\r\n    } // eslint-disable-next-line class-methods-use-this\r\n\r\n  }, {\r\n    key: \"hasCodeResult\",\r\n    value: function hasCodeResult(result) {\r\n      return !!(result && (result.barcodes ? result.barcodes.some(function (barcode) {\r\n        return barcode.codeResult;\r\n      }) : result.codeResult));\r\n    } // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n\r\n  }, {\r\n    key: \"publishResult\",\r\n    value: function publishResult() {\r\n      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\r\n      var imageData = arguments.length > 1 ? arguments[1] : undefined;\r\n      var resultToPublish = result;\r\n\r\n      if (result && this.context.onUIThread) {\r\n        this.transformResult(result);\r\n        this.addResult(result, imageData);\r\n        resultToPublish = result.barcodes || result;\r\n      }\r\n\r\n      events.publish('processed', resultToPublish);\r\n\r\n      if (this.hasCodeResult(result)) {\r\n        events.publish('detected', resultToPublish);\r\n      }\r\n    }\r\n  }, {\r\n    key: \"locateAndDecode\",\r\n    value: function () {\r\n      var _locateAndDecode = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {\r\n        var boxes, _this$context$inputIm3, decodeResult, imageResult, _this$context$inputIm4;\r\n\r\n        return regenerator_default.a.wrap(function _callee$(_context) {\r\n          while (1) {\r\n            switch (_context.prev = _context.next) {\r\n              case 0:\r\n                boxes = this.getBoundingBoxes();\r\n\r\n                if (!boxes) {\r\n                  _context.next = 12;\r\n                  break;\r\n                }\r\n\r\n                _context.next = 4;\r\n                return this.context.decoder.decodeFromBoundingBoxes(boxes);\r\n\r\n              case 4:\r\n                _context.t0 = _context.sent;\r\n\r\n                if (_context.t0) {\r\n                  _context.next = 7;\r\n                  break;\r\n                }\r\n\r\n                _context.t0 = {};\r\n\r\n              case 7:\r\n                decodeResult = _context.t0;\r\n                decodeResult.boxes = boxes;\r\n                this.publishResult(decodeResult, (_this$context$inputIm3 = this.context.inputImageWrapper) === null || _this$context$inputIm3 === void 0 ? void 0 : _this$context$inputIm3.data);\r\n                _context.next = 16;\r\n                break;\r\n\r\n              case 12:\r\n                _context.next = 14;\r\n                return this.context.decoder.decodeFromImage(this.context.inputImageWrapper);\r\n\r\n              case 14:\r\n                imageResult = _context.sent;\r\n\r\n                if (imageResult) {\r\n                  this.publishResult(imageResult, (_this$context$inputIm4 = this.context.inputImageWrapper) === null || _this$context$inputIm4 === void 0 ? void 0 : _this$context$inputIm4.data);\r\n                } else {\r\n                  this.publishResult();\r\n                }\r\n\r\n              case 16:\r\n              case \"end\":\r\n                return _context.stop();\r\n            }\r\n          }\r\n        }, _callee, this);\r\n      }));\r\n\r\n      function locateAndDecode() {\r\n        return _locateAndDecode.apply(this, arguments);\r\n      }\r\n\r\n      return locateAndDecode;\r\n    }()\r\n  }, {\r\n    key: \"startContinuousUpdate\",\r\n    value: function startContinuousUpdate() {\r\n      var _this$context$config4,\r\n          _this4 = this;\r\n\r\n      var next = null;\r\n      var delay = 1000 / (((_this$context$config4 = this.context.config) === null || _this$context$config4 === void 0 ? void 0 : _this$context$config4.frequency) || 60);\r\n      this.context.stopped = false;\r\n      var context = this.context;\r\n\r\n      var newFrame = function newFrame(timestamp) {\r\n        next = next || timestamp;\r\n\r\n        if (!context.stopped) {\r\n          if (timestamp >= next) {\r\n            next += delay;\r\n\r\n            _this4.update();\r\n          }\r\n\r\n          window.requestAnimationFrame(newFrame);\r\n        }\r\n      };\r\n\r\n      newFrame(performance.now());\r\n    }\r\n  }, {\r\n    key: \"start\",\r\n    value: function start() {\r\n      var _this$context$config5, _this$context$config6;\r\n\r\n      if (this.context.onUIThread && ((_this$context$config5 = this.context.config) === null || _this$context$config5 === void 0 ? void 0 : (_this$context$config6 = _this$context$config5.inputStream) === null || _this$context$config6 === void 0 ? void 0 : _this$context$config6.type) === 'LiveStream') {\r\n        this.startContinuousUpdate();\r\n      } else {\r\n        this.update();\r\n      }\r\n    }\r\n  }, {\r\n    key: \"stop\",\r\n    value: function () {\r\n      var _stop = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee2() {\r\n        var _this$context$config7;\r\n\r\n        return regenerator_default.a.wrap(function _callee2$(_context2) {\r\n          while (1) {\r\n            switch (_context2.prev = _context2.next) {\r\n              case 0:\r\n                this.context.stopped = true;\r\n                adjustWorkerPool(0);\r\n\r\n                if (!((_this$context$config7 = this.context.config) !== null && _this$context$config7 !== void 0 && _this$context$config7.inputStream && this.context.config.inputStream.type === 'LiveStream')) {\r\n                  _context2.next = 6;\r\n                  break;\r\n                }\r\n\r\n                _context2.next = 5;\r\n                return camera_access.release();\r\n\r\n              case 5:\r\n                this.context.inputStream.clearEventHandlers();\r\n\r\n              case 6:\r\n              case \"end\":\r\n                return _context2.stop();\r\n            }\r\n          }\r\n        }, _callee2, this);\r\n      }));\r\n\r\n      function stop() {\r\n        return _stop.apply(this, arguments);\r\n      }\r\n\r\n      return stop;\r\n    }()\r\n  }, {\r\n    key: \"setReaders\",\r\n    value: function setReaders(readers) {\r\n      if (this.context.decoder) {\r\n        this.context.decoder.setReaders(readers);\r\n      }\r\n\r\n      qworker_setReaders(readers);\r\n    }\r\n  }, {\r\n    key: \"registerReader\",\r\n    value: function registerReader(name, reader) {\r\n      barcode_decoder.registerReader(name, reader);\r\n\r\n      if (this.context.decoder) {\r\n        this.context.decoder.registerReader(name, reader);\r\n      }\r\n\r\n      qworker_registerReader(name, reader);\r\n    }\r\n  }]);\r\n\r\n  return Quagga;\r\n}();\r\n\r\n\r\n// CONCATENATED MODULE: ./src/quagga.js\r\n\r\n\r\n // eslint-disable-line no-unused-vars\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar instance = new quagga_Quagga();\r\nvar _context = instance.context;\r\nvar QuaggaJSStaticInterface = {\r\n  init: function init(config, cb, imageWrapper) {\r\n    var quaggaInstance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : instance;\r\n    var promise;\r\n\r\n    if (!cb) {\r\n      promise = new Promise(function (resolve, reject) {\r\n        cb = function cb(err) {\r\n          err ? reject(err) : resolve();\r\n        };\r\n      });\r\n    }\r\n\r\n    quaggaInstance.context.config = merge_default()({}, config_config, config); // TODO #179: pending restructure in Issue #179, we are temp disabling workers\r\n\r\n    if (quaggaInstance.context.config.numOfWorkers > 0) {\r\n      quaggaInstance.context.config.numOfWorkers = 0;\r\n    }\r\n\r\n    if (imageWrapper) {\r\n      quaggaInstance.context.onUIThread = false;\r\n      quaggaInstance.initializeData(imageWrapper);\r\n\r\n      if (cb) {\r\n        cb();\r\n      }\r\n    } else {\r\n      quaggaInstance.initInputStream(cb);\r\n    }\r\n\r\n    return promise;\r\n  },\r\n  start: function start() {\r\n    return instance.start();\r\n  },\r\n  stop: function stop() {\r\n    return instance.stop();\r\n  },\r\n  pause: function pause() {\r\n    _context.stopped = true;\r\n  },\r\n  onDetected: function onDetected(callback) {\r\n    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {\r\n      console.trace('* warning: Quagga.onDetected called with invalid callback, ignoring');\r\n      return;\r\n    }\r\n\r\n    events.subscribe('detected', callback);\r\n  },\r\n  offDetected: function offDetected(callback) {\r\n    events.unsubscribe('detected', callback);\r\n  },\r\n  onProcessed: function onProcessed(callback) {\r\n    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {\r\n      console.trace('* warning: Quagga.onProcessed called with invalid callback, ignoring');\r\n      return;\r\n    }\r\n\r\n    events.subscribe('processed', callback);\r\n  },\r\n  offProcessed: function offProcessed(callback) {\r\n    events.unsubscribe('processed', callback);\r\n  },\r\n  setReaders: function setReaders(readers) {\r\n    if (!readers) {\r\n      console.trace('* warning: Quagga.setReaders called with no readers, ignoring');\r\n      return;\r\n    }\r\n\r\n    instance.setReaders(readers);\r\n  },\r\n  registerReader: function registerReader(name, reader) {\r\n    if (!name) {\r\n      console.trace('* warning: Quagga.registerReader called with no name, ignoring');\r\n      return;\r\n    }\r\n\r\n    if (!reader) {\r\n      console.trace('* warning: Quagga.registerReader called with no reader, ignoring');\r\n      return;\r\n    }\r\n\r\n    instance.registerReader(name, reader);\r\n  },\r\n  registerResultCollector: function registerResultCollector(resultCollector) {\r\n    if (resultCollector && typeof resultCollector.addResult === 'function') {\r\n      _context.resultCollector = resultCollector;\r\n    }\r\n  },\r\n\r\n  get canvas() {\r\n    return _context.canvasContainer;\r\n  },\r\n\r\n  decodeSingle: function decodeSingle(config, resultCallback) {\r\n    var _this = this;\r\n\r\n    var quaggaInstance = new quagga_Quagga();\r\n    config = merge_default()({\r\n      inputStream: {\r\n        type: 'ImageStream',\r\n        sequence: false,\r\n        size: 800,\r\n        src: config.src\r\n      },\r\n      numOfWorkers:   true && config.debug ? 0 : 1,\r\n      locator: {\r\n        halfSample: false\r\n      }\r\n    }, config); // TODO #175: restructure worker support so that it will work with typescript using worker-loader\r\n    // https://webpack.js.org/loaders/worker-loader/\r\n\r\n    if (config.numOfWorkers > 0) {\r\n      config.numOfWorkers = 0;\r\n    } // workers require Worker and Blob support presently, so if no Blob or Worker then set\r\n    // workers to 0.\r\n\r\n\r\n    if (config.numOfWorkers > 0 && (typeof Blob === 'undefined' || typeof Worker === 'undefined')) {\r\n      console.warn('* no Worker and/or Blob support - forcing numOfWorkers to 0');\r\n      config.numOfWorkers = 0;\r\n    }\r\n\r\n    return new Promise(function (resolve, reject) {\r\n      try {\r\n        _this.init(config, function () {\r\n          events.once('processed', function (result) {\r\n            quaggaInstance.stop();\r\n\r\n            if (resultCallback) {\r\n              resultCallback.call(null, result);\r\n            }\r\n\r\n            resolve(result);\r\n          }, true);\r\n          quaggaInstance.start();\r\n        }, null, quaggaInstance);\r\n      } catch (err) {\r\n        reject(err);\r\n      }\r\n    });\r\n  },\r\n\r\n  // add the usually expected \"default\" for use with require, build step won't allow us to\r\n  // write to module.exports so do it here.\r\n  get default() {\r\n    return QuaggaJSStaticInterface;\r\n  },\r\n\r\n  Readers: reader_namespaceObject,\r\n  CameraAccess: camera_access,\r\n  ImageDebug: image_debug[\"a\" /* default */],\r\n  ImageWrapper: image_wrapper[\"a\" /* default */],\r\n  ResultCollector: result_collector\r\n};\r\n/* harmony default export */ var quagga = __webpack_exports__[\"default\"] = (QuaggaJSStaticInterface); // export BarcodeReader and other utilities for external plugins\r\n\r\n\r\n\r\n/***/ })\r\n/******/ ])[\"default\"];\r\n});\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9RdWFnZ2Evd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1F1YWdnYS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9jbHVzdGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vY3ZfdXRpbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9pbWFnZV9kZWJ1Zy50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2FycmF5X2hlbHBlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2ltYWdlX3dyYXBwZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZXJnZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvbG9jYXRvci90cmFjZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvbG9jYXRvci9iYXJjb2RlX2xvY2F0b3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnbk1lcmdlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2FmZUdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5TGlrZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZXBzaWxvbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3VidHJhY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZGl2aWRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Rpc3RhbmNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NxdWFyZWREaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc3F1YXJlZExlbmd0aC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9lcHNpbG9uLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9mcm9tVmFsdWVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL25vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kb3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3VidHJhY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZGl2aWRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Rpc3RhbmNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NxdWFyZWREaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9sZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3F1YXJlZExlbmd0aC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcGljay5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwTmF0aXZlU3VwZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3IvcmFzdGVyaXplci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvbG9jYXRvci9za2VsZXRvbml6ZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXlhYmxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWVyZ2VEZWVwLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weUFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQ3JlYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9QbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5c0luLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VSZXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FwcGx5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2NvbnN0YW50LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vdHlwZWRlZnMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Nsb25lLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Zyb21WYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY29weS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zZXQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZXF1YWxzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2V4YWN0RXF1YWxzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2FkZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zdWIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbXVsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Rpdi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9pbnZlcnNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL21pbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9tYXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvcm90YXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Zsb29yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2NlaWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvcm91bmQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc2NhbGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvc2NhbGVBbmRBZGQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZGlzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zcXJEaXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2xlbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zcXJMZW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbmVnYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL25vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9kb3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY3Jvc3MuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbGVycC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9yYW5kb20uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvdHJhbnNmb3JtTWF0Mi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi90cmFuc2Zvcm1NYXQyZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi90cmFuc2Zvcm1NYXQzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3RyYW5zZm9ybU1hdDQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZm9yRWFjaC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9saW1pdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jbG9uZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9hbmdsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jb3B5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9lcXVhbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZXhhY3RFcXVhbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvYWRkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3N1Yi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9tdWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZGl2LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL21pbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9tYXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZmxvb3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvY2VpbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9yb3VuZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zY2FsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zY2FsZUFuZEFkZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NxckRpc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3Nxckxlbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9uZWdhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvaW52ZXJzZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jcm9zcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9sZXJwLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JhbmRvbS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy90cmFuc2Zvcm1NYXQ0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3RyYW5zZm9ybU1hdDMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvdHJhbnNmb3JtUXVhdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9yb3RhdGVYLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdGF0ZVkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvcm90YXRlWi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9mb3JFYWNoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc3VwZXJQcm9wQmFzZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVBpY2suanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVBpY2tCeS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVtb2l6ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaGFzSW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUhhc0luLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc1BhdGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZmxhdFJlc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9mbGF0dGVuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0ZsYXR0ZW5hYmxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY29uc3RydWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9kZXRlcm1pbmFudC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi90cmFuc3Bvc2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvbXVsdGlwbHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvYWRqb2ludC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9yb3RhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvaW52ZXJ0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2NyZWF0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9zY2FsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9jb3B5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2Zyb2IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvbGR1LmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvYmFyY29kZV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci8yb2Y1X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2NvZGFiYXJfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV8xMjhfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV8zOV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzMyX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2NvZGVfMzlfdmluX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2NvZGVfOTNfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvZWFuX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2Vhbl8yX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2Vhbl81X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2Vhbl84X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2kyb2Y1X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL3VwY19lX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL3VwY19yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2RlY29kZXIvYnJlc2VuaGFtLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9kZWNvZGVyL2JhcmNvZGVfZGVjb2Rlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2luZGV4LnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vZXZlbnRzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvRXhjZXB0aW9uLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vbWVkaWFEZXZpY2VzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9jYW1lcmFfYWNjZXNzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29uZmlnL2NvbmZpZy5kZXYudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbmZpZy9jb25maWcubm9kZS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29uZmlnL2NvbmZpZy5wcm9kLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb25maWcvY29uZmlnLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9mcmFtZV9ncmFiYmVyX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2V4aWZfaGVscGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9pbWFnZV9sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2lucHV0X3N0cmVhbS9pbnB1dF9zdHJlYW1fYnJvd3Nlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvUXVhZ2dhQ29udGV4dC50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL2dldFZpZXdQb3J0LnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvaW5pdEJ1ZmZlcnMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9pbml0Q2FudmFzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvcXdvcmtlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL3NldHVwSW5wdXRTdHJlYW0udHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS90cmFuc2Zvcm0udHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9xdWFnZ2EudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS5qcyJdLCJuYW1lcyI6WyJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwibW9kdWxlIiwiZXhwb3J0cyIsIl9fZXNNb2R1bGUiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwic2VsZiIsIlJlZmVyZW5jZUVycm9yIiwiX2dldFByb3RvdHlwZU9mIiwibyIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwicHJvdG90eXBlIiwiX3R5cGVvZiIsInJlcXVpcmUiLCJhc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsImNhbGwiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsIkVQU0lMT04iLCJjbG9uZSIsImZyb21WYWx1ZXMiLCJjb3B5Iiwic2V0IiwiZXF1YWxzIiwiZXhhY3RFcXVhbHMiLCJhZGQiLCJzdWJ0cmFjdCIsInN1YiIsIm11bHRpcGx5IiwibXVsIiwiZGl2aWRlIiwiZGl2IiwiaW52ZXJzZSIsIm1pbiIsIm1heCIsInJvdGF0ZSIsImZsb29yIiwiY2VpbCIsInJvdW5kIiwic2NhbGUiLCJzY2FsZUFuZEFkZCIsImRpc3RhbmNlIiwiZGlzdCIsInNxdWFyZWREaXN0YW5jZSIsInNxckRpc3QiLCJsZW4iLCJzcXVhcmVkTGVuZ3RoIiwic3FyTGVuIiwibmVnYXRlIiwibm9ybWFsaXplIiwiZG90IiwiY3Jvc3MiLCJsZXJwIiwicmFuZG9tIiwidHJhbnNmb3JtTWF0MiIsInRyYW5zZm9ybU1hdDJkIiwidHJhbnNmb3JtTWF0MyIsInRyYW5zZm9ybU1hdDQiLCJmb3JFYWNoIiwibGltaXQiLCJ2ZWMyIiwicG9pbnQiLCJ0aHJlc2hvbGQiLCJwb2ludHMiLCJjZW50ZXIiLCJyYWQiLCJ2ZWMiLCJwb2ludE1hcCIsInBvaW50VG9BZGQiLCJpZCIsInB1c2giLCJ1cGRhdGVDZW50ZXIiLCJzdW0iLCJNYXRoIiwiY29zIiwic2luIiwiaW5pdCIsImZpdHMiLCJvdGhlclBvaW50Iiwic2ltaWxhcml0eSIsImFicyIsImdldFBvaW50cyIsImdldENlbnRlciIsImNyZWF0ZVBvaW50IiwibmV3UG9pbnQiLCJwcm9wZXJ0eSIsInYyY2xvbmUiLCJ2ZWMzIiwidjNjbG9uZSIsImltYWdlUmVmIiwieCIsInkiLCJ0aGF0IiwidG9WZWMyIiwidG9WZWMzIiwiY29tcHV0ZUludGVncmFsSW1hZ2UyIiwiaW1hZ2VXcmFwcGVyIiwiaW50ZWdyYWxXcmFwcGVyIiwiaW1hZ2VEYXRhIiwiZGF0YSIsIndpZHRoIiwic2l6ZSIsImhlaWdodCIsImludGVncmFsSW1hZ2VEYXRhIiwicG9zQSIsInBvc0IiLCJwb3NDIiwicG9zRCIsImNvbXB1dGVJbnRlZ3JhbEltYWdlIiwidiIsInUiLCJ0aHJlc2hvbGRJbWFnZSIsInRhcmdldFdyYXBwZXIiLCJ0YXJnZXREYXRhIiwiY29tcHV0ZUhpc3RvZ3JhbSIsImJpdHNQZXJQaXhlbCIsImJpdFNoaWZ0IiwiYnVja2V0Q250IiwiaGlzdCIsIkludDMyQXJyYXkiLCJzaGFycGVuTGluZSIsImxpbmUiLCJsZWZ0IiwicmlnaHQiLCJkZXRlcm1pbmVPdHN1VGhyZXNob2xkIiwicHgiLCJlbmQiLCJteCIsImRldGVybWluZVRocmVzaG9sZCIsInZldCIsInAxIiwicDIiLCJwMTIiLCJtMSIsIm0yIiwibTEyIiwiayIsIkFycmF5SGVscGVyIiwibWF4SW5kZXgiLCJvdHN1VGhyZXNob2xkIiwiY29tcHV0ZUJpbmFyeUltYWdlIiwia2VybmVsIiwiQSIsIkIiLCJDIiwiRCIsImF2ZyIsImNsdXN0ZXIiLCJ0aGlzQ2x1c3RlciIsImNsdXN0ZXJzIiwiYWRkVG9DbHVzdGVyIiwiZm91bmQiLCJDbHVzdGVyMiIsIlRyYWNlciIsInRyYWNlIiwiaXRlcmF0aW9uIiwibWF4SXRlcmF0aW9ucyIsInRvcCIsInJlc3VsdCIsImNlbnRlclBvcyIsImN1cnJlbnRQb3MiLCJpZHgiLCJmb3J3YXJkIiwidG8iLCJ0b0lkeCIsInByZWRpY3RlZFBvcyIsInRocmVzaG9sZFgiLCJ0aHJlc2hvbGRZIiwibWF0Y2giLCJwb3MiLCJwcmVkaWN0ZWQiLCJmcm9tIiwiRElMQVRFIiwiRVJPREUiLCJkaWxhdGUiLCJpbkltYWdlV3JhcHBlciIsIm91dEltYWdlV3JhcHBlciIsImluSW1hZ2VEYXRhIiwib3V0SW1hZ2VEYXRhIiwieVN0YXJ0MSIsInlTdGFydDIiLCJ4U3RhcnQxIiwieFN0YXJ0MiIsImVyb2RlIiwiYUltYWdlV3JhcHBlciIsImJJbWFnZVdyYXBwZXIiLCJyZXN1bHRJbWFnZVdyYXBwZXIiLCJhSW1hZ2VEYXRhIiwiYkltYWdlRGF0YSIsImNJbWFnZURhdGEiLCJiaXR3aXNlT3IiLCJjb3VudE5vblplcm8iLCJ0b3BHZW5lcmljIiwibGlzdCIsInNjb3JlRnVuYyIsIm1pbklkeCIsInF1ZXVlIiwic2NvcmUiLCJoaXQiLCJpdGVtIiwiYXBwbHkiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJncmF5QXJyYXlGcm9tSW1hZ2UiLCJodG1sSW1hZ2UiLCJvZmZzZXRYIiwiY3R4IiwiYXJyYXkiLCJkcmF3SW1hZ2UiLCJjdHhEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwiY29tcHV0ZUdyYXkiLCJncmF5QXJyYXlGcm9tQ29udGV4dCIsIm9mZnNldCIsImdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEiLCJjYW52YXNEYXRhIiwib3V0QXJyYXkiLCJ0b3BSb3dJZHgiLCJib3R0b21Sb3dJZHgiLCJlbmRJZHgiLCJvdXRXaWR0aCIsIm91dEltZ0lkeCIsImluV2lkdGgiLCJjb25maWciLCJsIiwic2luZ2xlQ2hhbm5lbCIsImxvYWRJbWFnZUFycmF5Iiwic3JjIiwiY2FsbGJhY2siLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbWciLCJJbWFnZSIsIm9ubG9hZCIsImdldENvbnRleHQiLCJVaW50OEFycmF5IiwiaGFsZlNhbXBsZSIsImluSW1nV3JhcHBlciIsIm91dEltZ1dyYXBwZXIiLCJpbkltZyIsIm91dEltZyIsImhzdjJyZ2IiLCJoc3YiLCJyZ2IiLCJoIiwicyIsImMiLCJtIiwiciIsImciLCJiIiwiX2NvbXB1dGVEaXZpc29ycyIsIm4iLCJsYXJnZURpdmlzb3JzIiwiZGl2aXNvcnMiLCJzcXJ0IiwidW5zaGlmdCIsImNvbmNhdCIsIl9jb21wdXRlSW50ZXJzZWN0aW9uIiwiYXJyMSIsImFycjIiLCJqIiwiY2FsY3VsYXRlUGF0Y2hTaXplIiwicGF0Y2hTaXplIiwiaW1nU2l6ZSIsImRpdmlzb3JzWCIsImRpdmlzb3JzWSIsIndpZGVTaWRlIiwiY29tbW9uIiwibnJPZlBhdGNoZXNMaXN0IiwibnJPZlBhdGNoZXNNYXAiLCJzbWFsbCIsIm1lZGl1bSIsImxhcmdlIiwibnJPZlBhdGNoZXNJZHgiLCJuck9mUGF0Y2hlcyIsImRlc2lyZWRQYXRjaFNpemUiLCJvcHRpbWFsUGF0Y2hTaXplIiwiZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzIiwiX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzIiwiZGltZW5zaW9uIiwicGFyc2VGbG9hdCIsInVuaXQiLCJpbmRleE9mIiwiX2RpbWVuc2lvbnNDb252ZXJ0ZXJzIiwiY29udGV4dCIsImJvdHRvbSIsImNvbXB1dGVJbWFnZUFyZWEiLCJpbnB1dFdpZHRoIiwiaW5wdXRIZWlnaHQiLCJhcmVhIiwicGFyc2VkQXJlYSIsImtleXMiLCJyZWR1Y2UiLCJwYXJzZWQiLCJjYWxjdWxhdGVkIiwic3giLCJzeSIsInN3Iiwic2giLCJkcmF3UmVjdCIsInN0eWxlIiwic3Ryb2tlU3R5bGUiLCJjb2xvciIsImZpbGxTdHlsZSIsImxpbmVXaWR0aCIsImJlZ2luUGF0aCIsInN0cm9rZVJlY3QiLCJkcmF3UGF0aCIsInBhdGgiLCJkZWYiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJzdHJva2UiLCJjYW52YXNEYXRhUG9zIiwiaW1hZ2VEYXRhUG9zIiwicHV0SW1hZ2VEYXRhIiwiYXJyIiwidmFsIiwiZmlsbCIsInNodWZmbGUiLCJ0b1BvaW50TGlzdCIsInJvd3MiLCJwIiwicm93Iiwiam9pbiIsInByZXYiLCJuZXh0IiwiYXNzZXJ0TnVtYmVyUG9zaXRpdmUiLCJFcnJvciIsIkltYWdlV3JhcHBlciIsIkFycmF5VHlwZSIsImluaXRpYWxpemUiLCJpbWdSZWYiLCJib3JkZXIiLCJzaXplWCIsInNpemVZIiwiaW5kZXhNYXBwaW5nIiwibGFiZWxDb3VudCIsInlzcSIsImxhYmVsU3VtIiwibGFiZWwiLCJtdTExIiwibXUwMiIsIm11MjAiLCJ4XyIsInlfIiwidG1wIiwiUEkiLCJQSV80IiwibTAwIiwibTAxIiwibTEwIiwibTExIiwibTAyIiwibTIwIiwidGhldGEiLCJpc05hTiIsImF0YW4iLCJyZXQiLCJVaW50OENsYW1wZWRBcnJheSIsInBpeGVsIiwiY3VycmVudCIsImdldCIsImZyYW1lIiwiZ2V0QXNSR0JBIiwibmV3RnJhbWUiLCJJbWFnZURhdGEiLCJpblNjYWxlIiwiYWRqdXN0ZWRTY2FsZSIsIndoaXRlUmdiIiwiYmxhY2tSZ2IiLCJhc3luY0dlbmVyYXRvclN0ZXAiLCJnZW4iLCJyZXNvbHZlIiwicmVqZWN0IiwiX25leHQiLCJfdGhyb3ciLCJhcmciLCJpbmZvIiwiZXJyb3IiLCJkb25lIiwiUHJvbWlzZSIsInRoZW4iLCJfYXN5bmNUb0dlbmVyYXRvciIsImZuIiwiYXJncyIsImFyZ3VtZW50cyIsImVyciIsInVuZGVmaW5lZCIsInN1cGVyUHJvcEJhc2UiLCJfZ2V0IiwiUmVmbGVjdCIsInJlY2VpdmVyIiwiYmFzZSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJpc09iamVjdCIsInR5cGUiLCJpc0FycmF5IiwiQXJyYXkiLCJiYXNlTWVyZ2UiLCJjcmVhdGVBc3NpZ25lciIsIm1lcmdlIiwib2JqZWN0Iiwic291cmNlIiwic3JjSW5kZXgiLCJmcmVlR2xvYmFsIiwiZnJlZVNlbGYiLCJyb290IiwiRnVuY3Rpb24iLCJpc09iamVjdExpa2UiLCJTeW1ib2wiLCJpdGVyYXRvciIsInNlYXJjaERpcmVjdGlvbnMiLCJsYWJlbFdyYXBwZXIiLCJsYWJlbERhdGEiLCJlZGdlbGFiZWwiLCJjeSIsImRpciIsImN4IiwidmVydGV4MkQiLCJjb250b3VyVHJhY2luZyIsIkZ2IiwiQ3YiLCJQIiwibGRpciIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJiYXNlR2V0VGFnIiwiX2NvbmZpZyIsIl9jdXJyZW50SW1hZ2VXcmFwcGVyIiwiX3NrZWxJbWFnZVdyYXBwZXIiLCJfc3ViSW1hZ2VXcmFwcGVyIiwiX2xhYmVsSW1hZ2VXcmFwcGVyIiwiX3BhdGNoR3JpZCIsIl9wYXRjaExhYmVsR3JpZCIsIl9pbWFnZVRvUGF0Y2hHcmlkIiwiX2JpbmFyeUltYWdlV3JhcHBlciIsIl9wYXRjaFNpemUiLCJfY2FudmFzQ29udGFpbmVyIiwiYmluYXJ5IiwiZG9tIiwiX251bVBhdGNoZXMiLCJfaW5wdXRJbWFnZVdyYXBwZXIiLCJfc2tlbGV0b25pemVyIiwiaW5pdEJ1ZmZlcnMiLCJza2VsZXRvbkltYWdlRGF0YSIsIkFycmF5QnVmZmVyIiwic2tlbGV0b25pemVyIiwid2luZG93IiwiZ2xvYmFsIiwiaW5pdENhbnZhcyIsInVzZVdvcmtlciIsImNsYXNzTmFtZSIsIkVOViIsImRlYnVnIiwic2hvd0NhbnZhcyIsInF1ZXJ5U2VsZWN0b3IiLCJhcHBlbmRDaGlsZCIsImJveEZyb21QYXRjaGVzIiwicGF0Y2hlcyIsIm92ZXJBdmciLCJwYXRjaCIsInRyYW5zTWF0IiwibWlueCIsIm1pbnkiLCJtYXh4IiwibWF4eSIsImJveCIsInNob3dQYXRjaGVzIiwiSW1hZ2VEZWJ1ZyIsIm1hdDIiLCJzaG93VHJhbnNmb3JtZWQiLCJzaG93VHJhbnNmb3JtZWRCb3giLCJzaG93QkIiLCJiaW5hcml6ZUltYWdlIiwiemVyb0JvcmRlciIsInNob3ciLCJmaW5kUGF0Y2hlcyIsIm1vbWVudHMiLCJwYXRjaGVzRm91bmQiLCJyYXN0ZXJpemVyIiwicmFzdGVyUmVzdWx0Iiwic2tlbGV0b25pemUiLCJSYXN0ZXJpemVyIiwicmFzdGVyaXplIiwic2hvd0xhYmVscyIsIm92ZXJsYXkiLCJjb3VudCIsImRlc2NyaWJlUGF0Y2giLCJzaG93Rm91bmRQYXRjaGVzIiwiZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyIsIm1heExhYmVsIiwibGFiZWxIaXN0IiwidG9wTGFiZWxzIiwibWFwIiwic29ydCIsImEiLCJmaWx0ZXIiLCJlbCIsImZpbmRCb3hlcyIsImJveGVzIiwic2hvd1JlbWFpbmluZ1BhdGNoTGFiZWxzIiwic2ltaWxhck1vbWVudHMiLCJ0b3BDbHVzdGVyIiwiZSIsInN1YkltYWdlQXNDb3B5Iiwic2hvd1NrZWxldG9uIiwicGF0Y2hQb3MiLCJlbGlnaWJsZU1vbWVudHMiLCJtYXRjaGluZ01vbWVudHMiLCJtaW5Db21wb25lbnRXZWlnaHQiLCJpbmRleCIsInJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5IiwiY3VycklkeCIsIm5vdFlldFByb2Nlc3NlZCIsImN1cnJlbnRJZHgiLCJjdXJyZW50UGF0Y2giLCJzaG93UGF0Y2hMYWJlbHMiLCJpbnB1dEltYWdlV3JhcHBlciIsImxvY2F0ZSIsImNoZWNrSW1hZ2VDb25zdHJhaW50cyIsImlucHV0U3RyZWFtIiwiZ2V0V2lkdGgiLCJnZXRIZWlnaHQiLCJ0aGlzSGFsZlNhbXBsZSIsImdldENvbmZpZyIsInNldFRvcFJpZ2h0Iiwic2V0Q2FudmFzU2l6ZSIsImNvbnNvbGUiLCJsb2ciLCJKU09OIiwic3RyaW5naWZ5Iiwic2V0V2lkdGgiLCJzZXRIZWlnaHQiLCJsaXN0Q2FjaGVDbGVhciIsImxpc3RDYWNoZURlbGV0ZSIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIkxpc3RDYWNoZSIsImVudHJpZXMiLCJjbGVhciIsImVudHJ5IiwiaGFzIiwiZXEiLCJhc3NvY0luZGV4T2YiLCJvdGhlciIsImdldE5hdGl2ZSIsIm5hdGl2ZUNyZWF0ZSIsImlzS2V5YWJsZSIsImdldE1hcERhdGEiLCJfX2RhdGFfXyIsImJhc2VJc0FyZ3VtZW50cyIsIm9iamVjdFByb3RvIiwiaGFzT3duUHJvcGVydHkiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImlzQXJndW1lbnRzIiwiTUFYX1NBRkVfSU5URUdFUiIsInJlSXNVaW50IiwiaXNJbmRleCIsInRlc3QiLCJpc0tleSIsInN0cmluZ1RvUGF0aCIsInRvU3RyaW5nIiwiY2FzdFBhdGgiLCJhcnJheVdpdGhvdXRIb2xlcyIsIml0ZXJhYmxlVG9BcnJheSIsInVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5Iiwibm9uSXRlcmFibGVTcHJlYWQiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJkZXRlcm1pbmFudCIsInRyYW5zcG9zZSIsImlkZW50aXR5IiwiYWRqb2ludCIsImludmVydCIsImZyb2IiLCJsZHUiLCJiYXNlSXNOYXRpdmUiLCJnZXRWYWx1ZSIsImFzeW5jVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwiaXNGdW5jdGlvbiIsInRhZyIsImJhc2VBc3NpZ25WYWx1ZSIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiY2hpbGRyZW4iLCJpc0xlbmd0aCIsImlzQXJyYXlMaWtlIiwiX3NldFByb3RvdHlwZU9mIiwic3ltYm9sVGFnIiwiaXNTeW1ib2wiLCJJTkZJTklUWSIsInRvS2V5IiwiTWFwIiwibWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJhc3NpZ25NZXJnZVZhbHVlIiwiZnVuYyIsIm92ZXJBcmciLCJnZXRQcm90b3R5cGUiLCJpc1Byb3RvdHlwZSIsIkN0b3IiLCJwcm90byIsInN0dWJGYWxzZSIsImZyZWVFeHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsIkJ1ZmZlciIsIm5hdGl2ZUlzQnVmZmVyIiwiaXNCdWZmZXIiLCJiYXNlSXNUeXBlZEFycmF5IiwiYmFzZVVuYXJ5Iiwibm9kZVV0aWwiLCJub2RlSXNUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5Iiwic2FmZUdldCIsImFzc2lnblZhbHVlIiwib2JqVmFsdWUiLCJhcnJheUxpa2VLZXlzIiwiYmFzZUtleXNJbiIsImtleXNJbiIsIm5hdGl2ZU1heCIsIm92ZXJSZXN0Iiwic3RhcnQiLCJ0cmFuc2Zvcm0iLCJvdGhlckFyZ3MiLCJiYXNlU2V0VG9TdHJpbmciLCJzaG9ydE91dCIsInNldFRvU3RyaW5nIiwiYXJyYXlMaWtlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm1pbkxlbiIsInNsaWNlIiwibmFtZSIsIl9hcnJheUxpa2VUb0FycmF5Iiwib3V0IiwiRmxvYXQzMkFycmF5IiwieiIsImFycmF5V2l0aEhvbGVzIiwiaXRlcmFibGVUb0FycmF5TGltaXQiLCJub25JdGVyYWJsZVJlc3QiLCJfc2xpY2VkVG9BcnJheSIsImFuZ2xlIiwidHJhbnNmb3JtUXVhdCIsInJvdGF0ZVgiLCJyb3RhdGVZIiwicm90YXRlWiIsImJhc2VQaWNrIiwiZmxhdFJlc3QiLCJwaWNrIiwiaXNOYXRpdmVGdW5jdGlvbiIsImNvbnN0cnVjdCIsIl93cmFwTmF0aXZlU3VwZXIiLCJDbGFzcyIsIl9jYWNoZSIsIldyYXBwZXIiLCJjcmVhdGVDb250b3VyMkQiLCJmaXJzdFZlcnRleCIsImluc2lkZUNvbnRvdXJzIiwibmV4dHBlZXIiLCJwcmV2cGVlciIsIkNPTlRPVVJfRElSIiwiQ1dfRElSIiwiQ0NXX0RJUiIsIlVOS05PV05fRElSIiwiRElSIiwiT1VUU0lERV9FREdFIiwiSU5TSURFX0VER0UiLCJ0cmFjZXIiLCJkZXB0aGxhYmVsIiwiYmMiLCJsYyIsImxhYmVsaW5kZXgiLCJjb2xvck1hcCIsInZlcnRleCIsImNjIiwic2MiLCJjb25uZWN0ZWRDb3VudCIsImRyYXdDb250b3VyIiwiZmlyc3RDb250b3VyIiwicHEiLCJpcSIsInEiLCJTa2VsZXRvbml6ZXIiLCJzdGRsaWIiLCJmb3JlaWduIiwiYnVmZmVyIiwiaW1hZ2VzIiwiaW11bCIsImluSW1hZ2VQdHIiLCJvdXRJbWFnZVB0ciIsImFJbWFnZVB0ciIsImJJbWFnZVB0ciIsImltYWdlUHRyIiwibWVtY3B5Iiwic3JjSW1hZ2VQdHIiLCJkc3RJbWFnZVB0ciIsInN1YkltYWdlUHRyIiwiZXJvZGVkSW1hZ2VQdHIiLCJ0ZW1wSW1hZ2VQdHIiLCJza2VsSW1hZ2VQdHIiLCJTdGFjayIsImJhc2VGb3IiLCJiYXNlTWVyZ2VEZWVwIiwiY3VzdG9taXplciIsInN0YWNrIiwic3JjVmFsdWUiLCJuZXdWYWx1ZSIsInN0YWNrQ2xlYXIiLCJzdGFja0RlbGV0ZSIsInN0YWNrR2V0Iiwic3RhY2tIYXMiLCJzdGFja1NldCIsImFycmF5UHJvdG8iLCJzcGxpY2UiLCJsYXN0SW5kZXgiLCJwb3AiLCJMQVJHRV9BUlJBWV9TSVpFIiwicGFpcnMiLCJpc01hc2tlZCIsInRvU291cmNlIiwicmVSZWdFeHBDaGFyIiwicmVJc0hvc3RDdG9yIiwiZnVuY1Byb3RvIiwiZnVuY1RvU3RyaW5nIiwicmVJc05hdGl2ZSIsIlJlZ0V4cCIsInJlcGxhY2UiLCJwYXR0ZXJuIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJpc093biIsInVubWFza2VkIiwiY29yZUpzRGF0YSIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJleGVjIiwiSUVfUFJPVE8iLCJIYXNoIiwiaGFzaENsZWFyIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkhBU0hfVU5ERUZJTkVEIiwiY3JlYXRlQmFzZUZvciIsImZyb21SaWdodCIsIml0ZXJhdGVlIiwia2V5c0Z1bmMiLCJpdGVyYWJsZSIsImNsb25lQnVmZmVyIiwiY2xvbmVUeXBlZEFycmF5IiwiY29weUFycmF5IiwiaW5pdENsb25lT2JqZWN0IiwiaXNBcnJheUxpa2VPYmplY3QiLCJpc1BsYWluT2JqZWN0IiwidG9QbGFpbk9iamVjdCIsIm1lcmdlRnVuYyIsInN0YWNrZWQiLCJpc0NvbW1vbiIsImlzQXJyIiwiaXNCdWZmIiwiaXNUeXBlZCIsImFsbG9jVW5zYWZlIiwiaXNEZWVwIiwiY2xvbmVBcnJheUJ1ZmZlciIsInR5cGVkQXJyYXkiLCJieXRlT2Zmc2V0IiwiYXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwiYmFzZUNyZWF0ZSIsIm9iamVjdENyZWF0ZSIsImFyZ3NUYWciLCJvYmplY3RUYWciLCJvYmplY3RDdG9yU3RyaW5nIiwiYXJyYXlUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJ0eXBlZEFycmF5VGFncyIsImZyZWVQcm9jZXNzIiwicHJvY2VzcyIsInR5cGVzIiwiYmluZGluZyIsImNvcHlPYmplY3QiLCJpc05ldyIsImJhc2VUaW1lcyIsImluaGVyaXRlZCIsImlzQXJnIiwiaXNUeXBlIiwic2tpcEluZGV4ZXMiLCJTdHJpbmciLCJuYXRpdmVLZXlzSW4iLCJpc1Byb3RvIiwiYmFzZVJlc3QiLCJpc0l0ZXJhdGVlQ2FsbCIsImFzc2lnbmVyIiwic291cmNlcyIsImd1YXJkIiwidGhpc0FyZyIsImNvbnN0YW50Iiwic3RyaW5nIiwiSE9UX0NPVU5UIiwiSE9UX1NQQU4iLCJuYXRpdmVOb3ciLCJEYXRlIiwibm93IiwibGFzdENhbGxlZCIsInN0YW1wIiwicmVtYWluaW5nIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib1JlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2V0VGltZW91dCIsImFoIiwiYWwiLCJiaCIsImJsIiwiYXNzaWduIiwibmV4dFNvdXJjZSIsIm5leHRLZXkiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfaSIsIl9hcnIiLCJfbiIsIl9kIiwiX3MiLCJfZSIsIl9ub25JdGVyYWJsZVJlc3QiLCJhMCIsImExIiwiYjAiLCJiMSIsInQiLCJheCIsImF5Iiwic3RyaWRlIiwibVNxIiwidGVtcEEiLCJ0ZW1wQiIsImNvc2luZSIsImFjb3MiLCJhMiIsImIyIiwiYXoiLCJieCIsImJ5IiwiYnoiLCJ6U2NhbGUiLCJ3IiwicXgiLCJxeSIsInF6IiwicXciLCJpeCIsIml5IiwiaXoiLCJpdyIsInB5IiwicHoiLCJydW50aW1lIiwiT3AiLCJoYXNPd24iLCIkU3ltYm9sIiwiaXRlcmF0b3JTeW1ib2wiLCJhc3luY0l0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsInRvU3RyaW5nVGFnU3ltYm9sIiwid3JhcCIsImlubmVyRm4iLCJvdXRlckZuIiwidHJ5TG9jc0xpc3QiLCJwcm90b0dlbmVyYXRvciIsIkdlbmVyYXRvciIsImdlbmVyYXRvciIsIkNvbnRleHQiLCJfaW52b2tlIiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiR2VuU3RhdGVTdXNwZW5kZWRTdGFydCIsIkdlblN0YXRlU3VzcGVuZGVkWWllbGQiLCJHZW5TdGF0ZUV4ZWN1dGluZyIsIkdlblN0YXRlQ29tcGxldGVkIiwiQ29udGludWVTZW50aW5lbCIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUiLCJJdGVyYXRvclByb3RvdHlwZSIsImdldFByb3RvIiwiTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUiLCJ2YWx1ZXMiLCJHcCIsImRpc3BsYXlOYW1lIiwiZGVmaW5lSXRlcmF0b3JNZXRob2RzIiwibWV0aG9kIiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImdlbkZ1biIsImN0b3IiLCJtYXJrIiwiYXdyYXAiLCJfX2F3YWl0IiwiQXN5bmNJdGVyYXRvciIsIlByb21pc2VJbXBsIiwiaW52b2tlIiwicmVjb3JkIiwidW53cmFwcGVkIiwicHJldmlvdXNQcm9taXNlIiwiZW5xdWV1ZSIsImNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnIiwiYXN5bmMiLCJpdGVyIiwic3RhdGUiLCJkb25lUmVzdWx0IiwiZGVsZWdhdGUiLCJkZWxlZ2F0ZVJlc3VsdCIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsInJlc3VsdE5hbWUiLCJuZXh0TG9jIiwicHVzaFRyeUVudHJ5IiwibG9jcyIsInRyeUxvYyIsImNhdGNoTG9jIiwiZmluYWxseUxvYyIsImFmdGVyTG9jIiwidHJ5RW50cmllcyIsInJlc2V0VHJ5RW50cnkiLCJjb21wbGV0aW9uIiwicmVzZXQiLCJyZXZlcnNlIiwiaXRlcmF0b3JNZXRob2QiLCJza2lwVGVtcFJlc2V0IiwiY2hhckF0Iiwic3RvcCIsInJvb3RFbnRyeSIsInJvb3RSZWNvcmQiLCJydmFsIiwiZXhjZXB0aW9uIiwiaGFuZGxlIiwibG9jIiwiY2F1Z2h0IiwiaGFzQ2F0Y2giLCJoYXNGaW5hbGx5IiwiZmluYWxseUVudHJ5IiwiY29tcGxldGUiLCJmaW5pc2giLCJ0aHJvd24iLCJkZWxlZ2F0ZVlpZWxkIiwicmVnZW5lcmF0b3JSdW50aW1lIiwiYWNjaWRlbnRhbFN0cmljdE1vZGUiLCJfc3VwZXJQcm9wQmFzZSIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJiYXNlUGlja0J5IiwiaGFzSW4iLCJiYXNlR2V0IiwiYmFzZVNldCIsInByZWRpY2F0ZSIsInJlSXNEZWVwUHJvcCIsInJlSXNQbGFpblByb3AiLCJtZW1vaXplQ2FwcGVkIiwicmVQcm9wTmFtZSIsInJlRXNjYXBlQ2hhciIsImNoYXJDb2RlQXQiLCJudW1iZXIiLCJxdW90ZSIsInN1YlN0cmluZyIsIm1lbW9pemUiLCJNQVhfTUVNT0laRV9TSVpFIiwiY2FjaGUiLCJGVU5DX0VSUk9SX1RFWFQiLCJyZXNvbHZlciIsIm1lbW9pemVkIiwiQ2FjaGUiLCJiYXNlVG9TdHJpbmciLCJhcnJheU1hcCIsInN5bWJvbFByb3RvIiwic3ltYm9sVG9TdHJpbmciLCJuZXN0ZWQiLCJiYXNlSGFzSW4iLCJoYXNQYXRoIiwiaGFzRnVuYyIsImZsYXR0ZW4iLCJiYXNlRmxhdHRlbiIsImFycmF5UHVzaCIsImlzRmxhdHRlbmFibGUiLCJkZXB0aCIsImlzU3RyaWN0Iiwic3ByZWFkYWJsZVN5bWJvbCIsImlzQ29uY2F0U3ByZWFkYWJsZSIsIl9pc05hdGl2ZUZ1bmN0aW9uIiwiaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2NvbnN0cnVjdCIsIlBhcmVudCIsImJpbmQiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0Iiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInZhbHVlT2YiLCJhMyIsImIzIiwiZGV0IiwidjAiLCJ2MSIsInBvdyIsIkwiLCJVIiwiQmFyY29kZURpcmVjdGlvbiIsIkJhcmNvZGVSZWFkZXIiLCJzdXBwbGVtZW50cyIsIl9yb3ciLCJjb3VudGVyIiwiY29kZSIsIm1heFNpbmdsZUVycm9yIiwiU0lOR0xFX0NPREVfRVJST1IiLCJzaW5nbGVFcnJvciIsIm1vZHVsbyIsImJhcldpZHRoIiwic2NhbGVkIiwiY29ycmVjdGlvbiIsImluZGljZXMiLCJkZWNvZGUiLCJkaXJlY3Rpb24iLCJSZXZlcnNlIiwiRm9yd2FyZCIsImZvcm1hdCIsIkZPUk1BVCIsIl9uZXh0VW5zZXQiLCJpc1doaXRlIiwiY291bnRlcnMiLCJjb3VudGVyUG9zIiwibnVtQ291bnRlcnMiLCJTdGFydE5vdEZvdW5kRXhjZXB0aW9uIiwiQ29kZU5vdEZvdW5kRXhjZXB0aW9uIiwiUGF0dGVybk5vdEZvdW5kRXhjZXB0aW9uIiwiTiIsIlciLCJTVEFSVF9QQVRURVJOIiwiU1RPUF9QQVRURVJOIiwiQ09ERV9QQVRURVJOIiwiU1RBUlRfUEFUVEVSTl9MRU5HVEgiLCJUd29PZkZpdmVSZWFkZXIiLCJ0cnlIYXJkZXIiLCJiZXN0TWF0Y2giLCJlcHNpbG9uIiwiQVZHX0NPREVfRVJST1IiLCJfbmV4dFNldCIsIl9tYXRjaFBhdHRlcm4iLCJzdGFydEluZm8iLCJuYXJyb3dCYXJXaWR0aCIsImxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQiLCJfZmluZFBhdHRlcm4iLCJfbWF0Y2hSYW5nZSIsImVuZEluZm8iLCJ0cmFpbGluZ1doaXRlc3BhY2VFbmQiLCJfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlIiwiZGVjb2RlZENvZGVzIiwiY291bnRlckxlbmd0aCIsImJhclNwYWNlUmF0aW8iLCJfZGVjb2RlQ29kZSIsIl9maW5kU3RhcnQiLCJfZmluZEVuZCIsIl9maWxsQ291bnRlcnMiLCJfdmVyaWZ5Q291bnRlckxlbmd0aCIsIl9kZWNvZGVQYXlsb2FkIiwiQUxQSEFCRVQiLCJDSEFSQUNURVJfRU5DT0RJTkdTIiwiU1RBUlRfRU5EIiwiTUlOX0VOQ09ERURfQ0hBUlMiLCJNQVhfQUNDRVBUQUJMRSIsIlBBRERJTkciLCJOZXdDb2RhYmFyUmVhZGVyIiwiX2NvdW50ZXJzIiwiYmFyVGhyZXNob2xkIiwiX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZCIsInNwYWNlVGhyZXNob2xkIiwiYml0bWFzayIsIl90b1BhdHRlcm4iLCJfaXNTdGFydEVuZCIsIl9zdW1Db3VudGVycyIsInN0YXJ0Q291bnRlciIsImVuZENvdW50ZXIiLCJmcm9tQ2hhckNvZGUiLCJfY2FsY3VsYXRlUGF0dGVybkxlbmd0aCIsImNoYXIiLCJjaGFyQ29kZSIsImNhdGVnb3JpemF0aW9uIiwic3BhY2UiLCJuYXJyb3ciLCJjb3VudHMiLCJ3aWRlIiwiYmFyIiwiX2NoYXJUb1BhdHRlcm4iLCJraW5kIiwiY2F0IiwibmV3a2luZCIsInRocmVzaG9sZHMiLCJfdGhyZXNob2xkUmVzdWx0UGF0dGVybiIsIm5leHRTdGFydCIsImRlY29kZWRDaGFyIiwiX3BhdHRlcm5Ub0NoYXIiLCJfdmVyaWZ5V2hpdGVzcGFjZSIsIl92YWxpZGF0ZVJlc3VsdCIsIkNvZGUxMjhSZWFkZXIiLCJfY29ycmVjdCIsImNhbGN1bGF0ZUNvcnJlY3Rpb24iLCJNT0RVTEVfSU5ESUNFUyIsIl9jb3JyZWN0QmFycyIsIlNUQVJUX0NPREVfQSIsIlNUQVJUX0NPREVfQyIsImNoZWNrc3VtIiwiY29kZXNldCIsIkNPREVfQSIsIlNUQVJUX0NPREVfQiIsIkNPREVfQiIsIkNPREVfQyIsInNoaWZ0TmV4dCIsInJlbW92ZUxhc3RDaGFyYWN0ZXIiLCJtdWx0aXBsaWVyIiwicmF3UmVzdWx0IiwiU1RPUF9DT0RFIiwiQ09ERV9TSElGVCIsImV4cGVjdGVkIiwibm9ybWFsaXplZCIsInN1bU5vcm1hbGl6ZWQiLCJzdW1FeHBlY3RlZCIsIkFMUEhBQkVUSF9TVFJJTkciLCJVaW50MTZBcnJheSIsIkFTVEVSSVNLIiwiQ29kZTM5UmVhZGVyIiwicGF0dGVyblN0YXJ0Iiwid2hpdGVTcGFjZU11c3RTdGFydCIsIm1heE5hcnJvd1dpZHRoIiwibnVtV2lkZUJhcnMiLCJ3aWRlQmFyV2lkdGgiLCJfZmluZE5leHRXaWR0aCIsIm1pbldpZHRoIiwibGFzdFN0YXJ0IiwicGF0dGVyblNpemUiLCJfdG9Db3VudGVycyIsInBhdHRlcm5zIiwiQUVJTyIsIkFaMDkiLCJjb2RlMzJzZXQiLCJDb2RlMzJSZWFkZXIiLCJyZXMiLCJjb2RlMzIiLCJfY2hlY2tDaGVja3N1bSIsIl9kZWNvZGVDb2RlMzIiLCJJT1EiLCJDb2RlMzlWSU5SZWFkZXIiLCJDb2RlOTNSZWFkZXIiLCJjaGFyQXJyYXkiLCJuZXh0Q2hhciIsIm5leHRDaGFyQ29kZSIsIndhcm4iLCJtYXhXZWlnaHQiLCJhcnJheVRvQ2hlY2siLCJ3ZWlnaHRlZFN1bXMiLCJ3ZWlnaHQiLCJjaGVja0NoYXIiLCJfbWF0Y2hDaGVja0NoYXIiLCJfdmVyaWZ5RW5kIiwiX3ZlcmlmeUNoZWNrc3VtcyIsIl9kZWNvZGVFeHRlbmRlZCIsIkNPREVfR19TVEFSVCIsIk1JRERMRV9QQVRURVJOIiwiRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4iLCJDT0RFX0ZSRVFVRU5DWSIsIkVBTlJlYWRlciIsImNvZGVyYW5nZSIsImNvZGVGcmVxdWVuY3kiLCJpbkNvZGUiLCJvdXRDb2RlIiwiZmlyc3REaWdpdCIsIl9jYWxjdWxhdGVGaXJzdERpZ2l0IiwibWlkZGxlUGF0dGVybiIsInJlc3VsdEluZm8iLCJfY2hlY2tzdW0iLCJzdXBwbGVtZW50IiwiX2RlY29kZUV4dGVuc2lvbnMiLCJsYXN0Q29kZSIsIkVBTjJSZWFkZXIiLCJwYXJzZUludCIsIkNIRUNLX0RJR0lUX0VOQ09ESU5HUyIsImRldGVybWluZUNoZWNrRGlnaXQiLCJleHRlbnNpb25DaGVja3N1bSIsIkVBTjVSZWFkZXIiLCJFQU44UmVhZGVyIiwiSTJvZjVSZWFkZXIiLCJvcHRzIiwibm9ybWFsaXplQmFyU3BhY2VXaWR0aCIsImNvdW50ZXJTdW0iLCJjb2RlU3VtIiwiY29ycmVjdGlvblJhdGlvIiwiTUFYX0NPUlJFQ1RJT05fRkFDVE9SIiwiY29ycmVjdGlvblJhdGlvSW52ZXJzZSIsImNvdW50ZXJQYWlyIiwiY29kZXMiLCJfZGVjb2RlUGFpciIsIlVQQ0VSZWFkZXIiLCJfZGV0ZXJtaW5lUGFyaXR5IiwibnJTeXN0ZW0iLCJ1cGNhIiwibGFzdERpZ2l0IiwiX2NvbnZlcnRUb1VQQ0EiLCJVUENSZWFkZXIiLCJzdWJzdHJpbmciLCJCcmVzZW5oYW0iLCJTbG9wZSIsIlVQIiwiRE9XTiIsImdldEJhcmNvZGVMaW5lIiwieDAiLCJ5MCIsIngxIiwieTEiLCJzdGVlcCIsInJlYWQiLCJkZWx0YVgiLCJkZWx0YVkiLCJ5U3RlcCIsInRvQmluYXJ5TGluZSIsInNsb3BlIiwic2xvcGUyIiwiZXh0cmVtYSIsImN1cnJlbnREaXIiLCJyVGhyZXNob2xkIiwicHJpbnRGcmVxdWVuY3kiLCJwcmludFBhdHRlcm4iLCJmaWxsQ29sb3IiLCJmaWxsUmVjdCIsIlJFQURFUlMiLCJjb2RlXzEyOF9yZWFkZXIiLCJlYW5fcmVhZGVyIiwiZWFuXzVfcmVhZGVyIiwiZWFuXzJfcmVhZGVyIiwiZWFuXzhfcmVhZGVyIiwiY29kZV8zOV9yZWFkZXIiLCJjb2RlXzM5X3Zpbl9yZWFkZXIiLCJjb2RhYmFyX3JlYWRlciIsIkNvZGFiYXJSZWFkZXIiLCJ1cGNfcmVhZGVyIiwidXBjX2VfcmVhZGVyIiwiaTJvZjVfcmVhZGVyIiwiY29kZV85M19yZWFkZXIiLCJjb2RlXzMyX3JlYWRlciIsInJlZ2lzdGVyUmVhZGVyIiwicmVhZGVyIiwiX2NhbnZhcyIsImZyZXF1ZW5jeSIsIl9iYXJjb2RlUmVhZGVycyIsImluaXRSZWFkZXJzIiwiaW5pdENvbmZpZyIsIiRkZWJ1ZyIsInJlYWRlcnMiLCJyZWFkZXJDb25maWciLCJjb25maWd1cmF0aW9uIiwicmVhZGVyT2JqIiwidmlzIiwibm9kZSIsInByb3AiLCJzaG93RnJlcXVlbmN5Iiwic2hvd1BhdHRlcm4iLCJkaXNwbGF5IiwiZ2V0RXh0ZW5kZWRMaW5lIiwiZXh0IiwiZXh0ZW5kTGluZSIsImFtb3VudCIsImV4dGVuc2lvbiIsImluSW1hZ2VXaXRoQm9yZGVyIiwiZ2V0TGluZSIsInRyeURlY29kZSIsImJhcmNvZGVMaW5lIiwiZGVjb2RlUGF0dGVybiIsImNvZGVSZXN1bHQiLCJ0cnlEZWNvZGVCcnV0ZUZvcmNlIiwibGluZUFuZ2xlIiwic2lkZUxlbmd0aCIsInNsaWNlcyIsInhkaXIiLCJ5ZGlyIiwiZ2V0TGluZUxlbmd0aCIsImRlY29kZUZyb21JbWFnZSIsImRlY29kZUltYWdlIiwiZGVjb2RlRnJvbUJvdW5kaW5nQm94IiwiZHJhd0JvdW5kaW5nQm94IiwibGluZUxlbmd0aCIsImF0YW4yIiwiZHJhd1NjYW5saW5lIiwiZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMiLCJiYXJjb2RlcyIsIm11bHRpcGxlIiwiaW1hZ2VXcmFwcGVySW4iLCJzZXRSZWFkZXJzIiwiRXZlbnRJbnRlcmZhY2UiLCJldmVudHMiLCJnZXRFdmVudCIsImV2ZW50TmFtZSIsInN1YnNjcmliZXJzIiwiY2xlYXJFdmVudHMiLCJwdWJsaXNoU3Vic2NyaXB0aW9uIiwic3Vic2NyaXB0aW9uIiwiX3N1YnNjcmliZSIsImV2ZW50Iiwic3Vic2NyaWJlIiwicHVibGlzaCIsInN1YnNjcmliZXIiLCJvbmNlIiwidW5zdWJzY3JpYmUiLCJFeGNlcHRpb24iLCJFUlJPUl9ERVNDIiwiZW51bWVyYXRlRGV2aWNlcyIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsImNvbnN0cmFpbnRzIiwic3RyZWFtUmVmIiwid2FpdEZvclZpZGVvIiwidmlkZW8iLCJhdHRlbXB0cyIsImNoZWNrVmlkZW8iLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJpbml0Q2FtZXJhIiwic3RyZWFtIiwic2V0QXR0cmlidXRlIiwic3JjT2JqZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBsYXkiLCJkZXByZWNhdGVkQ29uc3RyYWludHMiLCJ2aWRlb0NvbnN0cmFpbnRzIiwibWluQXNwZWN0UmF0aW8iLCJhc3BlY3RSYXRpbyIsImZhY2luZyIsImZhY2luZ01vZGUiLCJwaWNrQ29uc3RyYWludHMiLCJkZXZpY2VJZCIsImF1ZGlvIiwiZW51bWVyYXRlVmlkZW9EZXZpY2VzIiwiZGV2aWNlcyIsImRldmljZSIsImdldEFjdGl2ZVRyYWNrIiwidHJhY2tzIiwiZ2V0VmlkZW9UcmFja3MiLCJRdWFnZ2FKU0NhbWVyYUFjY2VzcyIsInJlcXVlc3RlZFZpZGVvRWxlbWVudCIsInJlcXVlc3QiLCJuZXdDb25zdHJhaW50cyIsInJlbGVhc2UiLCJwYXVzZSIsImdldEFjdGl2ZVN0cmVhbUxhYmVsIiwidHJhY2siLCJkaXNhYmxlVG9yY2giLCJhcHBseUNvbnN0cmFpbnRzIiwiYWR2YW5jZWQiLCJ0b3JjaCIsImVuYWJsZVRvcmNoIiwiY29udGFpbnMiLCJzb21lIiwiZXZlcnkiLCJwYXNzZXNGaWx0ZXIiLCJyZXN1bHRzIiwiY2FwYWNpdHkiLCJjYXB0dXJlIiwibWF0Y2hlc0NvbnN0cmFpbnRzIiwiYmxhY2tsaXN0IiwiYWRkUmVzdWx0IiwiaW1hZ2VTaXplIiwidG9EYXRhVVJMIiwiZ2V0UmVzdWx0cyIsIkRldkNvbmZpZyIsIm51bU9mV29ya2VycyIsImRlY29kZXIiLCJsb2NhdG9yIiwiTm9kZUNvbmZpZyIsInNlcXVlbmNlIiwiUHJvZENvbmZpZyIsIlF1YWdnYUNvbmZpZyIsIlRPX1JBRElBTlMiLCJhZGp1c3RDYW52YXNTaXplIiwidGFyZ2V0U2l6ZSIsIkZyYW1lR3JhYmJlciIsIl90aGF0IiwiX3N0cmVhbUNvbmZpZyIsIl92aWRlb1NpemUiLCJnZXRSZWFsV2lkdGgiLCJnZXRSZWFsSGVpZ2h0IiwiX2NhbnZhc1NpemUiLCJnZXRDYW52YXNTaXplIiwiX3NpemUiLCJ0b3BSaWdodCIsImdldFRvcFJpZ2h0IiwiX3N4IiwiX3N5IiwiX2N0eCIsIl9kYXRhIiwidmlkZW9TaXplIiwiY2FudmFzU2l6ZSIsImF0dGFjaERhdGEiLCJnZXREYXRhIiwiZ3JhYiIsImRvSGFsZlNhbXBsZSIsImdldEZyYW1lIiwiZHJhd2FibGUiLCJkcmF3QW5nbGUiLCJ0YWdzIiwib3JpZW50YXRpb24iLCJ0cmFuc2xhdGUiLCJnZXRTaXplIiwiRXhpZlRhZ3MiLCJBdmFpbGFibGVUYWdzIiwiZmluZFRhZ3NJbk9iamVjdFVSTCIsIm9iamVjdFVSTFRvQmxvYiIsInJlYWRUb0J1ZmZlciIsImZpbmRUYWdzSW5CdWZmZXIiLCJiYXNlNjRUb0FycmF5QnVmZmVyIiwiZGF0YVVybCIsImJhc2U2NCIsImF0b2IiLCJ2aWV3IiwiYmxvYiIsImZpbGVSZWFkZXIiLCJGaWxlUmVhZGVyIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJ1cmwiLCJodHRwIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwicmVzcG9uc2VUeXBlIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsIkRPTkUiLCJzdGF0dXMiLCJyZXNwb25zZSIsIm9uZXJyb3IiLCJzZW5kIiwiZmlsZSIsInNlbGVjdGVkVGFncyIsImRhdGFWaWV3IiwiRGF0YVZpZXciLCJleGlmVGFncyIsInNlbGVjdGVkVGFnIiwiZXhpZlRhZyIsIm1hcmtlciIsImdldFVpbnQ4IiwicmVhZEVYSUZEYXRhIiwiZ2V0VWludDE2IiwiZ2V0U3RyaW5nRnJvbUJ1ZmZlciIsInRpZmZPZmZzZXQiLCJiaWdFbmQiLCJmaXJzdElGRE9mZnNldCIsImdldFVpbnQzMiIsInJlYWRUYWdzIiwidGlmZlN0YXJ0IiwiZGlyU3RhcnQiLCJzdHJpbmdzIiwiZW50cnlPZmZzZXQiLCJyZWFkVGFnVmFsdWUiLCJudW1WYWx1ZXMiLCJvdXRzdHIiLCJJbWFnZUxvYWRlciIsImxvYWQiLCJkaXJlY3RvcnkiLCJodG1sSW1hZ2VzU3JjQXJyYXkiLCJodG1sSW1hZ2VzQXJyYXkiLCJudW0iLCJub3RMb2FkZWQiLCJhZGRJbWFnZSIsImltYWdlIiwibG9hZGVkIiwibG9hZGVkSW1nIiwibm90bG9hZGVkSW1ncyIsImltZ05hbWUiLCJzdWJzdHIiLCJsYXN0SW5kZXhPZiIsImFkZE9ubG9hZEhhbmRsZXIiLCJpbnB1dFN0cmVhbUZhY3RvcnkiLCJjcmVhdGVWaWRlb1N0cmVhbSIsIl9ldmVudE5hbWVzIiwiX2V2ZW50SGFuZGxlcnMiLCJfY2FsY3VsYXRlZFdpZHRoIiwiX2NhbGN1bGF0ZWRIZWlnaHQiLCJfdG9wUmlnaHQiLCJpbml0U2l6ZSIsInNldElucHV0U3RyZWFtIiwiZW5kZWQiLCJzZXRDdXJyZW50VGltZSIsInRpbWUiLCJmIiwiYm9vbCIsImNsZWFyRXZlbnRIYW5kbGVycyIsImhhbmRsZXJzIiwiaGFuZGxlciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ0cmlnZ2VyIiwiY3JlYXRlTGl2ZVN0cmVhbSIsImNyZWF0ZUltYWdlU3RyZWFtIiwiZnJhbWVJZHgiLCJwYXVzZWQiLCJpbWdBcnJheSIsImJhc2VVcmwiLCJjYWxjdWxhdGVkV2lkdGgiLCJjYWxjdWxhdGVkSGVpZ2h0IiwibG9hZEltYWdlcyIsImltZ3MiLCJwdWJsaXNoRXZlbnQiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsImluZCIsIlF1YWdnYUNvbnRleHQiLCJDYW52YXNDb250YWluZXIiLCJDYW52YXNJbmZvIiwiZ2V0Vmlld1BvcnQiLCJIVE1MRWxlbWVudCIsIm5vZGVOYW1lIiwic2VsZWN0b3IiLCJib3hTaXplIiwiQmFyY29kZUxvY2F0b3IiLCJmaW5kT3JDcmVhdGVDYW52YXMiLCJnZXRDYW52YXNBbmRDb250ZXh0IiwiaW5pdENhbnZhc2VzIiwidmlld3BvcnQiLCJjb250YWluZXIiLCJ3b3JrZXJQb29sIiwidXBkYXRlV29ya2VycyIsImZyYW1lR3JhYmJlciIsImF2YWlsYWJsZVdvcmtlciIsIndvcmtlclRocmVhZCIsImJ1c3kiLCJ3b3JrZXIiLCJwb3N0TWVzc2FnZSIsImNtZCIsImNvbmZpZ0ZvcldvcmtlciIsIndvcmtlckludGVyZmFjZSIsImZhY3RvcnkiLCJRdWFnZ2EiLCJtZXNzYWdlIiwib25Qcm9jZXNzZWQiLCJ3b3JrZXJJbnRlcmZhY2VSZWFkeSIsIm9ubWVzc2FnZSIsImdlbmVyYXRlV29ya2VyQmxvYiIsImZhY3RvcnlTb3VyY2UiLCJfX2ZhY3RvcnlTb3VyY2VfXyIsIkJsb2IiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJpbml0V29ya2VyIiwiY2IiLCJibG9iVVJMIiwiV29ya2VyIiwicmV2b2tlT2JqZWN0VVJMIiwiYWRqdXN0V29ya2VyUG9vbCIsImluY3JlYXNlQnkiLCJ3b3JrZXJzVG9UZXJtaW5hdGUiLCJ0ZXJtaW5hdGUiLCJ3b3JrZXJJbml0aWFsaXplZCIsInNldHVwSW5wdXRTdHJlYW0iLCJtb3ZlQm94IiwieE9mZnNldCIsInlPZmZzZXQiLCJjb3JuZXIiLCJtb3ZlTGluZSIsImZyYW1lZ3JhYmJlciIsImNhbnZhc0NvbnRhaW5lciIsIlFXb3JrZXJzIiwiaW5pdGlhbGl6ZURhdGEiLCJyZWFkeSIsIm9uVUlUaHJlYWQiLCJ3b3JrZXJzVXBkYXRlZCIsImxvY2F0ZUFuZERlY29kZSIsIl9pbml0QnVmZmVycyIsIkJhcmNvZGVEZWNvZGVyIiwiX2dldFZpZXdQb3J0IiwiX2luaXRDYW52YXMiLCJpbnB1dFR5cGUiLCJJbnB1dFN0cmVhbSIsIkNhbWVyYUFjY2VzcyIsImNhblJlY29yZCIsImJhcmNvZGUiLCJ0cmFuc2Zvcm1SZXN1bHQiLCJyZXN1bHRDb2xsZWN0b3IiLCJyZXN1bHRUb1B1Ymxpc2giLCJFdmVudHMiLCJoYXNDb2RlUmVzdWx0IiwiZ2V0Qm91bmRpbmdCb3hlcyIsImRlY29kZVJlc3VsdCIsInB1Ymxpc2hSZXN1bHQiLCJpbWFnZVJlc3VsdCIsImRlbGF5Iiwic3RvcHBlZCIsInRpbWVzdGFtcCIsInVwZGF0ZSIsInBlcmZvcm1hbmNlIiwic3RhcnRDb250aW51b3VzVXBkYXRlIiwiX2NvbnRleHQiLCJRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZSIsInF1YWdnYUluc3RhbmNlIiwicHJvbWlzZSIsIkNvbmZpZyIsImluaXRJbnB1dFN0cmVhbSIsIm9uRGV0ZWN0ZWQiLCJvZmZEZXRlY3RlZCIsIm9mZlByb2Nlc3NlZCIsInJlZ2lzdGVyUmVzdWx0Q29sbGVjdG9yIiwiZGVjb2RlU2luZ2xlIiwicmVzdWx0Q2FsbGJhY2siLCJkZWZhdWx0IiwiUmVhZGVycyIsIlJlc3VsdENvbGxlY3RvciJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87UUNWQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7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TyxFQUlQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FKTyxFQUtQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FMTyxFQU1QLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FOTyxFQU9QLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FQTyxFQVFQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FSTyxFQVNQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FUTyxFQVVQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FWTyxFQVdQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FYTyxFQVlQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FaTyxFQWFQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FiTyxFQWNQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FkTyxFQWVQLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FmTyxFQWdCUCxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FB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QUFDVixXQUFPWCx1QkFBUDtBQUNILEdBN0gyQjs7QUE4SDVCWSxTQUFPLEVBQVBBLHNCQTlINEI7QUErSDVCL0IsY0FBWSxFQUFaQSxhQS9INEI7QUFnSTVCcG5DLFlBQVUsRUFBVkEsOEJBaEk0QjtBQWlJNUJqSixjQUFZLEVBQVpBLGdDQWpJNEI7QUFrSTVCcXlDLGlCQUFlLEVBQWZBLGdCQUFlQTtBQWxJYSxDQUFoQztBQXFJZWIsbUdBQWYsRSxDQUNBIiwiZmlsZSI6InF1YWdnYS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlF1YWdnYVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJRdWFnZ2FcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gODkpO1xuIiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjaywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzcywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qc1wiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZi5qc1wiKTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVQU0lMT046IHJlcXVpcmUoJy4vZXBzaWxvbicpXG4gICwgY3JlYXRlOiByZXF1aXJlKCcuL2NyZWF0ZScpXG4gICwgY2xvbmU6IHJlcXVpcmUoJy4vY2xvbmUnKVxuICAsIGZyb21WYWx1ZXM6IHJlcXVpcmUoJy4vZnJvbVZhbHVlcycpXG4gICwgY29weTogcmVxdWlyZSgnLi9jb3B5JylcbiAgLCBzZXQ6IHJlcXVpcmUoJy4vc2V0JylcbiAgLCBlcXVhbHM6IHJlcXVpcmUoJy4vZXF1YWxzJylcbiAgLCBleGFjdEVxdWFsczogcmVxdWlyZSgnLi9leGFjdEVxdWFscycpXG4gICwgYWRkOiByZXF1aXJlKCcuL2FkZCcpXG4gICwgc3VidHJhY3Q6IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuICAsIHN1YjogcmVxdWlyZSgnLi9zdWInKVxuICAsIG11bHRpcGx5OiByZXF1aXJlKCcuL211bHRpcGx5JylcbiAgLCBtdWw6IHJlcXVpcmUoJy4vbXVsJylcbiAgLCBkaXZpZGU6IHJlcXVpcmUoJy4vZGl2aWRlJylcbiAgLCBkaXY6IHJlcXVpcmUoJy4vZGl2JylcbiAgLCBpbnZlcnNlOiByZXF1aXJlKCcuL2ludmVyc2UnKVxuICAsIG1pbjogcmVxdWlyZSgnLi9taW4nKVxuICAsIG1heDogcmVxdWlyZSgnLi9tYXgnKVxuICAsIHJvdGF0ZTogcmVxdWlyZSgnLi9yb3RhdGUnKVxuICAsIGZsb29yOiByZXF1aXJlKCcuL2Zsb29yJylcbiAgLCBjZWlsOiByZXF1aXJlKCcuL2NlaWwnKVxuICAsIHJvdW5kOiByZXF1aXJlKCcuL3JvdW5kJylcbiAgLCBzY2FsZTogcmVxdWlyZSgnLi9zY2FsZScpXG4gICwgc2NhbGVBbmRBZGQ6IHJlcXVpcmUoJy4vc2NhbGVBbmRBZGQnKVxuICAsIGRpc3RhbmNlOiByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbiAgLCBkaXN0OiByZXF1aXJlKCcuL2Rpc3QnKVxuICAsIHNxdWFyZWREaXN0YW5jZTogcmVxdWlyZSgnLi9zcXVhcmVkRGlzdGFuY2UnKVxuICAsIHNxckRpc3Q6IHJlcXVpcmUoJy4vc3FyRGlzdCcpXG4gICwgbGVuZ3RoOiByZXF1aXJlKCcuL2xlbmd0aCcpXG4gICwgbGVuOiByZXF1aXJlKCcuL2xlbicpXG4gICwgc3F1YXJlZExlbmd0aDogcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiAgLCBzcXJMZW46IHJlcXVpcmUoJy4vc3FyTGVuJylcbiAgLCBuZWdhdGU6IHJlcXVpcmUoJy4vbmVnYXRlJylcbiAgLCBub3JtYWxpemU6IHJlcXVpcmUoJy4vbm9ybWFsaXplJylcbiAgLCBkb3Q6IHJlcXVpcmUoJy4vZG90JylcbiAgLCBjcm9zczogcmVxdWlyZSgnLi9jcm9zcycpXG4gICwgbGVycDogcmVxdWlyZSgnLi9sZXJwJylcbiAgLCByYW5kb206IHJlcXVpcmUoJy4vcmFuZG9tJylcbiAgLCB0cmFuc2Zvcm1NYXQyOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDInKVxuICAsIHRyYW5zZm9ybU1hdDJkOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDJkJylcbiAgLCB0cmFuc2Zvcm1NYXQzOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDMnKVxuICAsIHRyYW5zZm9ybU1hdDQ6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0NCcpXG4gICwgZm9yRWFjaDogcmVxdWlyZSgnLi9mb3JFYWNoJylcbiAgLCBsaW1pdDogcmVxdWlyZSgnLi9saW1pdCcpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwiLy8gVE9ETzogY2x1c3Rlci5qcyBhbmQgY3ZfdXRpbHMuanMgYXJlIHByZXR0eSB0aWdodGx5IGludGVydHdpbmVkLCBtYWtpbmcgZm9yIGEgY29tcGxleCBjb252ZXJzaW9uXG4vLyBpbnRvIHR5cGVzY3JpcHQuIGJlIHdhcm5lZC4gOi0pXG5cbmltcG9ydCB7IGNsb25lLCBkb3QgfSBmcm9tICdnbC12ZWMyJztcblxuY29uc3QgdmVjMiA9IHsgY2xvbmUsIGRvdCB9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbHVzdGVyIGZvciBncm91cGluZyBzaW1pbGFyIG9yaWVudGF0aW9ucyBvZiBkYXRhcG9pbnRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBjcmVhdGUocG9pbnQsIHRocmVzaG9sZCkge1xuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgY29uc3QgY2VudGVyID0ge1xuICAgICAgICAgICAgcmFkOiAwLFxuICAgICAgICAgICAgdmVjOiB2ZWMyLmNsb25lKFswLCAwXSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBvaW50TWFwID0ge307XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkKHBvaW50VG9BZGQpIHtcbiAgICAgICAgICAgIHBvaW50TWFwW3BvaW50VG9BZGQuaWRdID0gcG9pbnRUb0FkZDtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50VG9BZGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ2VudGVyKCkge1xuICAgICAgICAgICAgbGV0IGk7IGxldFxuICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IHBvaW50c1tpXS5yYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZW50ZXIucmFkID0gc3VtIC8gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGNlbnRlci52ZWMgPSB2ZWMyLmNsb25lKFtNYXRoLmNvcyhjZW50ZXIucmFkKSwgTWF0aC5zaW4oY2VudGVyLnJhZCldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgICBhZGQocG9pbnQpO1xuICAgICAgICAgICAgdXBkYXRlQ2VudGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbml0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZChwb2ludFRvQWRkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwb2ludE1hcFtwb2ludFRvQWRkLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBhZGQocG9pbnRUb0FkZCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNlbnRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXRzKG90aGVyUG9pbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBjb3NpbmUgc2ltaWxhcml0eSB0byBjZW50ZXItYW5nbGVcbiAgICAgICAgICAgICAgICBjb25zdCBzaW1pbGFyaXR5ID0gTWF0aC5hYnModmVjMi5kb3Qob3RoZXJQb2ludC5wb2ludC52ZWMsIGNlbnRlci52ZWMpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2ltaWxhcml0eSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFBvaW50cygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENlbnRlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2VudGVyO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNyZWF0ZVBvaW50KG5ld1BvaW50LCBpZCwgcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhZDogbmV3UG9pbnRbcHJvcGVydHldLFxuICAgICAgICAgICAgcG9pbnQ6IG5ld1BvaW50LFxuICAgICAgICAgICAgaWQsXG4gICAgICAgIH07XG4gICAgfSxcbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1taXhlZC1vcGVyYXRvcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbmltcG9ydCB7IGNsb25lIGFzIHYyY2xvbmUgfSBmcm9tICdnbC12ZWMyJztcbmltcG9ydCB7IGNsb25lIGFzIHYzY2xvbmUgfSBmcm9tICdnbC12ZWMzJztcbmltcG9ydCBDbHVzdGVyMiBmcm9tICcuL2NsdXN0ZXInO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4vYXJyYXlfaGVscGVyJztcblxuY29uc3QgdmVjMiA9IHsgY2xvbmU6IHYyY2xvbmUgfTtcbmNvbnN0IHZlYzMgPSB7IGNsb25lOiB2M2Nsb25lIH07XG5cbi8qKlxuICogQHBhcmFtIHggeC1jb29yZGluYXRlXG4gKiBAcGFyYW0geSB5LWNvb3JkaW5hdGVcbiAqIEByZXR1cm4gSW1hZ2VSZWZlcmVuY2Uge3gseX0gQ29vcmRpbmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW1hZ2VSZWYoeCwgeSkge1xuICAgIGNvbnN0IHRoYXQgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHRvVmVjMigpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZWMyLmNsb25lKFt0aGlzLngsIHRoaXMueV0pO1xuICAgICAgICB9LFxuICAgICAgICB0b1ZlYzMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmVjMy5jbG9uZShbdGhpcy54LCB0aGlzLnksIDFdKTtcbiAgICAgICAgfSxcbiAgICAgICAgcm91bmQoKSB7XG4gICAgICAgICAgICB0aGlzLnggPSB0aGlzLnggPiAwLjAgPyBNYXRoLmZsb29yKHRoaXMueCArIDAuNSkgOiBNYXRoLmZsb29yKHRoaXMueCAtIDAuNSk7XG4gICAgICAgICAgICB0aGlzLnkgPSB0aGlzLnkgPiAwLjAgPyBNYXRoLmZsb29yKHRoaXMueSArIDAuNSkgOiBNYXRoLmZsb29yKHRoaXMueSAtIDAuNSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiB0aGF0O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIGludGVncmFsIGltYWdlIG9mIGEgZ2l2ZW4gZ3JheXNjYWxlIGltYWdlLlxuICogQHBhcmFtIGltYWdlRGF0YUNvbnRhaW5lciB7SW1hZ2VEYXRhQ29udGFpbmVyfSB0aGUgaW1hZ2UgdG8gYmUgaW50ZWdyYXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUludGVncmFsSW1hZ2UyKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKSB7XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGNvbnN0IGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgY29uc3QgaW50ZWdyYWxJbWFnZURhdGEgPSBpbnRlZ3JhbFdyYXBwZXIuZGF0YTtcbiAgICBsZXQgc3VtID0gMDsgbGV0IHBvc0EgPSAwOyBsZXQgcG9zQiA9IDA7IGxldCBwb3NDID0gMDsgbGV0IHBvc0QgPSAwOyBsZXQgeDsgbGV0XG4gICAgICAgIHk7XG5cbiAgICAvLyBzdW0gdXAgZmlyc3QgY29sdW1uXG4gICAgcG9zQiA9IHdpZHRoO1xuICAgIHN1bSA9IDA7XG4gICAgZm9yICh5ID0gMTsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbcG9zQV07XG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW3Bvc0JdICs9IHN1bTtcbiAgICAgICAgcG9zQSArPSB3aWR0aDtcbiAgICAgICAgcG9zQiArPSB3aWR0aDtcbiAgICB9XG5cbiAgICBwb3NBID0gMDtcbiAgICBwb3NCID0gMTtcbiAgICBzdW0gPSAwO1xuICAgIGZvciAoeCA9IDE7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbcG9zQV07XG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW3Bvc0JdICs9IHN1bTtcbiAgICAgICAgcG9zQSsrO1xuICAgICAgICBwb3NCKys7XG4gICAgfVxuXG4gICAgZm9yICh5ID0gMTsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIHBvc0EgPSB5ICogd2lkdGggKyAxO1xuICAgICAgICBwb3NCID0gKHkgLSAxKSAqIHdpZHRoICsgMTtcbiAgICAgICAgcG9zQyA9IHkgKiB3aWR0aDtcbiAgICAgICAgcG9zRCA9ICh5IC0gMSkgKiB3aWR0aDtcbiAgICAgICAgZm9yICh4ID0gMTsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIGludGVncmFsSW1hZ2VEYXRhW3Bvc0FdXG4gICAgICAgICAgICAgICAgKz0gaW1hZ2VEYXRhW3Bvc0FdICsgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKyBpbnRlZ3JhbEltYWdlRGF0YVtwb3NDXSAtIGludGVncmFsSW1hZ2VEYXRhW3Bvc0RdO1xuICAgICAgICAgICAgcG9zQSsrO1xuICAgICAgICAgICAgcG9zQisrO1xuICAgICAgICAgICAgcG9zQysrO1xuICAgICAgICAgICAgcG9zRCsrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUludGVncmFsSW1hZ2UoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIpIHtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIGxldCBzdW0gPSAwO1xuXG4gICAgLy8gc3VtIHVwIGZpcnN0IHJvd1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW2ldO1xuICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVtpXSA9IHN1bTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCB2ID0gMTsgdiA8IGhlaWdodDsgdisrKSB7XG4gICAgICAgIHN1bSA9IDA7XG4gICAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgd2lkdGg7IHUrKykge1xuICAgICAgICAgICAgc3VtICs9IGltYWdlRGF0YVt2ICogd2lkdGggKyB1XTtcbiAgICAgICAgICAgIGludGVncmFsSW1hZ2VEYXRhWygodikgKiB3aWR0aCkgKyB1XSA9IHN1bSArIGludGVncmFsSW1hZ2VEYXRhWyh2IC0gMSkgKiB3aWR0aCArIHVdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGhyZXNob2xkSW1hZ2UoaW1hZ2VXcmFwcGVyLCB0aHJlc2hvbGQsIHRhcmdldFdyYXBwZXIpIHtcbiAgICBpZiAoIXRhcmdldFdyYXBwZXIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHRhcmdldFdyYXBwZXIgPSBpbWFnZVdyYXBwZXI7XG4gICAgfVxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhOyBsZXQgeyBsZW5ndGggfSA9IGltYWdlRGF0YTsgY29uc3RcbiAgICAgICAgdGFyZ2V0RGF0YSA9IHRhcmdldFdyYXBwZXIuZGF0YTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB0YXJnZXREYXRhW2xlbmd0aF0gPSBpbWFnZURhdGFbbGVuZ3RoXSA8IHRocmVzaG9sZCA/IDEgOiAwO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVIaXN0b2dyYW0oaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwpIHtcbiAgICBpZiAoIWJpdHNQZXJQaXhlbCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgYml0c1BlclBpeGVsID0gODtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBpbWFnZURhdGE7XG4gICAgY29uc3QgYml0U2hpZnQgPSA4IC0gYml0c1BlclBpeGVsO1xuICAgIGNvbnN0IGJ1Y2tldENudCA9IDEgPDwgYml0c1BlclBpeGVsO1xuICAgIGNvbnN0IGhpc3QgPSBuZXcgSW50MzJBcnJheShidWNrZXRDbnQpO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGhpc3RbaW1hZ2VEYXRhW2xlbmd0aF0gPj4gYml0U2hpZnRdKys7XG4gICAgfVxuICAgIHJldHVybiBoaXN0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hhcnBlbkxpbmUobGluZSkge1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBsaW5lO1xuICAgIGxldCBsZWZ0ID0gbGluZVswXTtcbiAgICBsZXQgY2VudGVyID0gbGluZVsxXTtcbiAgICBsZXQgcmlnaHQ7XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHJpZ2h0ID0gbGluZVtpICsgMV07XG4gICAgICAgIC8vICAtMSA0IC0xIGtlcm5lbFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgbGluZVtpIC0gMV0gPSAoKChjZW50ZXIgKiAyKSAtIGxlZnQgLSByaWdodCkpICYgMjU1O1xuICAgICAgICBsZWZ0ID0gY2VudGVyO1xuICAgICAgICBjZW50ZXIgPSByaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVPdHN1VGhyZXNob2xkKGltYWdlV3JhcHBlciwgYml0c1BlclBpeGVsID0gOCkge1xuICAgIGxldCBoaXN0O1xuICAgIGNvbnN0IGJpdFNoaWZ0ID0gOCAtIGJpdHNQZXJQaXhlbDtcblxuICAgIGZ1bmN0aW9uIHB4KGluaXQsIGVuZCkge1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGluaXQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBoaXN0W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXgoaW5pdCwgZW5kKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBpbml0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gaSAqIGhpc3RbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRldGVybWluZVRocmVzaG9sZCgpIHtcbiAgICAgICAgY29uc3QgdmV0ID0gWzBdO1xuICAgICAgICBsZXQgcDE7XG4gICAgICAgIGxldCBwMjtcbiAgICAgICAgbGV0IHAxMjtcbiAgICAgICAgbGV0IG0xO1xuICAgICAgICBsZXQgbTI7XG4gICAgICAgIGxldCBtMTI7XG4gICAgICAgIGNvbnN0IG1heCA9ICgxIDw8IGJpdHNQZXJQaXhlbCkgLSAxO1xuXG4gICAgICAgIGhpc3QgPSBjb21wdXRlSGlzdG9ncmFtKGltYWdlV3JhcHBlciwgYml0c1BlclBpeGVsKTtcbiAgICAgICAgZm9yIChsZXQgayA9IDE7IGsgPCBtYXg7IGsrKykge1xuICAgICAgICAgICAgcDEgPSBweCgwLCBrKTtcbiAgICAgICAgICAgIHAyID0gcHgoayArIDEsIG1heCk7XG4gICAgICAgICAgICBwMTIgPSBwMSAqIHAyO1xuICAgICAgICAgICAgaWYgKHAxMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHAxMiA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtMSA9IG14KDAsIGspICogcDI7XG4gICAgICAgICAgICBtMiA9IG14KGsgKyAxLCBtYXgpICogcDE7XG4gICAgICAgICAgICBtMTIgPSBtMSAtIG0yO1xuICAgICAgICAgICAgdmV0W2tdID0gbTEyICogbTEyIC8gcDEyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnJheUhlbHBlci5tYXhJbmRleCh2ZXQpO1xuICAgIH1cblxuICAgIGNvbnN0IHRocmVzaG9sZCA9IGRldGVybWluZVRocmVzaG9sZCgpO1xuICAgIHJldHVybiB0aHJlc2hvbGQgPDwgYml0U2hpZnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvdHN1VGhyZXNob2xkKGltYWdlV3JhcHBlciwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IGRldGVybWluZU90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyKTtcblxuICAgIHRocmVzaG9sZEltYWdlKGltYWdlV3JhcHBlciwgdGhyZXNob2xkLCB0YXJnZXRXcmFwcGVyKTtcbiAgICByZXR1cm4gdGhyZXNob2xkO1xufVxuXG4vLyBsb2NhbCB0aHJlc2hvbGRpbmdcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQmluYXJ5SW1hZ2UoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIsIHRhcmdldFdyYXBwZXIpIHtcbiAgICBjb21wdXRlSW50ZWdyYWxJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlcik7XG5cbiAgICBpZiAoIXRhcmdldFdyYXBwZXIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHRhcmdldFdyYXBwZXIgPSBpbWFnZVdyYXBwZXI7XG4gICAgfVxuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHRhcmdldERhdGEgPSB0YXJnZXRXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGNvbnN0IGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgY29uc3QgaW50ZWdyYWxJbWFnZURhdGEgPSBpbnRlZ3JhbFdyYXBwZXIuZGF0YTtcbiAgICBsZXQgc3VtID0gMDsgbGV0IHY7IGxldCB1OyBjb25zdCBrZXJuZWwgPSAzOyBsZXQgQTsgbGV0IEI7IGxldCBDOyBsZXQgRDsgbGV0IGF2ZzsgY29uc3RcbiAgICAgICAgc2l6ZSA9IChrZXJuZWwgKiAyICsgMSkgKiAoa2VybmVsICogMiArIDEpO1xuXG4gICAgLy8gY2xlYXIgb3V0IHRvcCAmIGJvdHRvbS1ib3JkZXJcbiAgICBmb3IgKHYgPSAwOyB2IDw9IGtlcm5lbDsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XG4gICAgICAgICAgICB0YXJnZXREYXRhWygodikgKiB3aWR0aCkgKyB1XSA9IDA7XG4gICAgICAgICAgICB0YXJnZXREYXRhWygoKGhlaWdodCAtIDEpIC0gdikgKiB3aWR0aCkgKyB1XSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjbGVhciBvdXQgbGVmdCAmIHJpZ2h0IGJvcmRlclxuICAgIGZvciAodiA9IGtlcm5lbDsgdiA8IGhlaWdodCAtIGtlcm5lbDsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IDA7IHUgPD0ga2VybmVsOyB1KyspIHtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArICh3aWR0aCAtIDEgLSB1KV0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2ID0ga2VybmVsICsgMTsgdiA8IGhlaWdodCAtIGtlcm5lbCAtIDE7IHYrKykge1xuICAgICAgICBmb3IgKHUgPSBrZXJuZWwgKyAxOyB1IDwgd2lkdGggLSBrZXJuZWw7IHUrKykge1xuICAgICAgICAgICAgQSA9IGludGVncmFsSW1hZ2VEYXRhWyh2IC0ga2VybmVsIC0gMSkgKiB3aWR0aCArICh1IC0ga2VybmVsIC0gMSldO1xuICAgICAgICAgICAgQiA9IGludGVncmFsSW1hZ2VEYXRhWyh2IC0ga2VybmVsIC0gMSkgKiB3aWR0aCArICh1ICsga2VybmVsKV07XG4gICAgICAgICAgICBDID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgKyBrZXJuZWwpICogd2lkdGggKyAodSAtIGtlcm5lbCAtIDEpXTtcbiAgICAgICAgICAgIEQgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiArIGtlcm5lbCkgKiB3aWR0aCArICh1ICsga2VybmVsKV07XG4gICAgICAgICAgICBzdW0gPSBEIC0gQyAtIEIgKyBBO1xuICAgICAgICAgICAgYXZnID0gc3VtIC8gKHNpemUpO1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVt2ICogd2lkdGggKyB1XSA9IGltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA+IChhdmcgKyA1KSA/IDAgOiAxO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2x1c3Rlcihwb2ludHMsIHRocmVzaG9sZCwgcHJvcGVydHkpIHtcbiAgICBsZXQgaTsgbGV0IGs7IGxldCB0aGlzQ2x1c3RlcjsgbGV0IHBvaW50OyBjb25zdFxuICAgICAgICBjbHVzdGVycyA9IFtdO1xuXG4gICAgaWYgKCFwcm9wZXJ0eSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcHJvcGVydHkgPSAncmFkJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUb0NsdXN0ZXIobmV3UG9pbnQpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBjbHVzdGVycy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdGhpc0NsdXN0ZXIgPSBjbHVzdGVyc1trXTtcbiAgICAgICAgICAgIGlmICh0aGlzQ2x1c3Rlci5maXRzKG5ld1BvaW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXNDbHVzdGVyLmFkZChuZXdQb2ludCk7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgZWFjaCBjbG91ZFxuICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSBDbHVzdGVyMi5jcmVhdGVQb2ludChwb2ludHNbaV0sIGksIHByb3BlcnR5KTtcbiAgICAgICAgaWYgKCFhZGRUb0NsdXN0ZXIocG9pbnQpKSB7XG4gICAgICAgICAgICBjbHVzdGVycy5wdXNoKENsdXN0ZXIyLmNyZWF0ZShwb2ludCwgdGhyZXNob2xkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xufVxuXG5leHBvcnQgY29uc3QgVHJhY2VyID0ge1xuICAgIHRyYWNlKHBvaW50cywgdmVjKSB7XG4gICAgICAgIGxldCBpdGVyYXRpb247XG4gICAgICAgIGNvbnN0IG1heEl0ZXJhdGlvbnMgPSAxMDtcbiAgICAgICAgbGV0IHRvcCA9IFtdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBjZW50ZXJQb3MgPSAwO1xuICAgICAgICBsZXQgY3VycmVudFBvcyA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gdHJhY2UoaWR4LCBmb3J3YXJkKSB7XG4gICAgICAgICAgICBsZXQgdG87XG4gICAgICAgICAgICBsZXQgdG9JZHg7XG4gICAgICAgICAgICBsZXQgcHJlZGljdGVkUG9zO1xuICAgICAgICAgICAgY29uc3QgdGhyZXNob2xkWCA9IDE7XG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGRZID0gTWF0aC5hYnModmVjWzFdIC8gMTApO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1hdGNoKHBvcywgcHJlZGljdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcy54ID4gKHByZWRpY3RlZC54IC0gdGhyZXNob2xkWClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHBvcy54IDwgKHByZWRpY3RlZC54ICsgdGhyZXNob2xkWClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHBvcy55ID4gKHByZWRpY3RlZC55IC0gdGhyZXNob2xkWSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHBvcy55IDwgKHByZWRpY3RlZC55ICsgdGhyZXNob2xkWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG5leHQgaW5kZXggaXMgd2l0aGluIHRoZSB2ZWMgc3BlY2lmaWNhdGlvbnNcbiAgICAgICAgICAgIC8vIGlmIG5vdCwgY2hlY2sgYXMgbG9uZyBhcyB0aGUgdGhyZXNob2xkIGlzIG1ldFxuXG4gICAgICAgICAgICBjb25zdCBmcm9tID0gcG9pbnRzW2lkeF07XG4gICAgICAgICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICAgICAgICAgIHByZWRpY3RlZFBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZnJvbS54ICsgdmVjWzBdLFxuICAgICAgICAgICAgICAgICAgICB5OiBmcm9tLnkgKyB2ZWNbMV0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlZGljdGVkUG9zID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBmcm9tLnggLSB2ZWNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHk6IGZyb20ueSAtIHZlY1sxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b0lkeCA9IGZvcndhcmQgPyBpZHggKyAxIDogaWR4IC0gMTtcbiAgICAgICAgICAgIHRvID0gcG9pbnRzW3RvSWR4XTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICAgICAgd2hpbGUgKHRvICYmIChmb3VuZCA9IG1hdGNoKHRvLCBwcmVkaWN0ZWRQb3MpKSAhPT0gdHJ1ZSAmJiAoTWF0aC5hYnModG8ueSAtIGZyb20ueSkgPCB2ZWNbMV0pKSB7XG4gICAgICAgICAgICAgICAgdG9JZHggPSBmb3J3YXJkID8gdG9JZHggKyAxIDogdG9JZHggLSAxO1xuICAgICAgICAgICAgICAgIHRvID0gcG9pbnRzW3RvSWR4XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kID8gdG9JZHggOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpdGVyYXRpb24gPSAwOyBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zOyBpdGVyYXRpb24rKykge1xuICAgICAgICAgICAgLy8gcmFuZG9tbHkgc2VsZWN0IHBvaW50IHRvIHN0YXJ0IHdpdGhcbiAgICAgICAgICAgIGNlbnRlclBvcyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvaW50cy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAvLyB0cmFjZSBmb3J3YXJkXG4gICAgICAgICAgICB0b3AgPSBbXTtcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBjZW50ZXJQb3M7XG4gICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnRQb3MgPSB0cmFjZShjdXJyZW50UG9zLCB0cnVlKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNlbnRlclBvcyA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zID0gY2VudGVyUG9zO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICAgICAgICAgIHdoaWxlICgoY3VycmVudFBvcyA9IHRyYWNlKGN1cnJlbnRQb3MsIGZhbHNlKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wLnB1c2gocG9pbnRzW2N1cnJlbnRQb3NdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0b3AubGVuZ3RoID4gcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG59O1xuXG5leHBvcnQgY29uc3QgRElMQVRFID0gMTtcbmV4cG9ydCBjb25zdCBFUk9ERSA9IDI7XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWxhdGUoaW5JbWFnZVdyYXBwZXIsIG91dEltYWdlV3JhcHBlcikge1xuICAgIGxldCB2O1xuICAgIGxldCB1O1xuICAgIGNvbnN0IGluSW1hZ2VEYXRhID0gaW5JbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBvdXRJbWFnZURhdGEgPSBvdXRJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBoZWlnaHQgPSBpbkltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgY29uc3Qgd2lkdGggPSBpbkltYWdlV3JhcHBlci5zaXplLng7XG4gICAgbGV0IHN1bTtcbiAgICBsZXQgeVN0YXJ0MTtcbiAgICBsZXQgeVN0YXJ0MjtcbiAgICBsZXQgeFN0YXJ0MTtcbiAgICBsZXQgeFN0YXJ0MjtcblxuICAgIGZvciAodiA9IDE7IHYgPCBoZWlnaHQgLSAxOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMTsgdSA8IHdpZHRoIC0gMTsgdSsrKSB7XG4gICAgICAgICAgICB5U3RhcnQxID0gdiAtIDE7XG4gICAgICAgICAgICB5U3RhcnQyID0gdiArIDE7XG4gICAgICAgICAgICB4U3RhcnQxID0gdSAtIDE7XG4gICAgICAgICAgICB4U3RhcnQyID0gdSArIDE7XG4gICAgICAgICAgICBzdW0gPSBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDJdXG4gICAgICAgICAgICArIGluSW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdXG4gICAgICAgICAgICArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0Ml07XG4gICAgICAgICAgICBvdXRJbWFnZURhdGFbdiAqIHdpZHRoICsgdV0gPSBzdW0gPiAwID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlcm9kZShpbkltYWdlV3JhcHBlciwgb3V0SW1hZ2VXcmFwcGVyKSB7XG4gICAgbGV0IHY7XG4gICAgbGV0IHU7XG4gICAgY29uc3QgaW5JbWFnZURhdGEgPSBpbkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IG91dEltYWdlRGF0YSA9IG91dEltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGhlaWdodCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCB3aWR0aCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgc3VtO1xuICAgIGxldCB5U3RhcnQxO1xuICAgIGxldCB5U3RhcnQyO1xuICAgIGxldCB4U3RhcnQxO1xuICAgIGxldCB4U3RhcnQyO1xuXG4gICAgZm9yICh2ID0gMTsgdiA8IGhlaWdodCAtIDE7IHYrKykge1xuICAgICAgICBmb3IgKHUgPSAxOyB1IDwgd2lkdGggLSAxOyB1KyspIHtcbiAgICAgICAgICAgIHlTdGFydDEgPSB2IC0gMTtcbiAgICAgICAgICAgIHlTdGFydDIgPSB2ICsgMTtcbiAgICAgICAgICAgIHhTdGFydDEgPSB1IC0gMTtcbiAgICAgICAgICAgIHhTdGFydDIgPSB1ICsgMTtcbiAgICAgICAgICAgIHN1bSA9IGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0Ml1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbdiAqIHdpZHRoICsgdV1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQyXTtcbiAgICAgICAgICAgIG91dEltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA9IHN1bSA9PT0gNSA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3QoYUltYWdlV3JhcHBlciwgYkltYWdlV3JhcHBlciwgcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gICAgaWYgKCFyZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHJlc3VsdEltYWdlV3JhcHBlciA9IGFJbWFnZVdyYXBwZXI7XG4gICAgfVxuICAgIGxldCB7IGxlbmd0aCB9ID0gYUltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGFJbWFnZURhdGEgPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgYkltYWdlRGF0YSA9IGJJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBjSW1hZ2VEYXRhID0gcmVzdWx0SW1hZ2VXcmFwcGVyLmRhdGE7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgY0ltYWdlRGF0YVtsZW5ndGhdID0gYUltYWdlRGF0YVtsZW5ndGhdIC0gYkltYWdlRGF0YVtsZW5ndGhdO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpdHdpc2VPcihhSW1hZ2VXcmFwcGVyLCBiSW1hZ2VXcmFwcGVyLCByZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICBpZiAoIXJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcmVzdWx0SW1hZ2VXcmFwcGVyID0gYUltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgYUltYWdlRGF0YSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBiSW1hZ2VEYXRhID0gYkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGNJbWFnZURhdGEgPSByZXN1bHRJbWFnZVdyYXBwZXIuZGF0YTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBjSW1hZ2VEYXRhW2xlbmd0aF0gPSBhSW1hZ2VEYXRhW2xlbmd0aF0gfHwgYkltYWdlRGF0YVtsZW5ndGhdO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50Tm9uWmVybyhpbWFnZVdyYXBwZXIpIHtcbiAgICBsZXQgeyBsZW5ndGggfSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gaW1hZ2VXcmFwcGVyO1xuICAgIGxldCBzdW0gPSAwO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHN1bSArPSBkYXRhW2xlbmd0aF07XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b3BHZW5lcmljKGxpc3QsIHRvcCwgc2NvcmVGdW5jKSB7XG4gICAgbGV0IGk7IGxldCBtaW5JZHggPSAwOyBsZXQgbWluID0gMDsgY29uc3QgcXVldWUgPSBbXTsgbGV0IHNjb3JlOyBsZXQgaGl0OyBsZXRcbiAgICAgICAgcG9zO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRvcDsgaSsrKSB7XG4gICAgICAgIHF1ZXVlW2ldID0ge1xuICAgICAgICAgICAgc2NvcmU6IDAsXG4gICAgICAgICAgICBpdGVtOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNjb3JlID0gc2NvcmVGdW5jLmFwcGx5KHRoaXMsIFtsaXN0W2ldXSk7XG4gICAgICAgIGlmIChzY29yZSA+IG1pbikge1xuICAgICAgICAgICAgaGl0ID0gcXVldWVbbWluSWR4XTtcbiAgICAgICAgICAgIGhpdC5zY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgaGl0Lml0ZW0gPSBsaXN0W2ldO1xuICAgICAgICAgICAgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgIGZvciAocG9zID0gMDsgcG9zIDwgdG9wOyBwb3MrKykge1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtwb3NdLnNjb3JlIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IHF1ZXVlW3Bvc10uc2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIG1pbklkeCA9IHBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcXVldWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5QXJyYXlGcm9tSW1hZ2UoaHRtbEltYWdlLCBvZmZzZXRYLCBjdHgsIGFycmF5KSB7XG4gICAgY3R4LmRyYXdJbWFnZShodG1sSW1hZ2UsIG9mZnNldFgsIDAsIGh0bWxJbWFnZS53aWR0aCwgaHRtbEltYWdlLmhlaWdodCk7XG4gICAgY29uc3QgY3R4RGF0YSA9IGN0eC5nZXRJbWFnZURhdGEob2Zmc2V0WCwgMCwgaHRtbEltYWdlLndpZHRoLCBodG1sSW1hZ2UuaGVpZ2h0KS5kYXRhO1xuICAgIGNvbXB1dGVHcmF5KGN0eERhdGEsIGFycmF5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBcnJheUZyb21Db250ZXh0KGN0eCwgc2l6ZSwgb2Zmc2V0LCBhcnJheSkge1xuICAgIGNvbnN0IGN0eERhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKG9mZnNldC54LCBvZmZzZXQueSwgc2l6ZS54LCBzaXplLnkpLmRhdGE7XG4gICAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgYXJyYXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JheUFuZEhhbGZTYW1wbGVGcm9tQ2FudmFzRGF0YShjYW52YXNEYXRhLCBzaXplLCBvdXRBcnJheSkge1xuICAgIGxldCB0b3BSb3dJZHggPSAwO1xuICAgIGxldCBib3R0b21Sb3dJZHggPSBzaXplLng7XG4gICAgY29uc3QgZW5kSWR4ID0gTWF0aC5mbG9vcihjYW52YXNEYXRhLmxlbmd0aCAvIDQpO1xuICAgIGNvbnN0IG91dFdpZHRoID0gc2l6ZS54IC8gMjtcbiAgICBsZXQgb3V0SW1nSWR4ID0gMDtcbiAgICBjb25zdCBpbldpZHRoID0gc2l6ZS54O1xuICAgIGxldCBpO1xuXG4gICAgd2hpbGUgKGJvdHRvbVJvd0lkeCA8IGVuZElkeCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3V0V2lkdGg7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBvdXRBcnJheVtvdXRJbWdJZHhdID0gKFxuICAgICAgICAgICAgICAgICgwLjI5OSAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhW3RvcFJvd0lkeCAqIDQgKyAxXVxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMl0pXG4gICAgICAgICAgICAgICAgKyAoMC4yOTkgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAwXVxuICAgICAgICAgICAgICAgICArIDAuNTg3ICogY2FudmFzRGF0YVsodG9wUm93SWR4ICsgMSkgKiA0ICsgMV1cbiAgICAgICAgICAgICAgICAgKyAwLjExNCAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDJdKVxuICAgICAgICAgICAgICAgICsgKDAuMjk5ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4KSAqIDQgKyAwXVxuICAgICAgICAgICAgICAgICArIDAuNTg3ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4KSAqIDQgKyAxXVxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4KSAqIDQgKyAyXSlcbiAgICAgICAgICAgICAgICArICgwLjI5OSAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHggKyAxKSAqIDQgKyAxXVxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMl0pKSAvIDQ7XG4gICAgICAgICAgICBvdXRJbWdJZHgrKztcbiAgICAgICAgICAgIHRvcFJvd0lkeCArPSAyO1xuICAgICAgICAgICAgYm90dG9tUm93SWR4ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdG9wUm93SWR4ICs9IGluV2lkdGg7XG4gICAgICAgIGJvdHRvbVJvd0lkeCArPSBpbldpZHRoO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVHcmF5KGltYWdlRGF0YSwgb3V0QXJyYXksIGNvbmZpZykge1xuICAgIGNvbnN0IGwgPSAoaW1hZ2VEYXRhLmxlbmd0aCAvIDQpIHwgMDtcbiAgICBjb25zdCBzaW5nbGVDaGFubmVsID0gY29uZmlnICYmIGNvbmZpZy5zaW5nbGVDaGFubmVsID09PSB0cnVlO1xuXG4gICAgaWYgKHNpbmdsZUNoYW5uZWwpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgb3V0QXJyYXlbaV0gPSBpbWFnZURhdGFbaSAqIDQgKyAwXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG91dEFycmF5W2ldID0gMC4yOTkgKiBpbWFnZURhdGFbaSAqIDQgKyAwXSArIDAuNTg3ICogaW1hZ2VEYXRhW2kgKiA0ICsgMV0gKyAwLjExNCAqIGltYWdlRGF0YVtpICogNCArIDJdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZEltYWdlQXJyYXkoc3JjLCBjYWxsYmFjaywgY2FudmFzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpIHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcywgMCwgMCk7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAwLCAwKTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgY29tcHV0ZUdyYXkoZGF0YSwgYXJyYXkpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKGFycmF5LCB7XG4gICAgICAgICAgICB4OiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgeTogdGhpcy5oZWlnaHQsXG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH07XG4gICAgaW1nLnNyYyA9IHNyYztcbn1cblxuLyoqXG4gKiBAcGFyYW0gaW5JbWcge0ltYWdlV3JhcHBlcn0gaW5wdXQgaW1hZ2UgdG8gYmUgc2FtcGxlZFxuICogQHBhcmFtIG91dEltZyB7SW1hZ2VXcmFwcGVyfSB0byBiZSBzdG9yZWQgaW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbGZTYW1wbGUoaW5JbWdXcmFwcGVyLCBvdXRJbWdXcmFwcGVyKSB7XG4gICAgY29uc3QgaW5JbWcgPSBpbkltZ1dyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBpbldpZHRoID0gaW5JbWdXcmFwcGVyLnNpemUueDtcbiAgICBjb25zdCBvdXRJbWcgPSBvdXRJbWdXcmFwcGVyLmRhdGE7XG4gICAgbGV0IHRvcFJvd0lkeCA9IDA7XG4gICAgbGV0IGJvdHRvbVJvd0lkeCA9IGluV2lkdGg7XG4gICAgY29uc3QgZW5kSWR4ID0gaW5JbWcubGVuZ3RoO1xuICAgIGNvbnN0IG91dFdpZHRoID0gaW5XaWR0aCAvIDI7XG4gICAgbGV0IG91dEltZ0lkeCA9IDA7XG4gICAgd2hpbGUgKGJvdHRvbVJvd0lkeCA8IGVuZElkeCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dFdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIG91dEltZ1tvdXRJbWdJZHhdID0gTWF0aC5mbG9vcihcbiAgICAgICAgICAgICAgICAoaW5JbWdbdG9wUm93SWR4XSArIGluSW1nW3RvcFJvd0lkeCArIDFdICsgaW5JbWdbYm90dG9tUm93SWR4XSArIGluSW1nW2JvdHRvbVJvd0lkeCArIDFdKSAvIDQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb3V0SW1nSWR4Kys7XG4gICAgICAgICAgICB0b3BSb3dJZHggKz0gMjtcbiAgICAgICAgICAgIGJvdHRvbVJvd0lkeCArPSAyO1xuICAgICAgICB9XG4gICAgICAgIHRvcFJvd0lkeCArPSBpbldpZHRoO1xuICAgICAgICBib3R0b21Sb3dJZHggKz0gaW5XaWR0aDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoc3YycmdiKGhzdiwgcmdiID0gWzAsIDAsIDBdKSB7XG4gICAgY29uc3QgaCA9IGhzdlswXTtcbiAgICBjb25zdCBzID0gaHN2WzFdO1xuICAgIGNvbnN0IHYgPSBoc3ZbMl07XG4gICAgY29uc3QgYyA9IHYgKiBzO1xuICAgIGNvbnN0IHggPSBjICogKDEgLSBNYXRoLmFicygoaCAvIDYwKSAlIDIgLSAxKSk7XG4gICAgY29uc3QgbSA9IHYgLSBjO1xuICAgIGxldCByID0gMDtcbiAgICBsZXQgZyA9IDA7XG4gICAgbGV0IGIgPSAwO1xuXG4gICAgaWYgKGggPCA2MCkge1xuICAgICAgICByID0gYztcbiAgICAgICAgZyA9IHg7XG4gICAgfSBlbHNlIGlmIChoIDwgMTIwKSB7XG4gICAgICAgIHIgPSB4O1xuICAgICAgICBnID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAxODApIHtcbiAgICAgICAgZyA9IGM7XG4gICAgICAgIGIgPSB4O1xuICAgIH0gZWxzZSBpZiAoaCA8IDI0MCkge1xuICAgICAgICBnID0geDtcbiAgICAgICAgYiA9IGM7XG4gICAgfSBlbHNlIGlmIChoIDwgMzAwKSB7XG4gICAgICAgIHIgPSB4O1xuICAgICAgICBiID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAzNjApIHtcbiAgICAgICAgciA9IGM7XG4gICAgICAgIGIgPSB4O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICByZ2JbMF0gPSAoKHIgKyBtKSAqIDI1NSkgfCAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHJnYlsxXSA9ICgoZyArIG0pICogMjU1KSB8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcmdiWzJdID0gKChiICsgbSkgKiAyNTUpIHwgMDtcbiAgICByZXR1cm4gcmdiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2NvbXB1dGVEaXZpc29ycyhuKSB7XG4gICAgY29uc3QgbGFyZ2VEaXZpc29ycyA9IFtdO1xuICAgIGNvbnN0IGRpdmlzb3JzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IE1hdGguc3FydChuKSArIDE7IGkrKykge1xuICAgICAgICBpZiAobiAlIGkgPT09IDApIHtcbiAgICAgICAgICAgIGRpdmlzb3JzLnB1c2goaSk7XG4gICAgICAgICAgICBpZiAoaSAhPT0gbiAvIGkpIHtcbiAgICAgICAgICAgICAgICBsYXJnZURpdmlzb3JzLnVuc2hpZnQoTWF0aC5mbG9vcihuIC8gaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaXZpc29ycy5jb25jYXQobGFyZ2VEaXZpc29ycyk7XG59XG5cbmZ1bmN0aW9uIF9jb21wdXRlSW50ZXJzZWN0aW9uKGFycjEsIGFycjIpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKGkgPCBhcnIxLmxlbmd0aCAmJiBqIDwgYXJyMi5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGFycjFbaV0gPT09IGFycjJbal0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycjFbaV0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9IGVsc2UgaWYgKGFycjFbaV0gPiBhcnIyW2pdKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZVBhdGNoU2l6ZShwYXRjaFNpemUsIGltZ1NpemUpIHtcbiAgICBjb25zdCBkaXZpc29yc1ggPSBfY29tcHV0ZURpdmlzb3JzKGltZ1NpemUueCk7XG4gICAgY29uc3QgZGl2aXNvcnNZID0gX2NvbXB1dGVEaXZpc29ycyhpbWdTaXplLnkpO1xuICAgIGNvbnN0IHdpZGVTaWRlID0gTWF0aC5tYXgoaW1nU2l6ZS54LCBpbWdTaXplLnkpO1xuICAgIGNvbnN0IGNvbW1vbiA9IF9jb21wdXRlSW50ZXJzZWN0aW9uKGRpdmlzb3JzWCwgZGl2aXNvcnNZKTtcbiAgICBjb25zdCBuck9mUGF0Y2hlc0xpc3QgPSBbOCwgMTAsIDE1LCAyMCwgMzIsIDYwLCA4MF07XG4gICAgY29uc3QgbnJPZlBhdGNoZXNNYXAgPSB7XG4gICAgICAgICd4LXNtYWxsJzogNSxcbiAgICAgICAgc21hbGw6IDQsXG4gICAgICAgIG1lZGl1bTogMyxcbiAgICAgICAgbGFyZ2U6IDIsXG4gICAgICAgICd4LWxhcmdlJzogMSxcbiAgICB9O1xuICAgIGNvbnN0IG5yT2ZQYXRjaGVzSWR4ID0gbnJPZlBhdGNoZXNNYXBbcGF0Y2hTaXplXSB8fCBuck9mUGF0Y2hlc01hcC5tZWRpdW07XG4gICAgY29uc3QgbnJPZlBhdGNoZXMgPSBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdO1xuICAgIGNvbnN0IGRlc2lyZWRQYXRjaFNpemUgPSBNYXRoLmZsb29yKHdpZGVTaWRlIC8gbnJPZlBhdGNoZXMpO1xuICAgIGxldCBvcHRpbWFsUGF0Y2hTaXplO1xuXG4gICAgZnVuY3Rpb24gZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzKGRpdmlzb3JzKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGZvdW5kID0gZGl2aXNvcnNbTWF0aC5mbG9vcihkaXZpc29ycy5sZW5ndGggLyAyKV07XG5cbiAgICAgICAgd2hpbGUgKGkgPCAoZGl2aXNvcnMubGVuZ3RoIC0gMSkgJiYgZGl2aXNvcnNbaV0gPCBkZXNpcmVkUGF0Y2hTaXplKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGl2aXNvcnNbaV0gLSBkZXNpcmVkUGF0Y2hTaXplKSA+IE1hdGguYWJzKGRpdmlzb3JzW2kgLSAxXSAtIGRlc2lyZWRQYXRjaFNpemUpKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBkaXZpc29yc1tpIC0gMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gZGl2aXNvcnNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2lyZWRQYXRjaFNpemUgLyBmb3VuZCA8IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeCArIDFdIC8gbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4XVxuICAgICAgICAgICAgJiYgZGVzaXJlZFBhdGNoU2l6ZSAvIGZvdW5kID4gbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4IC0gMV0gLyBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdKSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmb3VuZCwgeTogZm91bmQgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBvcHRpbWFsUGF0Y2hTaXplID0gZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzKGNvbW1vbik7XG4gICAgaWYgKCFvcHRpbWFsUGF0Y2hTaXplKSB7XG4gICAgICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoX2NvbXB1dGVEaXZpc29ycyh3aWRlU2lkZSkpO1xuICAgICAgICBpZiAoIW9wdGltYWxQYXRjaFNpemUpIHtcbiAgICAgICAgICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoKF9jb21wdXRlRGl2aXNvcnMoZGVzaXJlZFBhdGNoU2l6ZSAqIG5yT2ZQYXRjaGVzKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpbWFsUGF0Y2hTaXplO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzKHZhbHVlKSB7XG4gICAgY29uc3QgZGltZW5zaW9uID0ge1xuICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdCh2YWx1ZSksXG4gICAgICAgIHVuaXQ6IHZhbHVlLmluZGV4T2YoJyUnKSA9PT0gdmFsdWUubGVuZ3RoIC0gMSA/ICclJyA6ICclJyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRpbWVuc2lvbjtcbn1cblxuZXhwb3J0IGNvbnN0IF9kaW1lbnNpb25zQ29udmVydGVycyA9IHtcbiAgICB0b3AoZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LmhlaWdodCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSA6IG51bGw7XG4gICAgfSxcbiAgICByaWdodChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQud2lkdGggLSAoY29udGV4dC53aWR0aCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSkgOiBudWxsO1xuICAgIH0sXG4gICAgYm90dG9tKGRpbWVuc2lvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uLnVuaXQgPT09ICclJyA/IE1hdGguZmxvb3IoY29udGV4dC5oZWlnaHQgLSAoY29udGV4dC5oZWlnaHQgKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkpIDogbnVsbDtcbiAgICB9LFxuICAgIGxlZnQoZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LndpZHRoICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpIDogbnVsbDtcbiAgICB9LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVJbWFnZUFyZWEoaW5wdXRXaWR0aCwgaW5wdXRIZWlnaHQsIGFyZWEpIHtcbiAgICBjb25zdCBjb250ZXh0ID0geyB3aWR0aDogaW5wdXRXaWR0aCwgaGVpZ2h0OiBpbnB1dEhlaWdodCB9O1xuXG4gICAgY29uc3QgcGFyc2VkQXJlYSA9IE9iamVjdC5rZXlzKGFyZWEpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhcmVhW2tleV07XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IF9wYXJzZUNTU0RpbWVuc2lvblZhbHVlcyh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWQgPSBfZGltZW5zaW9uc0NvbnZlcnRlcnNba2V5XShwYXJzZWQsIGNvbnRleHQpO1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICByZXN1bHRba2V5XSA9IGNhbGN1bGF0ZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwge30pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3g6IHBhcnNlZEFyZWEubGVmdCxcbiAgICAgICAgc3k6IHBhcnNlZEFyZWEudG9wLFxuICAgICAgICBzdzogcGFyc2VkQXJlYS5yaWdodCAtIHBhcnNlZEFyZWEubGVmdCxcbiAgICAgICAgc2g6IHBhcnNlZEFyZWEuYm90dG9tIC0gcGFyc2VkQXJlYS50b3AsXG4gICAgfTtcbn1cbiIsImltcG9ydCB7IFhZU2l6ZSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG4vLyBUT0RPOiBYWVBvc2l0aW9uIHNob3VsZCBiZSBhbiBYWU9iamVjdCwgYnV0IHRoYXQgYnJlYWtzIFhZRGVmaW5pdGlvbiwgd2hpY2ggYnJlYWtzIGRyYXdQYXRoKCkgYmVsb3cuXG5kZWNsYXJlIGludGVyZmFjZSBYWVBvc2l0aW9uIHtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xufVxuXG5kZWNsYXJlIGludGVyZmFjZSBDYW52YXNTdHlsZSB7XG4gICAgY29sb3I6IHN0cmluZztcbiAgICBsaW5lV2lkdGg6IG51bWJlcjtcbn1cblxuLy8gWFlEZWZpbml0aW9uIHRlbGxzIHVzIHdoaWNoIGNvbXBvbmVudCBvZiBhIGdpdmVuIGFycmF5IG9yIG9iamVjdCBpcyB0aGUgXCJYXCIgYW5kIHdoaWNoIGlzIHRoZSBcIllcIi5cbi8vIFVzdWFsbHkgdGhpcyBpcyAwIGZvciBYIGFuZCAxIGZvciBZLCBidXQgbWlnaHQgYmUgdXNlZCBhcyAneCcgZm9yIHggYW5kICd5JyBmb3IgWS5cbmRlY2xhcmUgaW50ZXJmYWNlIFhZRGVmaW5pdGlvbiB7XG4gICAgeDoga2V5b2YgWFlQb3NpdGlvbjtcbiAgICB5OiBrZXlvZiBYWVBvc2l0aW9uO1xufVxuXG5kZWNsYXJlIHR5cGUgUGF0aCA9IEFycmF5PFhZUG9zaXRpb24+O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZHJhd1JlY3QocG9zOiBYWVBvc2l0aW9uLCBzaXplOiBYWVNpemUsIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBzdHlsZTogQ2FudmFzU3R5bGUpOiB2b2lkIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aCB8fCAxO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VSZWN0KHBvcy54LCBwb3MueSwgc2l6ZS54LCBzaXplLnkpO1xuICAgIH0sXG4gICAgZHJhd1BhdGgocGF0aDogUGF0aCwgZGVmOiBYWURlZmluaXRpb24sIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBzdHlsZTogQ2FudmFzU3R5bGUpOiB2b2lkIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHBhdGhbMF1bZGVmLnhdLCBwYXRoWzBdW2RlZi55XSk7XG4gICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgcGF0aC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhwYXRoW2pdW2RlZi54XSwgcGF0aFtqXVtkZWYueV0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgZHJhd0ltYWdlKGltYWdlRGF0YTogQXJyYXk8bnVtYmVyPiwgc2l6ZTogWFlTaXplLCBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBjYW52YXNEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBzaXplLngsIHNpemUueSk7XG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gY2FudmFzRGF0YTtcbiAgICAgICAgbGV0IGNhbnZhc0RhdGFQb3MgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgbGV0IGltYWdlRGF0YVBvcyA9IGltYWdlRGF0YS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGNhbnZhc0RhdGFQb3MgLyBpbWFnZURhdGFQb3MgIT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW1hZ2VEYXRhUG9zLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaW1hZ2VEYXRhW2ltYWdlRGF0YVBvc107XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSAyNTU7XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShjYW52YXNEYXRhLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuaW1wb3J0IHsgVHlwZWRBcnJheSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGluaXQoYXJyOiBUeXBlZEFycmF5IHwgQXJyYXk8bnVtYmVyPiwgdmFsOiBudW1iZXIpIHtcbiAgICAgICAgYXJyLmZpbGwodmFsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2h1ZmZsZXMgdGhlIGNvbnRlbnQgb2YgYW4gYXJyYXlcbiAgICAgKi9cbiAgICBzaHVmZmxlKGFycjogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICAvLyBEdXJzdGVuZmVsZCBzaHVmZmxlIGFsZ29yaXRobVxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNDUwOTU0L2hvdy10by1yYW5kb21pemUtc2h1ZmZsZS1hLWphdmFzY3JpcHQtYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IGFyci5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGkgKyAxKSk7XG4gICAgICAgICAgICBbYXJyW2ldLCBhcnJbal1dID0gW2FycltqXSwgYXJyW2ldXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB0b1BvaW50TGlzdChhcnI6IEFycmF5PEFycmF5PG51bWJlcj4+KSB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBhcnIucmVkdWNlKChwLCBuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBgWyR7bi5qb2luKCcsJyl9XWA7XG4gICAgICAgICAgICBwLnB1c2gocm93KTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LCBbXSBhcyBBcnJheTxzdHJpbmc+KTtcbiAgICAgICAgcmV0dXJuIGBbJHtyb3dzLmpvaW4oJyxcXHJcXG4nKX1dYDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgZWxlbWVudHMgd2hpY2gncyBzY29yZSBpcyBiaWdnZXIgdGhhbiB0aGUgdGhyZXNob2xkXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdGhyZXNob2xkKGFycjogQXJyYXk8bnVtYmVyPiwgdGhyZXNob2xkOiBudW1iZXIsIHNjb3JlRnVuYzogKChzY29yZTogbnVtYmVyKSA9PiBudW1iZXIpKSB7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gYXJyLnJlZHVjZSgocHJldjogQXJyYXk8bnVtYmVyPiwgbmV4dCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNjb3JlRnVuYy5hcHBseShhcnIsIFtuZXh0XSkgPj0gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgcHJldi5wdXNoKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuIHF1ZXVlO1xuICAgIH0sXG5cbiAgICBtYXhJbmRleChhcnI6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2ldID4gYXJyW21heF0pIHtcbiAgICAgICAgICAgICAgICBtYXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfSxcblxuICAgIG1heChhcnI6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2ldID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gYXJyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfSxcblxuICAgIHN1bShhcnI6IEFycmF5PG51bWJlcj4gfCBUeXBlZEFycmF5KTogbnVtYmVyIHtcbiAgICAgICAgbGV0IHsgbGVuZ3RoIH0gPSBhcnI7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgc3VtICs9IGFycltsZW5ndGhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfSxcbn07XG4iLCJpbXBvcnQgeyBjbG9uZSB9IGZyb20gJ2dsLXZlYzInO1xuaW1wb3J0IHtcbiAgICBYWVNpemUsXG4gICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yLFxuICAgIFR5cGVkQXJyYXksXG4gICAgV3JhcHBlckluZGV4TWFwcGluZyxcbiAgICBNb21lbnQsXG4gICAgU3BhcnNlSW1hZ2VXcmFwcGVyLFxufSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuL2FycmF5X2hlbHBlcic7XG5pbXBvcnQgeyBoc3YycmdiIH0gZnJvbSAnLi9jdl91dGlscyc7XG5cbmNvbnN0IHZlYzIgPSB7IGNsb25lIH07XG5cbnR5cGUgUG9zaXRpdmVOdW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBhc3NlcnROdW1iZXJQb3NpdGl2ZSh2YWw6IG51bWJlcik6IGFzc2VydHMgdmFsIGlzIFBvc2l0aXZlTnVtYmVyIHtcbiAgICBpZiAodmFsIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIHBvc2l0aXZlIG51bWJlciwgcmVjZWl2ZWQgJHt2YWx9YCk7XG4gICAgfVxufVxuXG5jbGFzcyBJbWFnZVdyYXBwZXIgaW1wbGVtZW50cyBTcGFyc2VJbWFnZVdyYXBwZXIge1xuICAgIGRhdGE6IFR5cGVkQXJyYXkgfCBBcnJheTxudW1iZXI+O1xuXG4gICAgc2l6ZTogWFlTaXplO1xuXG4gICAgaW5kZXhNYXBwaW5nPzogV3JhcHBlckluZGV4TWFwcGluZztcblxuICAgIC8vIFJlcHJlc2VudHMgYSBiYXNpYyBpbWFnZSBjb21iaW5pbmcgdGhlIGRhdGEgYW5kIHNpemUuIEluIGFkZGl0aW9uLCBzb21lIG1ldGhvZHMgZm9yXG4gICAgLy8gbWFuaXB1bGF0aW9uIGFyZSBjb250YWluZWQgd2l0aGluLlxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBzaXplOiBYWVNpemUsXG4gICAgICAgIGRhdGE/OiBUeXBlZEFycmF5IHwgQXJyYXk8bnVtYmVyPixcbiAgICAgICAgQXJyYXlUeXBlOiBUeXBlZEFycmF5Q29uc3RydWN0b3IgfCBBcnJheUNvbnN0cnVjdG9yID0gVWludDhBcnJheSxcbiAgICAgICAgaW5pdGlhbGl6ZT86IGJvb2xlYW4sXG4gICAgKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IChBcnJheVR5cGUpKHNpemUueCAqIHNpemUueSk7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbGl6ZSkge1xuICAgICAgICAgICAgICAgIEFycmF5SGVscGVyLmluaXQodGhpcy5kYXRhLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB9XG5cbiAgICAvLyB0ZXN0cyBpZiBhIHBvc2l0aW9uIGlzIHdpdGhpbiB0aGUgaW1hZ2UsIGV4dGVuZGVkIG91dCBieSBhIGJvcmRlciBvbiBlYWNoIHNpZGVcbiAgICBpbkltYWdlV2l0aEJvcmRlcihpbWdSZWY6IFhZU2l6ZSwgYm9yZGVyOiBQb3NpdGl2ZU51bWJlciA9IDApOiBib29sZWFuIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyUG9zaXRpdmUoYm9yZGVyKTtcbiAgICAgICAgLy8gVE9ETzogY29kZV8xMjggc3RhcnRzIGZhaWxpbmcgbWlzZXJhYmx5IHdoZW4gaSBvbmx5IGFsbG93IGltZ1JlZiB0byBjb250YWluIHBvc2l0aXZlIG51bWJlcnMuXG4gICAgICAgIC8vIFRPRE86IHRoaXMgZG9lc24ndCBtYWtlIG11Y2ggc2Vuc2UgdG8gbWUsIHdoeSBkb2VzIGl0IGdvIG5lZ2F0aXZlPyAgVGVzdHMgYXJlIG5vdCBhZmZlY3RlZCBieVxuICAgICAgICAvLyByZXR1cm5pbmcgZmFsc2UsIGJ1dCB0aGUgd2hvbGUgY29kZV8xMjggcmVhZGVyIGJsb3dzIHVwIHdoZW4gaSB0aHJvdyBvbiBuZWdhdGl2ZSBpbWdSZWYuXG4gICAgICAgIC8vIGFzc2VydE51bWJlclBvc2l0aXZlKGltZ1JlZi54KTtcbiAgICAgICAgLy8gYXNzZXJ0TnVtYmVyUG9zaXRpdmUoaW1nUmVmLnkpO1xuICAgICAgICByZXR1cm4gKGltZ1JlZi54ID49IDApXG4gICAgICAgICAgICAmJiAoaW1nUmVmLnkgPj0gMClcbiAgICAgICAgICAgICYmIChpbWdSZWYueCA8ICh0aGlzLnNpemUueCArIChib3JkZXIgKiAyKSkpXG4gICAgICAgICAgICAmJiAoaW1nUmVmLnkgPCAodGhpcy5zaXplLnkgKyAoYm9yZGVyICogMikpKTtcbiAgICB9XG5cbiAgICAvLyBDb3B5IGZyb20gVEhJUyBJbWFnZVdyYXBwZXIgdG8gdGhlIG5ldyBpbWFnZVdyYXBwZXIgcGFyYW1ldGVyLCBzdGFydGluZyBhdCBmcm9tLCBzdG9wcGluZyBhdFxuICAgIC8vIGVuZCBvZiBuZXcgaW1hZ2VXcmFwcGVyIHNpemUuXG4gICAgc3ViSW1hZ2VBc0NvcHkoaW1hZ2VXcmFwcGVyOiBJbWFnZVdyYXBwZXIsIGZyb206IFhZU2l6ZSk6IEltYWdlV3JhcHBlciB7XG4gICAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGZyb20ueCk7XG4gICAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGZyb20ueSk7XG4gICAgICAgIGNvbnN0IHsgeDogc2l6ZVgsIHk6IHNpemVZIH0gPSBpbWFnZVdyYXBwZXIuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBzaXplWDsgeCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHNpemVZOyB5KyspIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBpbWFnZVdyYXBwZXIuZGF0YVt5ICogc2l6ZVggKyB4XSA9IHRoaXMuZGF0YVsoZnJvbS55ICsgeSkgKiB0aGlzLnNpemUueCArIGZyb20ueCArIHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbWFnZVdyYXBwZXI7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgZnVuY3Rpb24gcmVhbGx5IHByb2JhYmx5IHNob3VsZCBjYWxsIGludG8gSW1hZ2VXcmFwcGVyIHNvbWV3aGVyZSB0byBtYWtlXG4gICAgICAgIC8vIHN1cmUgdGhhdCBhbGwgb2YgaXQncyBwYXJhbWV0ZXJzIGFyZSBzZXQgcHJvcGVybHksIHNvbWV0aGluZyBsaWtlXG4gICAgICAgIC8vIEltYWdlV3JhcHBlci5VcGRhdGVGcm9tKClcbiAgICAgICAgLy8gdGhhdCBtaWdodCB0YWtlIGEgcHJvdmlkZWQgZGF0YSBhbmQgc2l6ZSwgYW5kIG1ha2Ugc3VyZSB0aGVyZSdzIG5vIGludmFsaWQgaW5kZXhNYXBwaW5nXG4gICAgICAgIC8vIGhhbmdpbmcgYXJvdW5kLCBhbmQgc3VjaC5cbiAgICB9XG5cbiAgICAvLyBSZXRyaWV2ZSBhIGdyYXlzY2FsZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gb2YgdGhlIGltYWdlXG4gICAgZ2V0KHg6IG51bWJlciwgeTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt5ICogdGhpcy5zaXplLnggKyB4XTtcbiAgICB9XG5cbiAgICAvLyBSZXRyaWV2ZSBhIGdyYXlzY2FsZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gb2YgdGhlIGltYWdlIChzYWZlLCB3aGF0ZXZlciB0aGF0XG4gICAgLy8gbWVhbnMpXG4gICAgZ2V0U2FmZSh4OiBudW1iZXIsIHk6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIC8vIGNhY2hlIGluZGV4TWFwcGluZyBiZWNhdXNlIGlmIHdlJ3JlIHVzaW5nIGl0IG9uY2UsIHdlJ2xsIHByb2JhYmx5IG5lZWQgaXQgYSBidW5jaCBtb3JlXG4gICAgICAgIC8vIHRvb1xuICAgICAgICBpZiAoIXRoaXMuaW5kZXhNYXBwaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZyA9IHtcbiAgICAgICAgICAgICAgICB4OiBbXSxcbiAgICAgICAgICAgICAgICB5OiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZS54OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy54W2ldID0gaTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy54W2kgKyB0aGlzLnNpemUueF0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemUueTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueVtpXSA9IGk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueVtpICsgdGhpcy5zaXplLnldID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhWyh0aGlzLmluZGV4TWFwcGluZy55W3kgKyB0aGlzLnNpemUueV0pICogdGhpcy5zaXplLnggKyB0aGlzLmluZGV4TWFwcGluZy54W3ggKyB0aGlzLnNpemUueF1dO1xuICAgIH1cblxuICAgIC8vIFNldHMgYSBnaXZlbiBwaXhlbCBwb3NpdGlvbiBpbiB0aGUgaW1hZ2UgdG8gdGhlIGdpdmVuIGdyYXlzY2FsZSB2YWx1ZVxuICAgIHNldCh4OiBudW1iZXIsIHk6IG51bWJlciwgdmFsdWU6IG51bWJlcik6IEltYWdlV3JhcHBlciB7XG4gICAgICAgIHRoaXMuZGF0YVt5ICogdGhpcy5zaXplLnggKyB4XSA9IHZhbHVlO1xuICAgICAgICBkZWxldGUgdGhpcy5pbmRleE1hcHBpbmc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFNldHMgdGhlIGJvcmRlciBvZiB0aGUgaW1hZ2UgKDEgcGl4ZWwpIHRvIHplcm9cbiAgICB6ZXJvQm9yZGVyKCk6IEltYWdlV3JhcHBlciB7XG4gICAgICAgIGNvbnN0IHsgeDogd2lkdGgsIHk6IGhlaWdodCB9ID0gdGhpcy5zaXplO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cbiAgICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IHRoaXMuZGF0YVsoaGVpZ2h0IC0gMSkgKiB3aWR0aCArIGldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhlaWdodCAtIDE7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuICAgICAgICAgICAgdGhpcy5kYXRhW2kgKiB3aWR0aF0gPSB0aGlzLmRhdGFbaSAqIHdpZHRoICsgKHdpZHRoIC0gMSldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5pbmRleE1hcHBpbmc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHRoaXMgZnVuY3Rpb24gaXMgZW50aXJlbHkgdG9vIGxhcmdlIGZvciBtZSB0byByZWFzb24gb3V0IHJpZ2h0IGF0IHRoaXMgbW9tZW50IHRoYXQgaSdtIGhhbmRsaW5nXG4gICAgLy8gYWxsIHRoZSByZXN0IG9mIGl0LCBzbyB0aGlzIGlzIGEgdmVyYmF0aW0gY29weSBvZiB0aGUgamF2YXNjcmlwdCBzb3VyY2UsIHdpdGggb25seSB0d2Vha3NcbiAgICAvLyBuZWNlc3NhcnkgdG8gZ2V0IGl0IHRvIHJ1biwgbm8gdGhvdWdodCBwdXQgaW50byBpdCB5ZXQuXG4gICAgbW9tZW50cyhsYWJlbENvdW50OiBudW1iZXIpOiBBcnJheTxNb21lbnQ+IHtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeDtcbiAgICAgICAgbGV0IHk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuc2l6ZS55O1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuc2l6ZS54O1xuICAgICAgICBsZXQgdmFsO1xuICAgICAgICBsZXQgeXNxO1xuICAgICAgICBjb25zdCBsYWJlbFN1bTogQXJyYXk8TW9tZW50PiA9IFtdO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgbGV0IGxhYmVsO1xuICAgICAgICBsZXQgbXUxMTtcbiAgICAgICAgbGV0IG11MDI7XG4gICAgICAgIGxldCBtdTIwO1xuICAgICAgICBsZXQgeF87XG4gICAgICAgIGxldCB5XztcbiAgICAgICAgbGV0IHRtcDtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxNb21lbnQ+ID0gW107XG4gICAgICAgIGNvbnN0IHsgUEkgfSA9IE1hdGg7XG4gICAgICAgIGNvbnN0IFBJXzQgPSBQSSAvIDQ7XG5cbiAgICAgICAgaWYgKGxhYmVsQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsYWJlbENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxhYmVsU3VtW2ldID0ge1xuICAgICAgICAgICAgICAgIG0wMDogMCxcbiAgICAgICAgICAgICAgICBtMDE6IDAsXG4gICAgICAgICAgICAgICAgbTEwOiAwLFxuICAgICAgICAgICAgICAgIG0xMTogMCxcbiAgICAgICAgICAgICAgICBtMDI6IDAsXG4gICAgICAgICAgICAgICAgbTIwOiAwLFxuICAgICAgICAgICAgICAgIHRoZXRhOiAwLFxuICAgICAgICAgICAgICAgIHJhZDogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIHlzcSA9IHkgKiB5O1xuICAgICAgICAgICAgZm9yICh4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBkYXRhW3kgKiB3aWR0aCArIHhdO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWxTdW1bdmFsIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0wMCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMDEgKz0geTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTEwICs9IHg7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0xMSArPSB4ICogeTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTAyICs9IHlzcTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTIwICs9IHggKiB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsYWJlbENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxhYmVsID0gbGFiZWxTdW1baV07XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgICAgICAgICBpZiAoIWlzTmFOKGxhYmVsLm0wMCkgJiYgbGFiZWwubTAwICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgeF8gPSBsYWJlbC5tMTAgLyBsYWJlbC5tMDA7XG4gICAgICAgICAgICAgICAgeV8gPSBsYWJlbC5tMDEgLyBsYWJlbC5tMDA7XG4gICAgICAgICAgICAgICAgbXUxMSA9IGxhYmVsLm0xMSAvIGxhYmVsLm0wMCAtIHhfICogeV87XG4gICAgICAgICAgICAgICAgbXUwMiA9IGxhYmVsLm0wMiAvIGxhYmVsLm0wMCAtIHlfICogeV87XG4gICAgICAgICAgICAgICAgbXUyMCA9IGxhYmVsLm0yMCAvIGxhYmVsLm0wMCAtIHhfICogeF87XG4gICAgICAgICAgICAgICAgdG1wID0gKG11MDIgLSBtdTIwKSAvICgyICogbXUxMSk7XG4gICAgICAgICAgICAgICAgdG1wID0gMC41ICogTWF0aC5hdGFuKHRtcCkgKyAobXUxMSA+PSAwID8gUElfNCA6IC1QSV80KSArIFBJO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXhlZC1vcGVyYXRvcnNcbiAgICAgICAgICAgICAgICBsYWJlbC50aGV0YSA9ICh0bXAgKiAxODAgLyBQSSArIDkwKSAlIDE4MCAtIDkwO1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbC50aGV0YSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwudGhldGEgKz0gMTgwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYWJlbC5yYWQgPSB0bXAgPiBQSSA/IHRtcCAtIFBJIDogdG1wO1xuICAgICAgICAgICAgICAgIGxhYmVsLnZlYyA9IHZlYzIuY2xvbmUoW01hdGguY29zKHRtcCksIE1hdGguc2luKHRtcCldKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gYSBVaW50OENsYW1wZWRBcnJheSBjb250YWluaW5nIHRoaXMgZ3JheXNjYWxlIGltYWdlIGNvbnZlcnRlZCB0byBSR0JBIGZvcm1cbiAgICBnZXRBc1JHQkEoc2NhbGUgPSAxLjApOiBVaW50OENsYW1wZWRBcnJheSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBVaW50OENsYW1wZWRBcnJheSg0ICogdGhpcy5zaXplLnggKiB0aGlzLnNpemUueSk7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5zaXplLnk7IHkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnNpemUueDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGl4ZWwgPSB5ICogdGhpcy5zaXplLnggKyB4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmdldCh4LCB5KSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAwXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDFdID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgMl0gPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAzXSA9IDI1NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8vIERpc3BsYXkgdGhpcyBJbWFnZVdyYXBwZXIgaW4gYSBnaXZlbiBDYW52YXMgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIHNjYWxlXG4gICAgc2hvdyhjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBzY2FsZSA9IDEuMCk6IHZvaWQge1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCBjYW52YXMgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYW1lID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5nZXRBc1JHQkEoc2NhbGUpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5zaXplLng7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5zaXplLnk7XG4gICAgICAgIGNvbnN0IG5ld0ZyYW1lID0gbmV3IEltYWdlRGF0YShkYXRhLCBmcmFtZS53aWR0aCwgZnJhbWUuaGVpZ2h0KTtcbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShuZXdGcmFtZSwgMCwgMCk7XG4gICAgfVxuXG4gICAgLy8gRGlzcGxheXMgYSBzcGVjaWZpZWQgU3ViSW1hZ2UgYXJlYSBpbiBhIGdpdmVuIGNhbnZhcy4gVGhpcyBkaWZmZXJzIGRyYXN0aWNhbGx5IGZyb21cbiAgICAvLyBjcmVhdGluZyBhIG5ldyBTdWJJbWFnZSBhbmQgdXNpbmcgaXQncyBzaG93KCkgbWV0aG9kLiBXaHk/IEkgZG9uJ3QgaGF2ZSB0aGUgYW5zd2VyIHRvIHRoYXRcbiAgICAvLyB5ZXQuICBJIHN1c3BlY3QgdGhlIEhTVi9SR0Igb3BlcmF0aW9ucyBpbnZvbHZlZCBoZXJlIGFyZSBtYWtpbmcgaXQgc2lnbmlmaWNhbnRseSBkaWZmZXJlbnQsXG4gICAgLy8gYnV0IHVudGlsIEkgY2FuIHZpc3VhbGl6ZSB0aGVzZSBmdW5jdGlvbnMgc2lkZSBieSBzaWRlLCBJJ20ganVzdCBnb2luZyB0byBjb3B5IHRoZSBleGlzdGluZ1xuICAgIC8vIGltcGxlbWVudGF0aW9uLlxuICAgIG92ZXJsYXkoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgaW5TY2FsZTogbnVtYmVyLCBmcm9tOiBYWVNpemUpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRTY2FsZSA9IChpblNjYWxlIDwgMCB8fCBpblNjYWxlID4gMzYwKSA/IDM2MCA6IGluU2NhbGU7XG4gICAgICAgIGNvbnN0IGhzdiA9IFswLCAxLCAxXTtcbiAgICAgICAgY29uc3QgcmdiID0gWzAsIDAsIDBdO1xuICAgICAgICBjb25zdCB3aGl0ZVJnYiA9IFsyNTUsIDI1NSwgMjU1XTtcbiAgICAgICAgY29uc3QgYmxhY2tSZ2IgPSBbMCwgMCwgMF07XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgY2FudmFzIGNvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFtZSA9IGN0eC5nZXRJbWFnZURhdGEoZnJvbS54LCBmcm9tLnksIHRoaXMuc2l6ZS54LCB0aGlzLnNpemUueSk7XG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gZnJhbWU7XG4gICAgICAgIGxldCB7IGxlbmd0aCB9ID0gdGhpcy5kYXRhO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIGhzdlswXSA9IHRoaXMuZGF0YVtsZW5ndGhdICogYWRqdXN0ZWRTY2FsZTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgcmVzdWx0ID0gaHN2WzBdIDw9IDAgPyB3aGl0ZVJnYiA6IGhzdlswXSA+PSAzNjAgPyBibGFja1JnYiA6IGhzdjJyZ2IoaHN2LCByZ2IpO1xuICAgICAgICAgICAgY29uc3QgcG9zID0gbGVuZ3RoICogNDtcbiAgICAgICAgICAgIFtkYXRhW3Bvc10sIGRhdGFbcG9zICsgMV0sIGRhdGFbcG9zICsgMl1dID0gcmVzdWx0O1xuICAgICAgICAgICAgZGF0YVtwb3MgKyAzXSA9IDI1NTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGZyYW1lLCBmcm9tLngsIGZyb20ueSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVdyYXBwZXI7XG4iLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBzdXBlclByb3BCYXNlID0gcmVxdWlyZShcIi4vc3VwZXJQcm9wQmFzZS5qc1wiKTtcblxuZnVuY3Rpb24gX2dldCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gUmVmbGVjdC5nZXQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IHN1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IHJlY2VpdmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICB9XG5cbiAgcmV0dXJuIF9nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIGJhc2VNZXJnZSA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZScpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gcmVxdWlyZSgnLi9fY3JlYXRlQXNzaWduZXInKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIChtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzKSwgX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCIvKipcbiAqIGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL1RpcHMvNDA3MTcyL0Nvbm5lY3RlZC1Db21wb25lbnQtTGFiZWxpbmctYW5kLVZlY3Rvcml6YXRpb25cbiAqL1xuY29uc3QgVHJhY2VyID0ge1xuICAgIHNlYXJjaERpcmVjdGlvbnM6IFtbMCwgMV0sIFsxLCAxXSwgWzEsIDBdLCBbMSwgLTFdLCBbMCwgLTFdLCBbLTEsIC0xXSwgWy0xLCAwXSwgWy0xLCAxXV0sXG4gICAgY3JlYXRlKGltYWdlV3JhcHBlciwgbGFiZWxXcmFwcGVyKSB7XG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgICAgICBjb25zdCBsYWJlbERhdGEgPSBsYWJlbFdyYXBwZXIuZGF0YTtcbiAgICAgICAgY29uc3QgeyBzZWFyY2hEaXJlY3Rpb25zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgICAgIGxldCBwb3M7XG5cbiAgICAgICAgZnVuY3Rpb24gdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpIHtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgICBsZXQgeDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgICAgIHkgPSBjdXJyZW50LmN5ICsgc2VhcmNoRGlyZWN0aW9uc1tjdXJyZW50LmRpcl1bMF07XG4gICAgICAgICAgICAgICAgeCA9IGN1cnJlbnQuY3ggKyBzZWFyY2hEaXJlY3Rpb25zW2N1cnJlbnQuZGlyXVsxXTtcbiAgICAgICAgICAgICAgICBwb3MgPSB5ICogd2lkdGggKyB4O1xuICAgICAgICAgICAgICAgIGlmICgoaW1hZ2VEYXRhW3Bvc10gPT09IGNvbG9yKSAmJiAoKGxhYmVsRGF0YVtwb3NdID09PSAwKSB8fCAobGFiZWxEYXRhW3Bvc10gPT09IGxhYmVsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhW3Bvc10gPSBsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5jeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuY3ggPSB4O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gZWRnZWxhYmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50LmRpciA9IChjdXJyZW50LmRpciArIDEpICUgODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHZlcnRleDJEKHgsIHksIGRpcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcHJldjogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICBsZXQgRnYgPSBudWxsO1xuICAgICAgICAgICAgbGV0IEN2O1xuICAgICAgICAgICAgbGV0IFA7XG4gICAgICAgICAgICBsZXQgbGRpcjtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgY3g6IHN4LFxuICAgICAgICAgICAgICAgIGN5OiBzeSxcbiAgICAgICAgICAgICAgICBkaXI6IDAsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgRnYgPSB2ZXJ0ZXgyRChzeCwgc3ksIGN1cnJlbnQuZGlyKTtcbiAgICAgICAgICAgICAgICBDdiA9IEZ2O1xuICAgICAgICAgICAgICAgIGxkaXIgPSBjdXJyZW50LmRpcjtcbiAgICAgICAgICAgICAgICBQID0gdmVydGV4MkQoY3VycmVudC5jeCwgY3VycmVudC5jeSwgMCk7XG4gICAgICAgICAgICAgICAgUC5wcmV2ID0gQ3Y7XG4gICAgICAgICAgICAgICAgQ3YubmV4dCA9IFA7XG4gICAgICAgICAgICAgICAgUC5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBDdiA9IFA7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmRpciA9IChjdXJyZW50LmRpciArIDYpICUgODtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGRpciAhPT0gY3VycmVudC5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LmRpciA9IGN1cnJlbnQuZGlyO1xuICAgICAgICAgICAgICAgICAgICAgICAgUCA9IHZlcnRleDJEKGN1cnJlbnQuY3gsIGN1cnJlbnQuY3ksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgUC5wcmV2ID0gQ3Y7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5uZXh0ID0gUDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFAubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdiA9IFA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5kaXIgPSBsZGlyO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YueCA9IGN1cnJlbnQuY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi55ID0gY3VycmVudC5jeTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZGlyID0gY3VycmVudC5kaXI7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoY3VycmVudC5jeCAhPT0gc3ggfHwgY3VycmVudC5jeSAhPT0gc3kpO1xuICAgICAgICAgICAgICAgIEZ2LnByZXYgPSBDdi5wcmV2O1xuICAgICAgICAgICAgICAgIEN2LnByZXYubmV4dCA9IEZ2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEZ2O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRvdXJUcmFjaW5nKHN5LCBzeCwgbGFiZWwsIGNvbG9yLCBlZGdlbGFiZWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgKFRyYWNlcik7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwiaW1wb3J0ICogYXMgdmVjMiBmcm9tICdnbC12ZWMyJztcbmltcG9ydCAqIGFzIG1hdDIgZnJvbSAnZ2wtbWF0Mic7XG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gJy4uL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCB7XG4gICAgY2FsY3VsYXRlUGF0Y2hTaXplLFxuICAgIG90c3VUaHJlc2hvbGQsXG4gICAgaHN2MnJnYixcbiAgICBjbHVzdGVyLFxuICAgIHRvcEdlbmVyaWMsXG4gICAgaW1hZ2VSZWYsXG4gICAgaGFsZlNhbXBsZSxcbiAgICBjb21wdXRlSW1hZ2VBcmVhLFxufSBmcm9tICcuLi9jb21tb24vY3ZfdXRpbHMnO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBSYXN0ZXJpemVyIGZyb20gJy4vcmFzdGVyaXplcic7XG5pbXBvcnQgVHJhY2VyIGZyb20gJy4vdHJhY2VyJztcbmltcG9ydCBza2VsZXRvbml6ZXIgZnJvbSAnLi9za2VsZXRvbml6ZXInO1xuXG5cbmxldCBfY29uZmlnO1xubGV0IF9jdXJyZW50SW1hZ2VXcmFwcGVyO1xubGV0IF9za2VsSW1hZ2VXcmFwcGVyO1xubGV0IF9zdWJJbWFnZVdyYXBwZXI7XG5sZXQgX2xhYmVsSW1hZ2VXcmFwcGVyO1xubGV0IF9wYXRjaEdyaWQ7XG5sZXQgX3BhdGNoTGFiZWxHcmlkO1xubGV0IF9pbWFnZVRvUGF0Y2hHcmlkO1xubGV0IF9iaW5hcnlJbWFnZVdyYXBwZXI7XG5sZXQgX3BhdGNoU2l6ZTtcbmNvbnN0IF9jYW52YXNDb250YWluZXIgPSB7XG4gICAgY3R4OiB7XG4gICAgICAgIGJpbmFyeTogbnVsbCxcbiAgICB9LFxuICAgIGRvbToge1xuICAgICAgICBiaW5hcnk6IG51bGwsXG4gICAgfSxcbn07XG5jb25zdCBfbnVtUGF0Y2hlcyA9IHsgeDogMCwgeTogMCB9O1xubGV0IF9pbnB1dEltYWdlV3JhcHBlcjtcbmxldCBfc2tlbGV0b25pemVyO1xuXG5mdW5jdGlvbiBpbml0QnVmZmVycygpIHtcbiAgICBpZiAoX2NvbmZpZy5oYWxmU2FtcGxlKSB7XG4gICAgICAgIF9jdXJyZW50SW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcih7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgeDogX2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCAvIDIgfCAwLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgIHk6IF9pbnB1dEltYWdlV3JhcHBlci5zaXplLnkgLyAyIHwgMCxcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2N1cnJlbnRJbWFnZVdyYXBwZXIgPSBfaW5wdXRJbWFnZVdyYXBwZXI7XG4gICAgfVxuXG4gICAgX3BhdGNoU2l6ZSA9IGNhbGN1bGF0ZVBhdGNoU2l6ZShfY29uZmlnLnBhdGNoU2l6ZSwgX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZSk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIF9udW1QYXRjaGVzLnggPSBfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnggLyBfcGF0Y2hTaXplLnggfCAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgX251bVBhdGNoZXMueSA9IF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueSAvIF9wYXRjaFNpemUueSB8IDA7XG5cbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfY3VycmVudEltYWdlV3JhcHBlci5zaXplLCB1bmRlZmluZWQsIFVpbnQ4QXJyYXksIGZhbHNlKTtcblxuICAgIF9sYWJlbEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX3BhdGNoU2l6ZSwgdW5kZWZpbmVkLCBBcnJheSwgdHJ1ZSk7XG5cbiAgICBjb25zdCBza2VsZXRvbkltYWdlRGF0YSA9IG5ldyBBcnJheUJ1ZmZlcig2NCAqIDEwMjQpO1xuICAgIF9zdWJJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHNrZWxldG9uSW1hZ2VEYXRhLCAwLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkpKTtcbiAgICBfc2tlbEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX3BhdGNoU2l6ZSxcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoc2tlbGV0b25JbWFnZURhdGEsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSAqIDMsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSksXG4gICAgICAgIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgX3NrZWxldG9uaXplciA9IHNrZWxldG9uaXplcihcbiAgICAgICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6ICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpID8gc2VsZiA6IGdsb2JhbCxcbiAgICAgICAgeyBzaXplOiBfcGF0Y2hTaXplLnggfSxcbiAgICAgICAgc2tlbGV0b25JbWFnZURhdGEsXG4gICAgKTtcblxuICAgIF9pbWFnZVRvUGF0Y2hHcmlkID0gbmV3IEltYWdlV3JhcHBlcih7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIHg6IChfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnggLyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCkgfCAwLFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB5OiAoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gX3N1YkltYWdlV3JhcHBlci5zaXplLnkpIHwgMCxcbiAgICB9LCB1bmRlZmluZWQsIEFycmF5LCB0cnVlKTtcbiAgICBfcGF0Y2hHcmlkID0gbmV3IEltYWdlV3JhcHBlcihfaW1hZ2VUb1BhdGNoR3JpZC5zaXplLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgX3BhdGNoTGFiZWxHcmlkID0gbmV3IEltYWdlV3JhcHBlcihfaW1hZ2VUb1BhdGNoR3JpZC5zaXplLCB1bmRlZmluZWQsIEludDMyQXJyYXksIHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0Q2FudmFzKCkge1xuICAgIGlmIChfY29uZmlnLnVzZVdvcmtlciB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LmNsYXNzTmFtZSA9ICdiaW5hcnlCdWZmZXInO1xuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Q2FudmFzID09PSB0cnVlKSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkZWJ1ZycpLmFwcGVuZENoaWxkKF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSk7XG4gICAgfVxuICAgIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSA9IF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS53aWR0aCA9IF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5oZWlnaHQgPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYm91bmRpbmcgYm94IHdoaWNoIGVuY2xvc2VzIGFsbCB0aGUgZ2l2ZW4gcGF0Y2hlc1xuICogQHJldHVybnMge0FycmF5fSBUaGUgbWluaW1hbCBib3VuZGluZyBib3hcbiAqL1xuZnVuY3Rpb24gYm94RnJvbVBhdGNoZXMocGF0Y2hlcykge1xuICAgIGxldCBvdmVyQXZnO1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuICAgIGxldCBwYXRjaDtcbiAgICBsZXQgdHJhbnNNYXQ7XG4gICAgbGV0IG1pbnggPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgbWlueSA9IF9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGxldCBtYXh4ID0gLV9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGxldCBtYXh5ID0gLV9iaW5hcnlJbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGxldCBib3g7XG4gICAgbGV0IHNjYWxlO1xuXG4gICAgLy8gZHJhdyBhbGwgcGF0Y2hlcyB3aGljaCBhcmUgdG8gYmUgdGFrZW4gaW50byBjb25zaWRlcmF0aW9uXG4gICAgb3ZlckF2ZyA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBvdmVyQXZnICs9IHBhdGNoLnJhZDtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dQYXRjaGVzKSB7XG4gICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICdyZWQnIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3ZlckF2ZyAvPSBwYXRjaGVzLmxlbmd0aDtcbiAgICBvdmVyQXZnID0gKG92ZXJBdmcgKiAxODAgLyBNYXRoLlBJICsgOTApICUgMTgwIC0gOTA7XG4gICAgaWYgKG92ZXJBdmcgPCAwKSB7XG4gICAgICAgIG92ZXJBdmcgKz0gMTgwO1xuICAgIH1cblxuICAgIG92ZXJBdmcgPSAoMTgwIC0gb3ZlckF2ZykgKiBNYXRoLlBJIC8gMTgwO1xuICAgIHRyYW5zTWF0ID0gbWF0Mi5jb3B5KG1hdDIuY3JlYXRlKCksIFtNYXRoLmNvcyhvdmVyQXZnKSwgTWF0aC5zaW4ob3ZlckF2ZyksIC1NYXRoLnNpbihvdmVyQXZnKSwgTWF0aC5jb3Mob3ZlckF2ZyldKTtcblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBwYXRjaGVzIGFuZCByb3RhdGUgYnkgYW5nbGVcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgIHZlYzIudHJhbnNmb3JtTWF0MihwYXRjaC5ib3hbal0sIHBhdGNoLmJveFtqXSwgdHJhbnNNYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dUcmFuc2Zvcm1lZCkge1xuICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChwYXRjaC5ib3gsIHsgeDogMCwgeTogMSB9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICcjOTlmZjAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluZCBib3VuZGluZyBib3hcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMF0gPCBtaW54KSB7XG4gICAgICAgICAgICAgICAgbWlueCA9IHBhdGNoLmJveFtqXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMF0gPiBtYXh4KSB7XG4gICAgICAgICAgICAgICAgbWF4eCA9IHBhdGNoLmJveFtqXVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMV0gPCBtaW55KSB7XG4gICAgICAgICAgICAgICAgbWlueSA9IHBhdGNoLmJveFtqXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRjaC5ib3hbal1bMV0gPiBtYXh5KSB7XG4gICAgICAgICAgICAgICAgbWF4eSA9IHBhdGNoLmJveFtqXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJveCA9IFtbbWlueCwgbWlueV0sIFttYXh4LCBtaW55XSwgW21heHgsIG1heHldLCBbbWlueCwgbWF4eV1dO1xuXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dUcmFuc2Zvcm1lZEJveCkge1xuICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwgeyB4OiAwLCB5OiAxIH0sIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwgeyBjb2xvcjogJyNmZjAwMDAnLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgfVxuXG4gICAgc2NhbGUgPSBfY29uZmlnLmhhbGZTYW1wbGUgPyAyIDogMTtcbiAgICAvLyByZXZlcnNlIHJvdGF0aW9uO1xuICAgIHRyYW5zTWF0ID0gbWF0Mi5pbnZlcnQodHJhbnNNYXQsIHRyYW5zTWF0KTtcbiAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgIHZlYzIudHJhbnNmb3JtTWF0Mihib3hbal0sIGJveFtqXSwgdHJhbnNNYXQpO1xuICAgIH1cblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93QkIpIHtcbiAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChib3gsIHsgeDogMCwgeTogMSB9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICcjZmYwMDAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgIH1cblxuICAgIGZvciAoaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgdmVjMi5zY2FsZShib3hbal0sIGJveFtqXSwgc2NhbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBib3g7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJpbmFyeSBpbWFnZSBvZiB0aGUgY3VycmVudCBpbWFnZVxuICovXG5mdW5jdGlvbiBiaW5hcml6ZUltYWdlKCkge1xuICAgIG90c3VUaHJlc2hvbGQoX2N1cnJlbnRJbWFnZVdyYXBwZXIsIF9iaW5hcnlJbWFnZVdyYXBwZXIpO1xuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuemVyb0JvcmRlcigpO1xuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Q2FudmFzKSB7XG4gICAgICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuc2hvdyhfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIDI1NSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciB0aGUgZW50aXJlIGltYWdlXG4gKiBleHRyYWN0IHBhdGNoZXNcbiAqL1xuZnVuY3Rpb24gZmluZFBhdGNoZXMoKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG4gICAgbGV0IG1vbWVudHM7XG4gICAgbGV0IHBhdGNoZXNGb3VuZCA9IFtdO1xuICAgIGxldCByYXN0ZXJpemVyO1xuICAgIGxldCByYXN0ZXJSZXN1bHQ7XG4gICAgbGV0IHBhdGNoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBfbnVtUGF0Y2hlcy54OyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IF9udW1QYXRjaGVzLnk7IGorKykge1xuICAgICAgICAgICAgeCA9IF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54ICogaTtcbiAgICAgICAgICAgIHkgPSBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueSAqIGo7XG5cbiAgICAgICAgICAgIC8vIHNlcGVyYXRlIHBhcnRzXG4gICAgICAgICAgICBza2VsZXRvbml6ZSh4LCB5KTtcblxuICAgICAgICAgICAgLy8gUmFzdGVyaXplLCBmaW5kIGluZGl2aWR1YWwgYmFyc1xuICAgICAgICAgICAgX3NrZWxJbWFnZVdyYXBwZXIuemVyb0JvcmRlcigpO1xuICAgICAgICAgICAgQXJyYXlIZWxwZXIuaW5pdChfbGFiZWxJbWFnZVdyYXBwZXIuZGF0YSwgMCk7XG4gICAgICAgICAgICByYXN0ZXJpemVyID0gUmFzdGVyaXplci5jcmVhdGUoX3NrZWxJbWFnZVdyYXBwZXIsIF9sYWJlbEltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICByYXN0ZXJSZXN1bHQgPSByYXN0ZXJpemVyLnJhc3Rlcml6ZSgwKTtcblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICBfbGFiZWxJbWFnZVdyYXBwZXIub3ZlcmxheShfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIE1hdGguZmxvb3IoMzYwIC8gcmFzdGVyUmVzdWx0LmNvdW50KSxcbiAgICAgICAgICAgICAgICAgICAgeyB4LCB5IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgbW9tZW50cyBmcm9tIHRoZSBza2VsZXRvbml6ZWQgcGF0Y2hcbiAgICAgICAgICAgIG1vbWVudHMgPSBfbGFiZWxJbWFnZVdyYXBwZXIubW9tZW50cyhyYXN0ZXJSZXN1bHQuY291bnQpO1xuXG4gICAgICAgICAgICAvLyBleHRyYWN0IGVsaWdpYmxlIHBhdGNoZXNcbiAgICAgICAgICAgIHBhdGNoZXNGb3VuZCA9IHBhdGNoZXNGb3VuZC5jb25jYXQoZGVzY3JpYmVQYXRjaChtb21lbnRzLCBbaSwgal0sIHgsIHkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Rm91bmRQYXRjaGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXRjaGVzRm91bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhdGNoID0gcGF0Y2hlc0ZvdW5kW2ldO1xuICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxuICAgICAgICAgICAgICAgIHsgY29sb3I6ICcjOTlmZjAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGNoZXNGb3VuZDtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aG9zZSBjb25uZWN0ZWQgYXJlYXMgd2hpY2ggY29udGFpbiBhdCBsZWFzdCA2IHBhdGNoZXNcbiAqIGFuZCByZXR1cm5zIHRoZW0gb3JkZXJlZCBERVNDIGJ5IHRoZSBudW1iZXIgb2YgY29udGFpbmVkIHBhdGNoZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhMYWJlbFxuICovXG5mdW5jdGlvbiBmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzKG1heExhYmVsKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IHN1bTtcbiAgICBsZXQgbGFiZWxIaXN0ID0gW107XG4gICAgbGV0IHRvcExhYmVscyA9IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG1heExhYmVsOyBpKyspIHtcbiAgICAgICAgbGFiZWxIaXN0LnB1c2goMCk7XG4gICAgfVxuICAgIHN1bSA9IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDtcbiAgICB3aGlsZSAoc3VtLS0pIHtcbiAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gPiAwKSB7XG4gICAgICAgICAgICBsYWJlbEhpc3RbX3BhdGNoTGFiZWxHcmlkLmRhdGFbc3VtXSAtIDFdKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsYWJlbEhpc3QgPSBsYWJlbEhpc3QubWFwKCh2YWwsIGlkeCkgPT4gKHtcbiAgICAgICAgdmFsLFxuICAgICAgICBsYWJlbDogaWR4ICsgMSxcbiAgICB9KSk7XG5cbiAgICBsYWJlbEhpc3Quc29ydCgoYSwgYikgPT4gYi52YWwgLSBhLnZhbCk7XG5cbiAgICAvLyBleHRyYWN0IHRvcCBhcmVhcyB3aXRoIGF0IGxlYXN0IDYgcGF0Y2hlcyBwcmVzZW50XG4gICAgdG9wTGFiZWxzID0gbGFiZWxIaXN0LmZpbHRlcigoZWwpID0+IGVsLnZhbCA+PSA1KTtcblxuICAgIHJldHVybiB0b3BMYWJlbHM7XG59XG5cbi8qKlxuICpcbiAqL1xuZnVuY3Rpb24gZmluZEJveGVzKHRvcExhYmVscywgbWF4TGFiZWwpIHtcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcbiAgICBsZXQgc3VtO1xuICAgIGNvbnN0IHBhdGNoZXMgPSBbXTtcbiAgICBsZXQgcGF0Y2g7XG4gICAgbGV0IGJveDtcbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIGNvbnN0IGhzdiA9IFswLCAxLCAxXTtcbiAgICBjb25zdCByZ2IgPSBbMCwgMCwgMF07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9wTGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN1bSA9IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDtcbiAgICAgICAgcGF0Y2hlcy5sZW5ndGggPSAwO1xuICAgICAgICB3aGlsZSAoc3VtLS0pIHtcbiAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dID09PSB0b3BMYWJlbHNbaV0ubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBwYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbc3VtXTtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJveCA9IGJveEZyb21QYXRjaGVzKHBhdGNoZXMpO1xuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgICBib3hlcy5wdXNoKGJveCk7XG5cbiAgICAgICAgICAgIC8vIGRyYXcgcGF0Y2gtbGFiZWxzIGlmIHJlcXVlc3RlZFxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dSZW1haW5pbmdQYXRjaExhYmVscykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwYXRjaGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoID0gcGF0Y2hlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaHN2WzBdID0gKHRvcExhYmVsc1tpXS5sYWJlbCAvIChtYXhMYWJlbCArIDEpKSAqIDM2MDtcbiAgICAgICAgICAgICAgICAgICAgaHN2MnJnYihoc3YsIHJnYik7XG4gICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgY29sb3I6IGByZ2IoJHtyZ2Iuam9pbignLCcpfSlgLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3hlcztcbn1cblxuLyoqXG4gKiBGaW5kIHNpbWlsYXIgbW9tZW50cyAodmlhIGNsdXN0ZXIpXG4gKiBAcGFyYW0ge09iamVjdH0gbW9tZW50c1xuICovXG5mdW5jdGlvbiBzaW1pbGFyTW9tZW50cyhtb21lbnRzKSB7XG4gICAgY29uc3QgY2x1c3RlcnMgPSBjbHVzdGVyKG1vbWVudHMsIDAuOTApO1xuICAgIGNvbnN0IHRvcENsdXN0ZXIgPSB0b3BHZW5lcmljKGNsdXN0ZXJzLCAxLCAoZSkgPT4gZS5nZXRQb2ludHMoKS5sZW5ndGgpO1xuICAgIGxldCBwb2ludHMgPSBbXTsgY29uc3RcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgaWYgKHRvcENsdXN0ZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBvaW50cyA9IHRvcENsdXN0ZXJbMF0uaXRlbS5nZXRQb2ludHMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1tpXS5wb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2tlbGV0b25pemUoeCwgeSkge1xuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuc3ViSW1hZ2VBc0NvcHkoX3N1YkltYWdlV3JhcHBlciwgaW1hZ2VSZWYoeCwgeSkpO1xuICAgIF9za2VsZXRvbml6ZXIuc2tlbGV0b25pemUoKTtcblxuICAgIC8vIFNob3cgc2tlbGV0b24gaWYgcmVxdWVzdGVkXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dTa2VsZXRvbikge1xuICAgICAgICBfc2tlbEltYWdlV3JhcHBlci5vdmVybGF5KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgMzYwLCBpbWFnZVJlZih4LCB5KSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3RzIGFuZCBkZXNjcmliZXMgdGhvc2UgcGF0Y2hlcyB3aGljaCBzZWVtIHRvIGNvbnRhaW4gYSBiYXJjb2RlIHBhdHRlcm5cbiAqIEBwYXJhbSB7QXJyYXl9IG1vbWVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXRjaFBvcyxcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybnMge0FycmF5fSBsaXN0IG9mIHBhdGNoZXNcbiAqL1xuZnVuY3Rpb24gZGVzY3JpYmVQYXRjaChtb21lbnRzLCBwYXRjaFBvcywgeCwgeSkge1xuICAgIGxldCBrO1xuICAgIGxldCBhdmc7XG4gICAgY29uc3QgZWxpZ2libGVNb21lbnRzID0gW107XG4gICAgbGV0IG1hdGNoaW5nTW9tZW50cztcbiAgICBsZXQgcGF0Y2g7XG4gICAgY29uc3QgcGF0Y2hlc0ZvdW5kID0gW107XG4gICAgY29uc3QgbWluQ29tcG9uZW50V2VpZ2h0ID0gTWF0aC5jZWlsKF9wYXRjaFNpemUueCAvIDMpO1xuXG4gICAgaWYgKG1vbWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgLy8gb25seSBjb2xsZWN0IG1vbWVudHMgd2hpY2gncyBhcmVhIGNvdmVycyBhdCBsZWFzdCBtaW5Db21wb25lbnRXZWlnaHQgcGl4ZWxzLlxuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbW9tZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgaWYgKG1vbWVudHNba10ubTAwID4gbWluQ29tcG9uZW50V2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZWxpZ2libGVNb21lbnRzLnB1c2gobW9tZW50c1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhdCBsZWFzdCAyIG1vbWVudHMgYXJlIGZvdW5kIHdoaWNoIGhhdmUgYXQgbGVhc3QgbWluQ29tcG9uZW50V2VpZ2h0cyBjb3ZlcmVkXG4gICAgICAgIGlmIChlbGlnaWJsZU1vbWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIG1hdGNoaW5nTW9tZW50cyA9IHNpbWlsYXJNb21lbnRzKGVsaWdpYmxlTW9tZW50cyk7XG4gICAgICAgICAgICBhdmcgPSAwO1xuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBzaW1pbGFyaXR5IG9mIHRoZSBtb21lbnRzXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbWF0Y2hpbmdNb21lbnRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgYXZnICs9IG1hdGNoaW5nTW9tZW50c1trXS5yYWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdHdvIG9mIHRoZSBtb21lbnRzIGFyZSBhbGxvd2VkIG5vdCB0byBmaXQgaW50byB0aGUgZXF1YXRpb25cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgcGF0Y2ggdG8gdGhlIHNldFxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgICAgICYmIG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPj0gKGVsaWdpYmxlTW9tZW50cy5sZW5ndGggLyA0KSAqIDNcbiAgICAgICAgICAgICAgICAgICAgJiYgbWF0Y2hpbmdNb21lbnRzLmxlbmd0aCA+IG1vbWVudHMubGVuZ3RoIC8gNCkge1xuICAgICAgICAgICAgICAgIGF2ZyAvPSBtYXRjaGluZ01vbWVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBhdGNoID0ge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogcGF0Y2hQb3NbMV0gKiBfbnVtUGF0Y2hlcy54ICsgcGF0Y2hQb3NbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBvczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGJveDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCwgeV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54LCB5XSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWMyLmNsb25lKFt4ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLngsIHkgKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCwgeSArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55XSksXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudHM6IG1hdGNoaW5nTW9tZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcmFkOiBhdmcsXG4gICAgICAgICAgICAgICAgICAgIHZlYzogdmVjMi5jbG9uZShbTWF0aC5jb3MoYXZnKSwgTWF0aC5zaW4oYXZnKV0pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcGF0Y2hlc0ZvdW5kLnB1c2gocGF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRjaGVzRm91bmQ7XG59XG5cbi8qKlxuICogZmluZHMgcGF0Y2hlcyB3aGljaCBhcmUgY29ubmVjdGVkIGFuZCBzaGFyZSB0aGUgc2FtZSBvcmllbnRhdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHBhdGNoZXNGb3VuZFxuICovXG5mdW5jdGlvbiByYXN0ZXJpemVBbmd1bGFyU2ltaWxhcml0eShwYXRjaGVzRm91bmQpIHtcbiAgICBsZXQgbGFiZWwgPSAwO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IDAuOTU7XG4gICAgbGV0IGN1cnJJZHggPSAwO1xuICAgIGxldCBqO1xuICAgIGxldCBwYXRjaDtcbiAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XG4gICAgY29uc3QgcmdiID0gWzAsIDAsIDBdO1xuXG4gICAgZnVuY3Rpb24gbm90WWV0UHJvY2Vzc2VkKCkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbaV0gPT09IDAgJiYgX3BhdGNoR3JpZC5kYXRhW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wYXRjaExhYmVsR3JpZC5sZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhY2UoY3VycmVudElkeCkge1xuICAgICAgICBsZXQgeDtcbiAgICAgICAgbGV0IHk7XG4gICAgICAgIGxldCBjdXJyZW50UGF0Y2g7XG4gICAgICAgIGxldCBpZHg7XG4gICAgICAgIGxldCBkaXI7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB7XG4gICAgICAgICAgICB4OiBjdXJyZW50SWR4ICUgX3BhdGNoTGFiZWxHcmlkLnNpemUueCxcbiAgICAgICAgICAgIHk6IChjdXJyZW50SWR4IC8gX3BhdGNoTGFiZWxHcmlkLnNpemUueCkgfCAwLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgc2ltaWxhcml0eTtcblxuICAgICAgICBpZiAoY3VycmVudElkeCA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgY3VycmVudFBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtjdXJyZW50SWR4XTtcbiAgICAgICAgICAgIC8vIGFzc2lnbiBsYWJlbFxuICAgICAgICAgICAgX3BhdGNoTGFiZWxHcmlkLmRhdGFbY3VycmVudElkeF0gPSBsYWJlbDtcbiAgICAgICAgICAgIGZvciAoZGlyID0gMDsgZGlyIDwgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnMubGVuZ3RoOyBkaXIrKykge1xuICAgICAgICAgICAgICAgIHkgPSBjdXJyZW50LnkgKyBUcmFjZXIuc2VhcmNoRGlyZWN0aW9uc1tkaXJdWzBdO1xuICAgICAgICAgICAgICAgIHggPSBjdXJyZW50LnggKyBUcmFjZXIuc2VhcmNoRGlyZWN0aW9uc1tkaXJdWzFdO1xuICAgICAgICAgICAgICAgIGlkeCA9IHkgKiBfcGF0Y2hMYWJlbEdyaWQuc2l6ZS54ICsgeDtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIGlmIHBhdGNoIGVtcHR5XG4gICAgICAgICAgICAgICAgaWYgKF9wYXRjaEdyaWQuZGF0YVtpZHhdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wYXRjaExhYmVsR3JpZC5kYXRhW2lkeF0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2lkeF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2ltaWxhcml0eSA9IE1hdGguYWJzKHZlYzIuZG90KF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbaWR4XS52ZWMsIGN1cnJlbnRQYXRjaC52ZWMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbWlsYXJpdHkgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcmVwYXJlIGZvciBmaW5kaW5nIHRoZSByaWdodCBwYXRjaGVzXG4gICAgQXJyYXlIZWxwZXIuaW5pdChfcGF0Y2hHcmlkLmRhdGEsIDApO1xuICAgIEFycmF5SGVscGVyLmluaXQoX3BhdGNoTGFiZWxHcmlkLmRhdGEsIDApO1xuICAgIEFycmF5SGVscGVyLmluaXQoX2ltYWdlVG9QYXRjaEdyaWQuZGF0YSwgbnVsbCk7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgcGF0Y2hlc0ZvdW5kLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc0ZvdW5kW2pdO1xuICAgICAgICBfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW3BhdGNoLmluZGV4XSA9IHBhdGNoO1xuICAgICAgICBfcGF0Y2hHcmlkLmRhdGFbcGF0Y2guaW5kZXhdID0gMTtcbiAgICB9XG5cbiAgICAvLyByYXN0ZXJpemUgdGhlIHBhdGNoZXMgZm91bmQgdG8gZGV0ZXJtaW5lIGFyZWFcbiAgICBfcGF0Y2hHcmlkLnplcm9Cb3JkZXIoKTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgIHdoaWxlICgoY3VycklkeCA9IG5vdFlldFByb2Nlc3NlZCgpKSA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICBsYWJlbCsrO1xuICAgICAgICB0cmFjZShjdXJySWR4KTtcbiAgICB9XG5cbiAgICAvLyBkcmF3IHBhdGNoLWxhYmVscyBpZiByZXF1ZXN0ZWRcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd1BhdGNoTGFiZWxzKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2pdID4gMCAmJiBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtqXSA8PSBsYWJlbCkge1xuICAgICAgICAgICAgICAgIHBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtqXTtcbiAgICAgICAgICAgICAgICBoc3ZbMF0gPSAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbal0gLyAobGFiZWwgKyAxKSkgKiAzNjA7XG4gICAgICAgICAgICAgICAgaHN2MnJnYihoc3YsIHJnYik7XG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxuICAgICAgICAgICAgICAgICAgICB7IGNvbG9yOiBgcmdiKCR7cmdiLmpvaW4oJywnKX0pYCwgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdChpbnB1dEltYWdlV3JhcHBlciwgY29uZmlnKSB7XG4gICAgICAgIF9jb25maWcgPSBjb25maWc7XG4gICAgICAgIF9pbnB1dEltYWdlV3JhcHBlciA9IGlucHV0SW1hZ2VXcmFwcGVyO1xuXG4gICAgICAgIGluaXRCdWZmZXJzKCk7XG4gICAgICAgIGluaXRDYW52YXMoKTtcbiAgICB9LFxuXG4gICAgbG9jYXRlKCkge1xuICAgICAgICBpZiAoX2NvbmZpZy5oYWxmU2FtcGxlKSB7XG4gICAgICAgICAgICBoYWxmU2FtcGxlKF9pbnB1dEltYWdlV3JhcHBlciwgX2N1cnJlbnRJbWFnZVdyYXBwZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmluYXJpemVJbWFnZSgpO1xuICAgICAgICBjb25zdCBwYXRjaGVzRm91bmQgPSBmaW5kUGF0Y2hlcygpO1xuICAgICAgICAvLyByZXR1cm4gdW5sZXNzIDUlIG9yIG1vcmUgcGF0Y2hlcyBhcmUgZm91bmRcbiAgICAgICAgaWYgKHBhdGNoZXNGb3VuZC5sZW5ndGggPCBfbnVtUGF0Y2hlcy54ICogX251bVBhdGNoZXMueSAqIDAuMDUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmFzdGVycml6ZSBhcmVhIGJ5IGNvbXBhcmluZyBhbmd1bGFyIHNpbWlsYXJpdHk7XG4gICAgICAgIGNvbnN0IG1heExhYmVsID0gcmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkocGF0Y2hlc0ZvdW5kKTtcbiAgICAgICAgaWYgKG1heExhYmVsIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWFyY2ggZm9yIGFyZWEgd2l0aCB0aGUgbW9zdCBwYXRjaGVzIChiaWdnZXN0IGNvbm5lY3RlZCBhcmVhKVxuICAgICAgICBjb25zdCB0b3BMYWJlbHMgPSBmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzKG1heExhYmVsKTtcbiAgICAgICAgaWYgKHRvcExhYmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYm94ZXMgPSBmaW5kQm94ZXModG9wTGFiZWxzLCBtYXhMYWJlbCk7XG4gICAgICAgIHJldHVybiBib3hlcztcbiAgICB9LFxuXG4gICAgY2hlY2tJbWFnZUNvbnN0cmFpbnRzKGlucHV0U3RyZWFtLCBjb25maWcpIHtcbiAgICAgICAgbGV0IHBhdGNoU2l6ZTtcbiAgICAgICAgbGV0IHdpZHRoID0gaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKTtcbiAgICAgICAgbGV0IGhlaWdodCA9IGlucHV0U3RyZWFtLmdldEhlaWdodCgpO1xuICAgICAgICBjb25zdCB0aGlzSGFsZlNhbXBsZSA9IGNvbmZpZy5oYWxmU2FtcGxlID8gMC41IDogMTtcbiAgICAgICAgbGV0IGFyZWE7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHdpZHRoIGFuZCBoZWlnaHQgYmFzZWQgb24gYXJlYVxuICAgICAgICBpZiAoaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCkuYXJlYSkge1xuICAgICAgICAgICAgYXJlYSA9IGNvbXB1dGVJbWFnZUFyZWEod2lkdGgsIGhlaWdodCwgaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCkuYXJlYSk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRUb3BSaWdodCh7IHg6IGFyZWEuc3gsIHk6IGFyZWEuc3kgfSk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRDYW52YXNTaXplKHsgeDogd2lkdGgsIHk6IGhlaWdodCB9KTtcbiAgICAgICAgICAgIHdpZHRoID0gYXJlYS5zdztcbiAgICAgICAgICAgIGhlaWdodCA9IGFyZWEuc2g7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzaXplID0ge1xuICAgICAgICAgICAgeDogTWF0aC5mbG9vcih3aWR0aCAqIHRoaXNIYWxmU2FtcGxlKSxcbiAgICAgICAgICAgIHk6IE1hdGguZmxvb3IoaGVpZ2h0ICogdGhpc0hhbGZTYW1wbGUpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHBhdGNoU2l6ZSA9IGNhbGN1bGF0ZVBhdGNoU2l6ZShjb25maWcucGF0Y2hTaXplLCBzaXplKTtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBhdGNoLVNpemU6ICR7SlNPTi5zdHJpbmdpZnkocGF0Y2hTaXplKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0U3RyZWFtLnNldFdpZHRoKE1hdGguZmxvb3IoTWF0aC5mbG9vcihzaXplLnggLyBwYXRjaFNpemUueCkgKiAoMSAvIHRoaXNIYWxmU2FtcGxlKSAqIHBhdGNoU2l6ZS54KSk7XG4gICAgICAgIGlucHV0U3RyZWFtLnNldEhlaWdodChNYXRoLmZsb29yKE1hdGguZmxvb3Ioc2l6ZS55IC8gcGF0Y2hTaXplLnkpICogKDEgLyB0aGlzSGFsZlNhbXBsZSkgKiBwYXRjaFNpemUueSkpO1xuXG4gICAgICAgIGlmICgoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSAlIHBhdGNoU2l6ZS54KSA9PT0gMCAmJiAoaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkgJSBwYXRjaFNpemUueSkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSBkaW1lbnNpb25zIGRvIG5vdCBjb21wbHkgd2l0aCB0aGUgY3VycmVudCBzZXR0aW5nczogV2lkdGggKCR7XG4gICAgICAgICAgICB3aWR0aH0gKWFuZCBoZWlnaHQgKCR7aGVpZ2h0XG4gICAgICAgIH0pIG11c3QgYSBtdWx0aXBsZSBvZiAke3BhdGNoU2l6ZS54fWApO1xuICAgIH0sXG59O1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlcy5qc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheS5qc1wiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcIik7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkLmpzXCIpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBkZXRlcm1pbmFudDogcmVxdWlyZSgnLi9kZXRlcm1pbmFudCcpXG4gICwgdHJhbnNwb3NlOiByZXF1aXJlKCcuL3RyYW5zcG9zZScpXG4gICwgbXVsdGlwbHk6IHJlcXVpcmUoJy4vbXVsdGlwbHknKVxuICAsIGlkZW50aXR5OiByZXF1aXJlKCcuL2lkZW50aXR5JylcbiAgLCBhZGpvaW50OiByZXF1aXJlKCcuL2Fkam9pbnQnKVxuICAsIHJvdGF0ZTogcmVxdWlyZSgnLi9yb3RhdGUnKVxuICAsIGludmVydDogcmVxdWlyZSgnLi9pbnZlcnQnKVxuICAsIGNyZWF0ZTogcmVxdWlyZSgnLi9jcmVhdGUnKVxuICAsIHNjYWxlOiByZXF1aXJlKCcuL3NjYWxlJylcbiAgLCBjb3B5OiByZXF1aXJlKCcuL2NvcHknKVxuICAsIGZyb2I6IHJlcXVpcmUoJy4vZnJvYicpXG4gICwgbGR1OiByZXF1aXJlKCcuL2xkdScpXG59XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAqIGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduTWVyZ2VWYWx1ZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgLCB1bmxlc3MgYGtleWAgaXMgXCJfX3Byb3RvX19cIiBvciBcImNvbnN0cnVjdG9yXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzYWZlR2V0O1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG4iLCJ2YXIgYmFzZVNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuIiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCIpO1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIm1vZHVsZS5leHBvcnRzID0gMC4wMDAwMDFcbiIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICpcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpXG4gICAgb3V0WzBdID0gMFxuICAgIG91dFsxXSA9IDBcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzdWJ0cmFjdFxuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHlcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkaXZpZGVcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZGlzdGFuY2VcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZERpc3RhbmNlXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5mdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXVxuICAgIHJldHVybiB4KnggKyB5Knlcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxlbmd0aFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZExlbmd0aFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICByZXR1cm4geCp4ICsgeSp5XG59IiwibW9kdWxlLmV4cG9ydHMgPSAwLjAwMDAwMVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgb3V0WzBdID0gMFxuICAgIG91dFsxXSA9IDBcbiAgICBvdXRbMl0gPSAwXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVZhbHVlcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5mdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHopIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgb3V0WzJdID0gelxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG5vcm1hbGl6ZTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXVxuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnpcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbilcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlblxuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuXG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW5cbiAgICB9XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZG90O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzdWJ0cmFjdDtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXVxuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHk7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXVxuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkaXZpZGU7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXVxuICAgIG91dFsyXSA9IGFbMl0gLyBiWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXVxuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Knpcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5mdW5jdGlvbiBsZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdXG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqelxufSIsInZhciBhcnJheVdpdGhIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aEhvbGVzLmpzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1wiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcIik7XG5cbnZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVJlc3QuanNcIik7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgRVBTSUxPTjogcmVxdWlyZSgnLi9lcHNpbG9uJylcbiAgLCBjcmVhdGU6IHJlcXVpcmUoJy4vY3JlYXRlJylcbiAgLCBjbG9uZTogcmVxdWlyZSgnLi9jbG9uZScpXG4gICwgYW5nbGU6IHJlcXVpcmUoJy4vYW5nbGUnKVxuICAsIGZyb21WYWx1ZXM6IHJlcXVpcmUoJy4vZnJvbVZhbHVlcycpXG4gICwgY29weTogcmVxdWlyZSgnLi9jb3B5JylcbiAgLCBzZXQ6IHJlcXVpcmUoJy4vc2V0JylcbiAgLCBlcXVhbHM6IHJlcXVpcmUoJy4vZXF1YWxzJylcbiAgLCBleGFjdEVxdWFsczogcmVxdWlyZSgnLi9leGFjdEVxdWFscycpXG4gICwgYWRkOiByZXF1aXJlKCcuL2FkZCcpXG4gICwgc3VidHJhY3Q6IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuICAsIHN1YjogcmVxdWlyZSgnLi9zdWInKVxuICAsIG11bHRpcGx5OiByZXF1aXJlKCcuL211bHRpcGx5JylcbiAgLCBtdWw6IHJlcXVpcmUoJy4vbXVsJylcbiAgLCBkaXZpZGU6IHJlcXVpcmUoJy4vZGl2aWRlJylcbiAgLCBkaXY6IHJlcXVpcmUoJy4vZGl2JylcbiAgLCBtaW46IHJlcXVpcmUoJy4vbWluJylcbiAgLCBtYXg6IHJlcXVpcmUoJy4vbWF4JylcbiAgLCBmbG9vcjogcmVxdWlyZSgnLi9mbG9vcicpXG4gICwgY2VpbDogcmVxdWlyZSgnLi9jZWlsJylcbiAgLCByb3VuZDogcmVxdWlyZSgnLi9yb3VuZCcpXG4gICwgc2NhbGU6IHJlcXVpcmUoJy4vc2NhbGUnKVxuICAsIHNjYWxlQW5kQWRkOiByZXF1aXJlKCcuL3NjYWxlQW5kQWRkJylcbiAgLCBkaXN0YW5jZTogcmVxdWlyZSgnLi9kaXN0YW5jZScpXG4gICwgZGlzdDogcmVxdWlyZSgnLi9kaXN0JylcbiAgLCBzcXVhcmVkRGlzdGFuY2U6IHJlcXVpcmUoJy4vc3F1YXJlZERpc3RhbmNlJylcbiAgLCBzcXJEaXN0OiByZXF1aXJlKCcuL3NxckRpc3QnKVxuICAsIGxlbmd0aDogcmVxdWlyZSgnLi9sZW5ndGgnKVxuICAsIGxlbjogcmVxdWlyZSgnLi9sZW4nKVxuICAsIHNxdWFyZWRMZW5ndGg6IHJlcXVpcmUoJy4vc3F1YXJlZExlbmd0aCcpXG4gICwgc3FyTGVuOiByZXF1aXJlKCcuL3NxckxlbicpXG4gICwgbmVnYXRlOiByZXF1aXJlKCcuL25lZ2F0ZScpXG4gICwgaW52ZXJzZTogcmVxdWlyZSgnLi9pbnZlcnNlJylcbiAgLCBub3JtYWxpemU6IHJlcXVpcmUoJy4vbm9ybWFsaXplJylcbiAgLCBkb3Q6IHJlcXVpcmUoJy4vZG90JylcbiAgLCBjcm9zczogcmVxdWlyZSgnLi9jcm9zcycpXG4gICwgbGVycDogcmVxdWlyZSgnLi9sZXJwJylcbiAgLCByYW5kb206IHJlcXVpcmUoJy4vcmFuZG9tJylcbiAgLCB0cmFuc2Zvcm1NYXQ0OiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDQnKVxuICAsIHRyYW5zZm9ybU1hdDM6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0MycpXG4gICwgdHJhbnNmb3JtUXVhdDogcmVxdWlyZSgnLi90cmFuc2Zvcm1RdWF0JylcbiAgLCByb3RhdGVYOiByZXF1aXJlKCcuL3JvdGF0ZVgnKVxuICAsIHJvdGF0ZVk6IHJlcXVpcmUoJy4vcm90YXRlWScpXG4gICwgcm90YXRlWjogcmVxdWlyZSgnLi9yb3RhdGVaJylcbiAgLCBmb3JFYWNoOiByZXF1aXJlKCcuL2ZvckVhY2gnKVxufVxuIiwidmFyIGJhc2VQaWNrID0gcmVxdWlyZSgnLi9fYmFzZVBpY2snKSxcbiAgICBmbGF0UmVzdCA9IHJlcXVpcmUoJy4vX2ZsYXRSZXN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrO1xuIiwidmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vZ2V0UHJvdG90eXBlT2YuanNcIik7XG5cbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuXG52YXIgaXNOYXRpdmVGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2lzTmF0aXZlRnVuY3Rpb24uanNcIik7XG5cbnZhciBjb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3QuanNcIik7XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcblxuICBtb2R1bGUuZXhwb3J0cyA9IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFpc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuXG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBnZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3dyYXBOYXRpdmVTdXBlciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImltcG9ydCBUcmFjZXIgZnJvbSAnLi90cmFjZXInO1xuXG4vKipcbiAqIGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL1RpcHMvNDA3MTcyL0Nvbm5lY3RlZC1Db21wb25lbnQtTGFiZWxpbmctYW5kLVZlY3Rvcml6YXRpb25cbiAqL1xuY29uc3QgUmFzdGVyaXplciA9IHtcbiAgICBjcmVhdGVDb250b3VyMkQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXI6IG51bGwsXG4gICAgICAgICAgICBpbmRleDogbnVsbCxcbiAgICAgICAgICAgIGZpcnN0VmVydGV4OiBudWxsLFxuICAgICAgICAgICAgaW5zaWRlQ29udG91cnM6IG51bGwsXG4gICAgICAgICAgICBuZXh0cGVlcjogbnVsbCxcbiAgICAgICAgICAgIHByZXZwZWVyOiBudWxsLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgQ09OVE9VUl9ESVI6IHtcbiAgICAgICAgQ1dfRElSOiAwLFxuICAgICAgICBDQ1dfRElSOiAxLFxuICAgICAgICBVTktOT1dOX0RJUjogMixcbiAgICB9LFxuICAgIERJUjoge1xuICAgICAgICBPVVRTSURFX0VER0U6IC0zMjc2NyxcbiAgICAgICAgSU5TSURFX0VER0U6IC0zMjc2NixcbiAgICB9LFxuICAgIGNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcikge1xuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICAgICAgY29uc3QgbGFiZWxEYXRhID0gbGFiZWxXcmFwcGVyLmRhdGE7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICAgICAgY29uc3QgdHJhY2VyID0gVHJhY2VyLmNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhc3Rlcml6ZShkZXB0aGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbG9yO1xuICAgICAgICAgICAgICAgIGxldCBiYztcbiAgICAgICAgICAgICAgICBsZXQgbGM7XG4gICAgICAgICAgICAgICAgbGV0IGxhYmVsaW5kZXg7XG4gICAgICAgICAgICAgICAgbGV0IGN4O1xuICAgICAgICAgICAgICAgIGxldCBjeTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvck1hcCA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCB2ZXJ0ZXg7XG4gICAgICAgICAgICAgICAgbGV0IHA7XG4gICAgICAgICAgICAgICAgbGV0IGNjO1xuICAgICAgICAgICAgICAgIGxldCBzYztcbiAgICAgICAgICAgICAgICBsZXQgcG9zO1xuICAgICAgICAgICAgICAgIGxldCBjb25uZWN0ZWRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IGk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDAwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JNYXBbaV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbG9yTWFwWzBdID0gaW1hZ2VEYXRhWzBdO1xuICAgICAgICAgICAgICAgIGNjID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKGN5ID0gMTsgY3kgPCBoZWlnaHQgLSAxOyBjeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwWzBdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGN4ID0gMTsgY3ggPCB3aWR0aCAtIDE7IGN4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGN5ICogd2lkdGggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gaW1hZ2VEYXRhW3Bvc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yICE9PSBiYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGMgPSBjb25uZWN0ZWRDb3VudCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvck1hcFtsY10gPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB0cmFjZXIuY29udG91clRyYWNpbmcoY3ksIGN4LCBsYywgY29sb3IsIFJhc3Rlcml6ZXIuRElSLk9VVFNJREVfRURHRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVydGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gbGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IFJhc3Rlcml6ZXIuY3JlYXRlQ29udG91cjJEKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNXX0RJUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluZGV4ID0gbGFiZWxpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmZpcnN0VmVydGV4ID0gdmVydGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAubmV4dHBlZXIgPSBjYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmluc2lkZUNvbnRvdXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MucHJldnBlZXIgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYyA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSB0cmFjZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29udG91clRyYWNpbmcoY3ksIGN4LCBSYXN0ZXJpemVyLkRJUi5JTlNJREVfRURHRSwgY29sb3IsIGxhYmVsaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBSYXN0ZXJpemVyLmNyZWF0ZUNvbnRvdXIyRCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZmlyc3RWZXJ0ZXggPSB2ZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbnNpZGVDb250b3VycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRobGFiZWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNDV19ESVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5kaXIgPSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNXX0RJUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbmRleCA9IGRlcHRobGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MgPSBjYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKHNjICE9PSBudWxsKSAmJiBzYy5pbmRleCAhPT0gbGFiZWxpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYyA9IHNjLm5leHRwZWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5uZXh0cGVlciA9IHNjLmluc2lkZUNvbnRvdXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2MuaW5zaWRlQ29udG91cnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjLmluc2lkZUNvbnRvdXJzLnByZXZwZWVyID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYy5pbnNpZGVDb250b3VycyA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhW3Bvc10gPSBsYWJlbGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLk9VVFNJREVfRURHRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBsYWJlbERhdGFbcG9zXSA9PT0gUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLklOU0lERV9FREdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gaW1hZ2VEYXRhW3Bvc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSBsYWJlbERhdGFbcG9zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwW2xhYmVsaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNjID0gY2M7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjLmluZGV4ID0gZGVwdGhsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgc2MgPSBzYy5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY2MsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBjb25uZWN0ZWRDb3VudCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgICAgICAgZHJhd0NvbnRvdXIoY2FudmFzLCBmaXJzdENvbnRvdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcSA9IGZpcnN0Q29udG91cjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlxO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHA7XG5cbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAncmVkJztcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcSA9IHBxLmluc2lkZUNvbnRvdXJzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gaXE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBpcS5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHBxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBxID0gcHEubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gcHEuaW5zaWRlQ29udG91cnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChxLmRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ0NXX0RJUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuVU5LTk9XTl9ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcS5maXJzdFZlcnRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChwICE9PSBxLmZpcnN0VmVydGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBSYXN0ZXJpemVyO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbi8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuXG4vKiBAcHJlc2VydmUgQVNNIEJFR0lOICovXG5mdW5jdGlvbiBTa2VsZXRvbml6ZXIoc3RkbGliLCBmb3JlaWduLCBidWZmZXIpIHtcbiAgICAndXNlIGFzbSc7XG5cbiAgICBjb25zdCBpbWFnZXMgPSBuZXcgc3RkbGliLlVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCBzaXplID0gZm9yZWlnbi5zaXplIHwgMDtcbiAgICBjb25zdCB7IGltdWwgfSA9IHN0ZGxpYi5NYXRoO1xuXG4gICAgZnVuY3Rpb24gZXJvZGUoaW5JbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgaW5JbWFnZVB0ciB8PSAwO1xuICAgICAgICBvdXRJbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCB2ID0gMDtcbiAgICAgICAgbGV0IHUgPSAwO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IHlTdGFydDEgPSAwO1xuICAgICAgICBsZXQgeVN0YXJ0MiA9IDA7XG4gICAgICAgIGxldCB4U3RhcnQxID0gMDtcbiAgICAgICAgbGV0IHhTdGFydDIgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKHYgPSAxOyAodiB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdiA9ICh2ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgZm9yICh1ID0gMTsgKHUgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHUgPSAodSArIDEpIHwgMCkge1xuICAgICAgICAgICAgICAgIHlTdGFydDEgPSAob2Zmc2V0IC0gc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHlTdGFydDIgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDEgPSAodSAtIDEpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQyID0gKHUgKyAxKSB8IDA7XG4gICAgICAgICAgICAgICAgc3VtID0gKChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQyKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDIpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICAgICAgICAgIGlmICgoc3VtIHwgMCkgPT0gKDUgfCAwKSkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGFJbWFnZVB0ciwgYkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xuICAgICAgICBhSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgYkltYWdlUHRyIHw9IDA7XG4gICAgICAgIG91dEltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID0gKChpbWFnZXNbKGFJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApIC0gKGltYWdlc1soYkltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpdHdpc2VPcihhSW1hZ2VQdHIsIGJJbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgYUltYWdlUHRyIHw9IDA7XG4gICAgICAgIGJJbWFnZVB0ciB8PSAwO1xuICAgICAgICBvdXRJbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9ICgoaW1hZ2VzWyhhSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSB8IChpbWFnZXNbKGJJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb3VudE5vblplcm8oaW1hZ2VQdHIpIHtcbiAgICAgICAgaW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBzdW0gPSAoKHN1bSB8IDApICsgKGltYWdlc1soaW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChzdW0gfCAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0KGltYWdlUHRyLCB2YWx1ZSkge1xuICAgICAgICBpbWFnZVB0ciB8PSAwO1xuICAgICAgICB2YWx1ZSB8PSAwO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlsYXRlKGluSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGluSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgb3V0SW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgdiA9IDA7XG4gICAgICAgIGxldCB1ID0gMDtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCB5U3RhcnQxID0gMDtcbiAgICAgICAgbGV0IHlTdGFydDIgPSAwO1xuICAgICAgICBsZXQgeFN0YXJ0MSA9IDA7XG4gICAgICAgIGxldCB4U3RhcnQyID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICh2ID0gMTsgKHYgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHYgPSAodiArIDEpIHwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgIGZvciAodSA9IDE7ICh1IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB1ID0gKHUgKyAxKSB8IDApIHtcbiAgICAgICAgICAgICAgICB5U3RhcnQxID0gKG9mZnNldCAtIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB5U3RhcnQyID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQxID0gKHUgLSAxKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MiA9ICh1ICsgMSkgfCAwO1xuICAgICAgICAgICAgICAgIHN1bSA9ICgoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MikgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQyKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoKHN1bSB8IDApID4gKDAgfCAwKSkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lbWNweShzcmNJbWFnZVB0ciwgZHN0SW1hZ2VQdHIpIHtcbiAgICAgICAgc3JjSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgZHN0SW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1soZHN0SW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSAoaW1hZ2VzWyhzcmNJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0JvcmRlcihpbWFnZVB0cikge1xuICAgICAgICBpbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCB4ID0gMDtcbiAgICAgICAgbGV0IHkgPSAwO1xuXG4gICAgICAgIGZvciAoeCA9IDA7ICh4IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB4ID0gKHggKyAxKSB8IDApIHtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB4KSB8IDBdID0gMDtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB5KSB8IDBdID0gMDtcbiAgICAgICAgICAgIHkgPSAoKHkgKyBzaXplKSAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB5KSB8IDBdID0gMDtcbiAgICAgICAgICAgIHkgPSAoeSArIDEpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHggPSAwOyAoeCB8IDApIDwgKHNpemUgfCAwKTsgeCA9ICh4ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XG4gICAgICAgICAgICB5ID0gKHkgKyAxKSB8IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBza2VsZXRvbml6ZSgpIHtcbiAgICAgICAgY29uc3Qgc3ViSW1hZ2VQdHIgPSAwO1xuICAgICAgICBsZXQgZXJvZGVkSW1hZ2VQdHIgPSAwO1xuICAgICAgICBsZXQgdGVtcEltYWdlUHRyID0gMDtcbiAgICAgICAgbGV0IHNrZWxJbWFnZVB0ciA9IDA7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgZG9uZSA9IDA7XG5cbiAgICAgICAgZXJvZGVkSW1hZ2VQdHIgPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcbiAgICAgICAgdGVtcEltYWdlUHRyID0gKGVyb2RlZEltYWdlUHRyICsgZXJvZGVkSW1hZ2VQdHIpIHwgMDtcbiAgICAgICAgc2tlbEltYWdlUHRyID0gKHRlbXBJbWFnZVB0ciArIGVyb2RlZEltYWdlUHRyKSB8IDA7XG5cbiAgICAgICAgLy8gaW5pdCBza2VsLWltYWdlXG4gICAgICAgIGluaXQoc2tlbEltYWdlUHRyLCAwKTtcbiAgICAgICAgemVyb0JvcmRlcihzdWJJbWFnZVB0cik7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZXJvZGUoc3ViSW1hZ2VQdHIsIGVyb2RlZEltYWdlUHRyKTtcbiAgICAgICAgICAgIGRpbGF0ZShlcm9kZWRJbWFnZVB0ciwgdGVtcEltYWdlUHRyKTtcbiAgICAgICAgICAgIHN1YnRyYWN0KHN1YkltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIsIHRlbXBJbWFnZVB0cik7XG4gICAgICAgICAgICBiaXR3aXNlT3Ioc2tlbEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIsIHNrZWxJbWFnZVB0cik7XG4gICAgICAgICAgICBtZW1jcHkoZXJvZGVkSW1hZ2VQdHIsIHN1YkltYWdlUHRyKTtcbiAgICAgICAgICAgIHN1bSA9IGNvdW50Tm9uWmVybyhzdWJJbWFnZVB0cikgfCAwO1xuICAgICAgICAgICAgZG9uZSA9ICgoc3VtIHwgMCkgPT0gMCB8IDApO1xuICAgICAgICB9IHdoaWxlICghZG9uZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNrZWxldG9uaXplLFxuICAgIH07XG59XG4vKiBAcHJlc2VydmUgQVNNIEVORCAqL1xuZXhwb3J0IGRlZmF1bHQgU2tlbGV0b25pemVyO1xuLyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGJhc2VNZXJnZURlZXAgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2VEZWVwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZUpzRGF0YTtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCJ2YXIgY3JlYXRlQmFzZUZvciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VGb3InKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3I7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuIiwidmFyIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5JyksXG4gICAgc2FmZUdldCA9IHJlcXVpcmUoJy4vX3NhZmVHZXQnKSxcbiAgICB0b1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi90b1BsYWluT2JqZWN0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICBpZiAoc3RhY2tlZCkge1xuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpbml0Q2xvbmVPYmplY3Qoc3JjVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChpc0NvbW1vbikge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgfVxuICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlRGVlcDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVUeXBlZEFycmF5O1xuIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZU9iamVjdDtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcbiIsIi8qXG4gKiB0eXBlZGVmcy5qc1xuICogTm9ybWFsaXplcyBicm93c2VyLXNwZWNpZmljIHByZWZpeGVzIGFuZCBwcm92aWRlIHNvbWUgYmFzaWMgcG9seWZpbGxzXG4gKi9cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgfHwgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCBmdW5jdGlvbiAoLyogZnVuY3Rpb24gRnJhbWVSZXF1ZXN0Q2FsbGJhY2sgKi8gY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfSgpKTtcbiAgICB9XG59XG5cbmlmICh0eXBlb2YgTWF0aC5pbXVsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgIE1hdGguaW11bCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGNvbnN0IGFoID0gKGEgPj4+IDE2KSAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYWwgPSBhICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBiaCA9IChiID4+PiAxNikgJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGJsID0gYiAmIDB4ZmZmZjtcbiAgICAgICAgLy8gdGhlIHNoaWZ0IGJ5IDAgZml4ZXMgdGhlIHNpZ24gb24gdGhlIGhpZ2ggcGFydFxuICAgICAgICAvLyB0aGUgZmluYWwgfDAgY29udmVydHMgdGhlIHVuc2lnbmVkIHZhbHVlIGludG8gYSBzaWduZWQgdmFsdWVcbiAgICAgICAgcmV0dXJuICgoYWwgKiBibCkgKyAoKChhaCAqIGJsICsgYWwgKiBiaCkgPDwgMTYpID4+PiAwKSB8IDApO1xuICAgIH07XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1iaXR3aXNlICovXG59XG5cbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbiAodGFyZ2V0KSB7IC8vIC5sZW5ndGggb2YgZnVuY3Rpb24gaXMgMlxuXG4ndXNlIHN0cmljdCc7XG5cbiAgICAgICAgaWYgKHRhcmdldCA9PT0gbnVsbCkgeyAvLyBUeXBlRXJyb3IgaWYgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG8gPSBPYmplY3QodGFyZ2V0KTtcblxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgICAgICAgY29uc3QgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG5cbiAgICAgICAgICAgIGlmIChuZXh0U291cmNlICE9PSBudWxsKSB7IC8vIFNraXAgb3ZlciBpZiB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmV4dEtleSBpbiBuZXh0U291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIGJ1Z3Mgd2hlbiBoYXNPd25Qcm9wZXJ0eSBpcyBzaGFkb3dlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHRTb3VyY2UsIG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH07XG59XG4iLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aEhvbGVzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIm1vZHVsZS5leHBvcnRzID0gY2xvbmVcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKVxuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVZhbHVlc1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5KSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMilcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHlcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc2V0XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBzZXQob3V0LCB4LCB5KSB7XG4gICAgb3V0WzBdID0geFxuICAgIG91dFsxXSA9IHlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBlcXVhbHNcblxudmFyIEVQU0lMT04gPSByZXF1aXJlKCcuL2Vwc2lsb24nKVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF1cbiAgdmFyIGExID0gYVsxXVxuICB2YXIgYjAgPSBiWzBdXG4gIHZhciBiMSA9IGJbMV1cbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4YWN0RXF1YWxzXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBleGFjdGx5IGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFkZFxuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3N1YnRyYWN0JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tdWx0aXBseScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGl2aWRlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gaW52ZXJzZVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF1cbiAgb3V0WzFdID0gMS4wIC8gYVsxXVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IG1pblxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBtYXhcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKVxuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlXG5cbi8qKlxuICogUm90YXRlcyBhIHZlYzIgYnkgYW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgdGhlIGFuZ2xlIG9mIHJvdGF0aW9uIChpbiByYWRpYW5zKVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCBhbmdsZSkge1xuICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgIHMgPSBNYXRoLnNpbihhbmdsZSlcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV1cblxuICBvdXRbMF0gPSB4ICogYyAtIHkgKiBzXG4gIG91dFsxXSA9IHggKiBzICsgeSAqIGNcblxuICByZXR1cm4gb3V0XG59XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gZmxvb3JcblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pXG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjZWlsXG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pXG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdW5kXG5cbi8qKlxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKVxuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGVcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJcbiAgICBvdXRbMV0gPSBhWzFdICogYlxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlQW5kQWRkXG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSlcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcXVhcmVkRGlzdGFuY2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xlbmd0aCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3F1YXJlZExlbmd0aCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IG5lZ2F0ZVxuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXVxuICAgIG91dFsxXSA9IC1hWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbm9ybWFsaXplXG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIHZhciBsZW4gPSB4KnggKyB5KnlcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbilcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlblxuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuXG4gICAgfVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRvdFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXVxufSIsIm1vZHVsZS5leHBvcnRzID0gY3Jvc3NcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICAgIHZhciB6ID0gYVswXSAqIGJbMV0gLSBhWzFdICogYlswXVxuICAgIG91dFswXSA9IG91dFsxXSA9IDBcbiAgICBvdXRbMl0gPSB6XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbGVycFxuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXVxuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpXG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByYW5kb21cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wXG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMi4wICogTWF0aC5QSVxuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogc2NhbGVcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0MlxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDIob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHlcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0MmRcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDJkKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHkgKyBtWzVdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0M1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDNcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0NFxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDRcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXG4gKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hcblxudmFyIHZlYyA9IHJlcXVpcmUoJy4vY3JlYXRlJykoKVxuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgdmFyIGksIGxcbiAgICBpZighc3RyaWRlKSB7XG4gICAgICAgIHN0cmlkZSA9IDJcbiAgICB9XG5cbiAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IDBcbiAgICB9XG4gICAgXG4gICAgaWYoY291bnQpIHtcbiAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGwgPSBhLmxlbmd0aFxuICAgIH1cblxuICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgdmVjWzBdID0gYVtpXVxuICAgICAgICB2ZWNbMV0gPSBhW2krMV1cbiAgICAgICAgZm4odmVjLCB2ZWMsIGFyZylcbiAgICAgICAgYVtpXSA9IHZlY1swXVxuICAgICAgICBhW2krMV0gPSB2ZWNbMV1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGFcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxpbWl0O1xuXG4vKipcbiAqIExpbWl0IHRoZSBtYWduaXR1ZGUgb2YgdGhpcyB2ZWN0b3IgdG8gdGhlIHZhbHVlIHVzZWQgZm9yIHRoZSBgbWF4YFxuICogcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSAge3ZlYzJ9IHRoZSB2ZWN0b3IgdG8gbGltaXRcbiAqIEBwYXJhbSAge051bWJlcn0gbWF4IHRoZSBtYXhpbXVtIG1hZ25pdHVkZSBmb3IgdGhlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBsaW1pdChvdXQsIGEsIG1heCkge1xuICB2YXIgbVNxID0gYVswXSAqIGFbMF0gKyBhWzFdICogYVsxXTtcblxuICBpZiAobVNxID4gbWF4ICogbWF4KSB7XG4gICAgdmFyIG4gPSBNYXRoLnNxcnQobVNxKTtcbiAgICBvdXRbMF0gPSBhWzBdIC8gbiAqIG1heDtcbiAgICBvdXRbMV0gPSBhWzFdIC8gbiAqIG1heDtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgb3V0WzJdID0gYVsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGFuZ2xlXG5cbnZhciBmcm9tVmFsdWVzID0gcmVxdWlyZSgnLi9mcm9tVmFsdWVzJylcbnZhciBub3JtYWxpemUgPSByZXF1aXJlKCcuL25vcm1hbGl6ZScpXG52YXIgZG90ID0gcmVxdWlyZSgnLi9kb3QnKVxuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5mdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gICAgdmFyIHRlbXBBID0gZnJvbVZhbHVlcyhhWzBdLCBhWzFdLCBhWzJdKVxuICAgIHZhciB0ZW1wQiA9IGZyb21WYWx1ZXMoYlswXSwgYlsxXSwgYlsyXSlcbiBcbiAgICBub3JtYWxpemUodGVtcEEsIHRlbXBBKVxuICAgIG5vcm1hbGl6ZSh0ZW1wQiwgdGVtcEIpXG4gXG4gICAgdmFyIGNvc2luZSA9IGRvdCh0ZW1wQSwgdGVtcEIpXG5cbiAgICBpZihjb3NpbmUgPiAxLjApe1xuICAgICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKVxuICAgIH0gICAgIFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjb3B5O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICBvdXRbMl0gPSBhWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc2V0O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHopIHtcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIG91dFsyXSA9IHpcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBlcXVhbHNcblxudmFyIEVQU0lMT04gPSByZXF1aXJlKCcuL2Vwc2lsb24nKVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF1cbiAgdmFyIGExID0gYVsxXVxuICB2YXIgYTIgPSBhWzJdXG4gIHZhciBiMCA9IGJbMF1cbiAgdmFyIGIxID0gYlsxXVxuICB2YXIgYjIgPSBiWzJdXG4gIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleGFjdEVxdWFsc1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFkZDtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXVxuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3N1YnRyYWN0JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tdWx0aXBseScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGl2aWRlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gbWluO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSlcbiAgICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG1heDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKVxuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pXG4gICAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmbG9vclxuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKVxuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY2VpbFxuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKVxuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSlcbiAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm91bmRcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pXG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSlcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlO1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlxuICAgIG91dFsxXSA9IGFbMV0gKiBiXG4gICAgb3V0WzJdID0gYVsyXSAqIGJcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZUFuZEFkZDtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKVxuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKVxuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdGFuY2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NxdWFyZWREaXN0YW5jZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gbmVnYXRlO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXVxuICAgIG91dFsxXSA9IC1hWzFdXG4gICAgb3V0WzJdID0gLWFbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnNlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF1cbiAgb3V0WzFdID0gMS4wIC8gYVsxXVxuICBvdXRbMl0gPSAxLjAgLyBhWzJdXG4gIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGNyb3NzO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdXG5cbiAgICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieVxuICAgIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6XG4gICAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYnhcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBsZXJwO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdXG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheClcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KVxuICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmFuZG9tO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjBcblxuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDIuMCAqIE1hdGguUElcbiAgICB2YXIgeiA9IChNYXRoLnJhbmRvbSgpICogMi4wKSAtIDEuMFxuICAgIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wLXoqeikgKiBzY2FsZVxuXG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGVcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZVxuICAgIG91dFsyXSA9IHogKiBzY2FsZVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDQ7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdXG4gICAgdyA9IHcgfHwgMS4wXG4gICAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHdcbiAgICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gd1xuICAgIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gd1xuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDM7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXVxuICAgIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XVxuICAgIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XVxuICAgIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybVF1YXQ7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gICAgLy8gYmVuY2htYXJrczogaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnNcblxuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeVxuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXpcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWDtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIGMpe1xuICAgIHZhciBieSA9IGJbMV1cbiAgICB2YXIgYnogPSBiWzJdXG5cbiAgICAvLyBUcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgIHZhciBweSA9IGFbMV0gLSBieVxuICAgIHZhciBweiA9IGFbMl0gLSBielxuXG4gICAgdmFyIHNjID0gTWF0aC5zaW4oYylcbiAgICB2YXIgY2MgPSBNYXRoLmNvcyhjKVxuXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYnkgKyBweSAqIGNjIC0gcHogKiBzY1xuICAgIG91dFsyXSA9IGJ6ICsgcHkgKiBzYyArIHB6ICogY2NcblxuICAgIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIGIsIGMpe1xuICAgIHZhciBieCA9IGJbMF1cbiAgICB2YXIgYnogPSBiWzJdXG5cbiAgICAvLyB0cmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgIHZhciBweCA9IGFbMF0gLSBieFxuICAgIHZhciBweiA9IGFbMl0gLSBielxuICAgIFxuICAgIHZhciBzYyA9IE1hdGguc2luKGMpXG4gICAgdmFyIGNjID0gTWF0aC5jb3MoYylcbiAgXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBieCArIHB6ICogc2MgKyBweCAqIGNjXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIG91dFsyXSA9IGJ6ICsgcHogKiBjYyAtIHB4ICogc2NcbiAgXG4gICAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVaO1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgYiwgYyl7XG4gICAgdmFyIGJ4ID0gYlswXVxuICAgIHZhciBieSA9IGJbMV1cblxuICAgIC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgICB2YXIgcHggPSBhWzBdIC0gYnhcbiAgICB2YXIgcHkgPSBhWzFdIC0gYnlcbiAgXG4gICAgdmFyIHNjID0gTWF0aC5zaW4oYylcbiAgICB2YXIgY2MgPSBNYXRoLmNvcyhjKVxuXG4gICAgLy8gcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cbiAgICBvdXRbMF0gPSBieCArIHB4ICogY2MgLSBweSAqIHNjXG4gICAgb3V0WzFdID0gYnkgKyBweCAqIHNjICsgcHkgKiBjY1xuICAgIG91dFsyXSA9IGFbMl1cbiAgXG4gICAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuXG52YXIgdmVjID0gcmVxdWlyZSgnLi9jcmVhdGUnKSgpXG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzNzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzMuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMzcyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGxcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gM1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoXG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldIFxuICAgICAgICAgICAgdmVjWzFdID0gYVtpKzFdIFxuICAgICAgICAgICAgdmVjWzJdID0gYVtpKzJdXG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKVxuICAgICAgICAgICAgYVtpXSA9IHZlY1swXSBcbiAgICAgICAgICAgIGFbaSsxXSA9IHZlY1sxXSBcbiAgICAgICAgICAgIGFbaSsyXSA9IHZlY1syXVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYVxufSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iLCJ2YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9nZXRQcm90b3R5cGVPZi5qc1wiKTtcblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zdXBlclByb3BCYXNlLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCIpO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBiYXNlUGlja0J5ID0gcmVxdWlyZSgnLi9fYmFzZVBpY2tCeScpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2s7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKSxcbiAgICBiYXNlU2V0ID0gcmVxdWlyZSgnLi9fYmFzZVNldCcpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2tCeTtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG4iLCJ2YXIgbWVtb2l6ZUNhcHBlZCA9IHJlcXVpcmUoJy4vX21lbW9pemVDYXBwZWQnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fCBrZXkgPT09ICdjb25zdHJ1Y3RvcicgfHwga2V5ID09PSAncHJvdG90eXBlJykge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgfVxuICAgIH1cbiAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldDtcbiIsInZhciBiYXNlSGFzSW4gPSByZXF1aXJlKCcuL19iYXNlSGFzSW4nKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcbiIsInZhciBmbGF0dGVuID0gcmVxdWlyZSgnLi9mbGF0dGVuJyksXG4gICAgb3ZlclJlc3QgPSByZXF1aXJlKCcuL19vdmVyUmVzdCcpLFxuICAgIHNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fc2V0VG9TdHJpbmcnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXRSZXN0O1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKTtcblxuLyoqXG4gKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbjtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gcmVxdWlyZSgnLi9faXNGbGF0dGVuYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZsYXR0ZW5hYmxlO1xuIiwiZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXNOYXRpdmVGdW5jdGlvbiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuXG52YXIgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcmVxdWlyZShcIi4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzXCIpO1xuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3QsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9jb25zdHJ1Y3QgPSBmdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgIHZhciBhID0gW251bGxdO1xuICAgICAgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpO1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gRnVuY3Rpb24uYmluZC5hcHBseShQYXJlbnQsIGEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICBpZiAoQ2xhc3MpIHNldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgfVxuXG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJtb2R1bGUuZXhwb3J0cyA9IGRldGVybWluYW50XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuZGV0ZXJtaW5hbnRcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHJldHVybiBhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zcG9zZVxuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLnRyYW5zcG9zZVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMSA9IGFbMV1cbiAgICBvdXRbMV0gPSBhWzJdXG4gICAgb3V0WzJdID0gYTFcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYVsyXVxuICAgIG91dFsyXSA9IGFbMV1cbiAgICBvdXRbM10gPSBhWzNdXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IG11bHRpcGx5XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MidzXG4gKlxuICogQGFsaWFzIG1hdDIubXVsdGlwbHlcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM11cbiAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXVxuICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMVxuICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMVxuICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiM1xuICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiM1xuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5XG5cbi8qKlxuICogU2V0IGEgbWF0MiB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQGFsaWFzIG1hdDIuaWRlbnRpdHlcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxXG4gIG91dFsxXSA9IDBcbiAgb3V0WzJdID0gMFxuICBvdXRbM10gPSAxXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYWRqb2ludFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmFkam9pbnRcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gYWRqb2ludChvdXQsIGEpIHtcbiAgLy8gQ2FjaGluZyB0aGlzIHZhbHVlIGlzIG5lc3NlY2FyeSBpZiBvdXQgPT0gYVxuICB2YXIgYTAgPSAgYVswXVxuICBvdXRbMF0gPSAgYVszXVxuICBvdXRbMV0gPSAtYVsxXVxuICBvdXRbMl0gPSAtYVsyXVxuICBvdXRbM10gPSAgYTBcblxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVxuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQyIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBhbGlhcyBtYXQyLnJvdGF0ZVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM11cbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpXG4gIHZhciBjID0gTWF0aC5jb3MocmFkKVxuICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzXG4gIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHNcbiAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogY1xuICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaW52ZXJ0XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5pbnZlcnRcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYTAgPSBhWzBdXG4gIHZhciBhMSA9IGFbMV1cbiAgdmFyIGEyID0gYVsyXVxuICB2YXIgYTMgPSBhWzNdXG4gIHZhciBkZXQgPSBhMCAqIGEzIC0gYTIgKiBhMVxuXG4gIGlmICghZGV0KSByZXR1cm4gbnVsbFxuICBkZXQgPSAxLjAgLyBkZXRcblxuICBvdXRbMF0gPSAgYTMgKiBkZXRcbiAgb3V0WzFdID0gLWExICogZGV0XG4gIG91dFsyXSA9IC1hMiAqIGRldFxuICBvdXRbM10gPSAgYTAgKiBkZXRcblxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmNyZWF0ZVxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSg0KVxuICBvdXRbMF0gPSAxXG4gIG91dFsxXSA9IDBcbiAgb3V0WzJdID0gMFxuICBvdXRbM10gPSAxXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGVcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5zY2FsZVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqKi9cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdXG4gIHZhciB2MCA9IHZbMF0sIHYxID0gdlsxXVxuICBvdXRbMF0gPSBhMCAqIHYwXG4gIG91dFsxXSA9IGExICogdjBcbiAgb3V0WzJdID0gYTIgKiB2MVxuICBvdXRbM10gPSBhMyAqIHYxXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY29weVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyIHRvIGFub3RoZXJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5jb3B5XG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF1cbiAgb3V0WzFdID0gYVsxXVxuICBvdXRbMl0gPSBhWzJdXG4gIG91dFszXSA9IGFbM11cbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmcm9iXG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5mcm9iXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbmZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgIE1hdGgucG93KGFbMF0sIDIpICtcbiAgICBNYXRoLnBvdyhhWzFdLCAyKSArXG4gICAgTWF0aC5wb3coYVsyXSwgMikgK1xuICAgIE1hdGgucG93KGFbM10sIDIpXG4gIClcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gbGR1XG5cbi8qKlxuICogUmV0dXJucyBMLCBEIGFuZCBVIG1hdHJpY2VzIChMb3dlciB0cmlhbmd1bGFyLCBEaWFnb25hbCBhbmQgVXBwZXIgdHJpYW5ndWxhcikgYnkgZmFjdG9yaXppbmcgdGhlIGlucHV0IG1hdHJpeFxuICpcbiAqIEBhbGlhcyBtYXQyLmxkdVxuICogQHBhcmFtIHttYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBEIHRoZSBkaWFnb25hbCBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gVSB0aGUgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxuICovXG5mdW5jdGlvbiBsZHUoTCwgRCwgVSwgYSkge1xuICBMWzJdID0gYVsyXS9hWzBdXG4gIFVbMF0gPSBhWzBdXG4gIFVbMV0gPSBhWzFdXG4gIFVbM10gPSBhWzNdIC0gTFsyXSAqIFVbMV1cbiAgcmV0dXJuIFtMLCBELCBVXVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tY3ljbGVcbmltcG9ydCB7IEltYWdlV3JhcHBlciB9IGZyb20gJ3F1YWdnYSc7XG5pbXBvcnQgeyBRdWFnZ2FKU1Jlc3VsdE9iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcblxuLy8gZm9yIHNvbWUgcmVhc29uIHRoaXMgdGhyb3dzIGEgc2hhZG93IGVycm9yIG9uIGl0c2VsZj8hXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG5leHBvcnQgZW51bSBCYXJjb2RlRGlyZWN0aW9uIHtcbiAgICBGb3J3YXJkID0gMSxcbiAgICBSZXZlcnNlID0gLTFcbn1cblxuZXhwb3J0IHR5cGUgQmFyY29kZVJlYWRlclR5cGUgPSBzdHJpbmc7XG5leHBvcnQgdHlwZSBCYXJjb2RlRm9ybWF0ID0gc3RyaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVSZWFkZXJDb25maWcge1xuICAgIG5vcm1hbGl6ZUJhclNwYWNlV2lkdGg/OiBib29sZWFuLFxuICAgIHN1cHBsZW1lbnRzPzogQXJyYXk8QmFyY29kZVJlYWRlclR5cGU+LFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVDb3JyZWN0aW9uIHtcbiAgICBiYXI6IG51bWJlcixcbiAgICBzcGFjZTogbnVtYmVyLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVQb3NpdGlvbiB7XG4gICAgZW5kOiBudW1iZXIsXG4gICAgZW5kQ291bnRlcj86IG51bWJlcixcbiAgICBlcnJvcj86IG51bWJlcixcbiAgICBzdGFydDogbnVtYmVyLFxuICAgIHN0YXJ0Q291bnRlcj86IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVJbmZvIGV4dGVuZHMgQmFyY29kZVBvc2l0aW9uIHtcbiAgICBjb2RlOiBudW1iZXIsXG4gICAgY29ycmVjdGlvbj86IEJhcmNvZGVDb3JyZWN0aW9uLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGUge1xuICAgIGNvZGU6IHN0cmluZyxcbiAgICBjb2Rlc2V0PzogbnVtYmVyLFxuICAgIGNvcnJlY3Rpb24/OiBCYXJjb2RlQ29ycmVjdGlvbixcbiAgICBkZWNvZGVkQ29kZXM/OiBBcnJheTxzdHJpbmcgfCBCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbj4sXG4gICAgZGlyZWN0aW9uPzogQmFyY29kZURpcmVjdGlvbixcbiAgICBlbmQ6IG51bWJlcixcbiAgICBlbmRJbmZvPzogQmFyY29kZVBvc2l0aW9uLFxuICAgIGZvcm1hdDogQmFyY29kZUZvcm1hdCxcbiAgICBzdGFydDogbnVtYmVyLFxuICAgIHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uLFxuICAgIHN1cHBsZW1lbnQ/OiBCYXJjb2RlLFxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFyY29kZVJlYWRlciB7XG4gICAgX3JvdzogQXJyYXk8bnVtYmVyPiA9IFtdO1xuXG4gICAgY29uZmlnOiBCYXJjb2RlUmVhZGVyQ29uZmlnID0ge307XG5cbiAgICBzdXBwbGVtZW50czogQXJyYXk8QmFyY29kZVJlYWRlcj4gPSBbXTtcblxuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMDtcblxuICAgIEZPUk1BVDogQmFyY29kZUZvcm1hdCA9ICd1bmtub3duJztcblxuICAgIENPTkZJR19LRVlTOiBCYXJjb2RlUmVhZGVyQ29uZmlnID0ge307XG4gICAgLy8gVE9ETzogc2hvdWxkIGFkZCBBTFBIQUJFVEhfU1RSSU5HLCBBTFBIQUJFVCwgQ0hBUkFDVEVSX0VOQ09ESU5HUyB0byBiYXNlIGNsYXNzLCBpZiB0aGV5XG4gICAgLy8gYXJlIHVzZWZ1bCBpbiBtb3N0IHJlYWRlcnMuXG5cbiAgICBwdWJsaWMgYWJzdHJhY3QgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGw7XG5cbiAgICBzdGF0aWMgZ2V0IEV4Y2VwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFN0YXJ0Tm90Rm91bmRFeGNlcHRpb246ICdTdGFydC1JbmZvIHdhcyBub3QgZm91bmQhJyxcbiAgICAgICAgICAgIENvZGVOb3RGb3VuZEV4Y2VwdGlvbjogJ0NvZGUgY291bGQgbm90IGJlIGZvdW5kIScsXG4gICAgICAgICAgICBQYXR0ZXJuTm90Rm91bmRFeGNlcHRpb246ICdQYXR0ZXJuIGNvdWxkIG5vdCBiZSBmb3VuZCEnLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZzogQmFyY29kZVJlYWRlckNvbmZpZywgc3VwcGxlbWVudHM/OiBBcnJheTxCYXJjb2RlUmVhZGVyPikge1xuICAgICAgICB0aGlzLl9yb3cgPSBbXTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgIGlmIChzdXBwbGVtZW50cykge1xuICAgICAgICAgICAgdGhpcy5zdXBwbGVtZW50cyA9IHN1cHBsZW1lbnRzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9uZXh0VW5zZXQobGluZTogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBzdGFydCA9IDApOiBudW1iZXIge1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWxpbmVbaV0pIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lLmxlbmd0aDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX21hdGNoUGF0dGVybihjb3VudGVyOiBSZWFkb25seUFycmF5PG51bWJlcj4sIGNvZGU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgbWF4U2luZ2xlRXJyb3IgPSB0aGlzLlNJTkdMRV9DT0RFX0VSUk9SIHx8IDEpOiBudW1iZXIge1xuICAgICAgICBsZXQgZXJyb3IgPSAwO1xuICAgICAgICBsZXQgc2luZ2xlRXJyb3IgPSAwO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IG1vZHVsbyA9IDA7XG4gICAgICAgIGxldCBiYXJXaWR0aCA9IDA7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGxldCBzY2FsZWQgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGNvdW50ZXJbaV07XG4gICAgICAgICAgICBtb2R1bG8gKz0gY29kZVtpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VtIDwgbW9kdWxvKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJhcldpZHRoID0gc3VtIC8gbW9kdWxvO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgbWF4U2luZ2xlRXJyb3IgKj0gYmFyV2lkdGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY291bnQgPSBjb3VudGVyW2ldO1xuICAgICAgICAgICAgc2NhbGVkID0gY29kZVtpXSAqIGJhcldpZHRoO1xuICAgICAgICAgICAgc2luZ2xlRXJyb3IgPSBNYXRoLmFicyhjb3VudCAtIHNjYWxlZCkgLyBzY2FsZWQ7XG4gICAgICAgICAgICBpZiAoc2luZ2xlRXJyb3IgPiBtYXhTaW5nbGVFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IgKz0gc2luZ2xlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yIC8gbW9kdWxvO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfbmV4dFNldChsaW5lOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldCA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5lW2ldKSByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9jb3JyZWN0QmFycyhjb3VudGVyOiBBcnJheTxudW1iZXI+LCBjb3JyZWN0aW9uOiBudW1iZXIsIGluZGljZXM6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgbGV0IHsgbGVuZ3RoIH0gPSBpbmRpY2VzO1xuICAgICAgICBsZXQgdG1wID0gMDtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICB0bXAgPSBjb3VudGVyW2luZGljZXNbbGVuZ3RoXV0gKiAoMSAtICgoMSAtIGNvcnJlY3Rpb24pIC8gMikpO1xuICAgICAgICAgICAgaWYgKHRtcCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBjb3VudGVyW2luZGljZXNbbGVuZ3RoXV0gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZGVjb2RlUGF0dGVybihwYXR0ZXJuOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVQYXR0ZXJuJywgcGF0dGVybik7XG4gICAgICAgIHRoaXMuX3JvdyA9IHBhdHRlcm47XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVQYXR0ZXJuIGNhbGxpbmcgZGVjb2RlJywgdHlwZW9mIHRoaXMsIHRoaXMuY29uc3RydWN0b3IsIHRoaXMuRk9STUFULCBKU09OLnN0cmluZ2lmeSh0aGlzKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmRlY29kZSgpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmlyc3QgcmVzdWx0PScsIHJlc3VsdCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmRlY29kZSgpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldmVyc2VkIHJlc3VsdD0nLCByZXN1bHQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kaXJlY3Rpb24gPSBCYXJjb2RlRGlyZWN0aW9uLlJldmVyc2U7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gdGhpcy5fcm93Lmxlbmd0aCAtIHJlc3VsdC5zdGFydDtcbiAgICAgICAgICAgICAgICByZXN1bHQuZW5kID0gdGhpcy5fcm93Lmxlbmd0aCAtIHJlc3VsdC5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZGlyZWN0aW9uID0gQmFyY29kZURpcmVjdGlvbi5Gb3J3YXJkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5mb3JtYXQgPSB0aGlzLkZPUk1BVDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nJywgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX21hdGNoUmFuZ2Uoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgPCAwID8gMCA6IHN0YXJ0O1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maWxsQ291bnRlcnMob2Zmc2V0OiBudW1iZXIgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93KSwgZW5kOiBudW1iZXIgPSB0aGlzLl9yb3cubGVuZ3RoLCBpc1doaXRlID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBjb3VudGVyczogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50ZXJzO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdG9Db3VudGVycyhzdGFydDogbnVtYmVyLCBjb3VudGVyczogVWludDE2QXJyYXkgfCBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9yb3cubGVuZ3RoO1xuICAgICAgICBsZXQgaXNXaGl0ZSA9ICF0aGlzLl9yb3dbc3RhcnRdO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG5cbiAgICAgICAgQXJyYXlIZWxwZXIuaW5pdChjb3VudGVycywgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBudW1Db3VudGVycykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudGVycztcbiAgICB9XG5cbiAgICAvLyBvdmVycmlkZS9pbXBsZW1lbnQgdGhpcyBpbiB5b3VyIGN1c3RvbSByZWFkZXJzLlxuICAgIHByb3RlY3RlZCBkZWNvZGVJbWFnZShpbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlcik6IFF1YWdnYUpTUmVzdWx0T2JqZWN0IHwgbnVsbCB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12b2lkXG4gICAgICAgIHZvaWQgaW1hZ2VXcmFwcGVyO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhcmNvZGVSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNvbnN0IE4gPSAxO1xuY29uc3QgVyA9IDM7XG5jb25zdCBTVEFSVF9QQVRURVJOID0gW1csIE4sIFcsIE4sIE4sIE5dO1xuY29uc3QgU1RPUF9QQVRURVJOID0gW1csIE4sIE4sIE4sIFddO1xuY29uc3QgQ09ERV9QQVRURVJOID0gW1xuICAgIFtOLCBOLCBXLCBXLCBOXSxcbiAgICBbVywgTiwgTiwgTiwgV10sXG4gICAgW04sIFcsIE4sIE4sIFddLFxuICAgIFtXLCBXLCBOLCBOLCBOXSxcbiAgICBbTiwgTiwgVywgTiwgV10sXG4gICAgW1csIE4sIFcsIE4sIE5dLFxuICAgIFtOLCBXLCBXLCBOLCBOXSxcbiAgICBbTiwgTiwgTiwgVywgV10sXG4gICAgW1csIE4sIE4sIFcsIE5dLFxuICAgIFtOLCBXLCBOLCBXLCBOXSxcbl07XG5jb25zdCBTVEFSVF9QQVRURVJOX0xFTkdUSCA9IFNUQVJUX1BBVFRFUk4ucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsLCAwKTtcblxuY2xhc3MgVHdvT2ZGaXZlUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgYmFyU3BhY2VSYXRpbyA9IFsxLCAxXTtcblxuICAgIEZPUk1BVCA9ICcyb2Y1JztcblxuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC43ODtcblxuICAgIEFWR19DT0RFX0VSUk9SID0gMC4zMDtcblxuICAgIHByb3RlY3RlZCBfZmluZFBhdHRlcm4ocGF0dGVybjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQ6IG51bWJlciwgaXNXaGl0ZSA9IGZhbHNlLCB0cnlIYXJkZXIgPSBmYWxzZSk6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBbXTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgZXJyb3IgPSAwO1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcblxuICAgICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyW2ldID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSBjb3VudGVyW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgbGV0IHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBuYXJyb3dCYXJXaWR0aCA9IDE7XG4gICAgICAgIGxldCBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID0gMDtcblxuICAgICAgICB3aGlsZSAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFycm93QmFyV2lkdGggPSBNYXRoLmZsb29yKChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KSAvIFNUQVJUX1BBVFRFUk5fTEVOR1RIKTtcbiAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSBuYXJyb3dCYXJXaWR0aCAqIDU7XG4gICAgICAgICAgICBpZiAobGVhZGluZ1doaXRlc3BhY2VTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XG4gICAgICAgICAgICBzdGFydEluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZUluZm8pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kRW5kKCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICAvLyBUT0RPOiByZXZlcnNlLCBmb2xsb3dlZCBieSBzb21lIGNhbGNzLCBmb2xsb3dlZCBieSBhbm90aGVyIHJldmVyc2U/IHJlYWxseT9cbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oU1RPUF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcblxuICAgICAgICBpZiAoZW5kSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXZlcnNlIG51bWJlcnNcbiAgICAgICAgY29uc3QgdG1wID0gZW5kSW5mby5zdGFydDtcbiAgICAgICAgZW5kSW5mby5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSBlbmRJbmZvLmVuZDtcbiAgICAgICAgZW5kSW5mby5lbmQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gdG1wO1xuXG4gICAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnM6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgcmV0dXJuIChjb3VudGVycy5sZW5ndGggJSAxMCA9PT0gMCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVDb2RlKGNvdW50ZXI6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSB0aGlzLkFWR19DT0RFX0VSUk9SO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCBDT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIENPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IhKSB7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IhIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoY291bnRlcnM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgcmVzdWx0OiBBcnJheTxzdHJpbmc+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uPik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBjb25zdCBjb3VudGVyTGVuZ3RoID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAocG9zIDwgY291bnRlckxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2ldID0gY291bnRlcnNbcG9zXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1swXTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvdW50ZXIpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChgJHtjb2RlLmNvZGV9YCk7XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG5cblxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZEVuZCgpO1xuICAgICAgICBpZiAoIWVuZEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY291bnRlcnMgPSB0aGlzLl9maWxsQ291bnRlcnMoc3RhcnRJbmZvLmVuZCwgZW5kSW5mby5zdGFydCwgZmFsc2UpO1xuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goc3RhcnRJbmZvKTtcblxuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2RlY29kZVBheWxvYWQoY291bnRlcnMsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA8IDUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goZW5kSW5mbyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmRJbmZvLmVuZCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUd29PZkZpdmVSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlLCBCYXJjb2RlUG9zaXRpb24gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuLy8gY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5LSQ6Ly4rQUJDRCc7XG5jb25zdCBBTFBIQUJFVCA9IFs0OCwgNDksIDUwLCA1MSwgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNDUsIDM2LCA1OCwgNDcsIDQ2LCA0MywgNjUsIDY2LCA2NywgNjhdO1xuY29uc3QgQ0hBUkFDVEVSX0VOQ09ESU5HUyA9XG4gICAgWzB4MDAzLCAweDAwNiwgMHgwMDksIDB4MDYwLCAweDAxMiwgMHgwNDIsIDB4MDIxLCAweDAyNCwgMHgwMzAsIDB4MDQ4LCAweDAwYywgMHgwMTgsXG4gICAgICAgIDB4MDQ1LCAweDA1MSwgMHgwNTQsIDB4MDE1LCAweDAxQSwgMHgwMjksIDB4MDBCLCAweDAwRV07XG5jb25zdCBTVEFSVF9FTkQgPSBbMHgwMUEsIDB4MDI5LCAweDAwQiwgMHgwMEVdO1xuY29uc3QgTUlOX0VOQ09ERURfQ0hBUlMgPSA0O1xuY29uc3QgTUFYX0FDQ0VQVEFCTEUgPSAyLjA7XG5jb25zdCBQQURESU5HID0gMS41O1xuXG5pbnRlcmZhY2UgVGhyZXNob2xkU2l6ZSB7XG4gICAgc2l6ZTogbnVtYmVyLFxuICAgIGNvdW50czogbnVtYmVyLFxuICAgIG1pbjogbnVtYmVyLFxuICAgIG1heDogbnVtYmVyLFxufTtcblxuaW50ZXJmYWNlIFRocmVzaG9sZCB7XG4gICAgc3BhY2U6IHtcbiAgICAgICAgbmFycm93OiBUaHJlc2hvbGRTaXplLFxuICAgICAgICB3aWRlOiBUaHJlc2hvbGRTaXplLFxuICAgIH0sXG4gICAgYmFyOiB7XG4gICAgICAgIG5hcnJvdzogVGhyZXNob2xkU2l6ZSxcbiAgICAgICAgd2lkZTogVGhyZXNob2xkU2l6ZSxcbiAgICB9LFxufTtcblxuY2xhc3MgTmV3Q29kYWJhclJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIF9jb3VudGVyczogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICAgIEZPUk1BVCA9ICdjb2RhYmFyJztcblxuICAgIHByb3RlY3RlZCBfY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkKG9mZnNldDogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xuICAgICAgICBsZXQgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgIGxldCBjb3VudGVyID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgZW5kOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyc1tpXTtcbiAgICAgICAgICAgIGlmIChjb3VudGVyID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gY291bnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudGVyIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgbWluID0gY291bnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoKG1pbiArIG1heCkgLyAyLjApIHwgMDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF90b1BhdHRlcm4ob2Zmc2V0OiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSA3O1xuICAgICAgICBjb25zdCBlbmQgPSBvZmZzZXQgKyBudW1Db3VudGVycztcblxuICAgICAgICBpZiAoZW5kID4gdGhpcy5fY291bnRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiYXJUaHJlc2hvbGQgPSB0aGlzLl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0LCBlbmQpO1xuICAgICAgICBjb25zdCBzcGFjZVRocmVzaG9sZCA9IHRoaXMuX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZChvZmZzZXQgKyAxLCBlbmQpO1xuXG4gICAgICAgIGxldCBiaXRtYXNrID0gMSA8PCAobnVtQ291bnRlcnMgLSAxKTtcbiAgICAgICAgbGV0IHRocmVzaG9sZCA9IDA7XG4gICAgICAgIGxldCBwYXR0ZXJuID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IChpICYgMSkgPT09IDAgPyBiYXJUaHJlc2hvbGQgOiBzcGFjZVRocmVzaG9sZDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb3VudGVyc1tvZmZzZXQgKyBpXSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gfD0gYml0bWFzaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJpdG1hc2sgPj49IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9pc1N0YXJ0RW5kKHBhdHRlcm46IG51bWJlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFNUQVJUX0VORC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKFNUQVJUX0VORFtpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9zdW1Db3VudGVycyhzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xuICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IHRoaXMuX2NvdW50ZXJzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5fY291bnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4oaSk7XG4gICAgICAgICAgICBpZiAocGF0dGVybiAhPT0gLTEgJiYgdGhpcy5faXNTdGFydEVuZChwYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IExvb2sgZm9yIHdoaXRlc3BhY2UgYWhlYWRcbiAgICAgICAgICAgICAgICBzdGFydCArPSB0aGlzLl9zdW1Db3VudGVycygwLCBpKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBzdGFydCArIHRoaXMuX3N1bUNvdW50ZXJzKGksIGkgKyA4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgICAgICBzdGFydENvdW50ZXI6IGksXG4gICAgICAgICAgICAgICAgICAgIGVuZENvdW50ZXI6IGkgKyA4LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9wYXR0ZXJuVG9DaGFyKHBhdHRlcm46IG51bWJlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQUxQSEFCRVRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgob2Zmc2V0OiBudW1iZXIpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IG9mZnNldCArIDc7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IHRoaXMuX2NvdW50ZXJzW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlXaGl0ZXNwYWNlKHN0YXJ0Q291bnRlcjogbnVtYmVyLCBlbmRDb3VudGVyOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKChzdGFydENvdW50ZXIgLSAxIDw9IDApXG4gICAgICAgICAgICB8fCB0aGlzLl9jb3VudGVyc1tzdGFydENvdW50ZXIgLSAxXSA+PSAodGhpcy5fY2FsY3VsYXRlUGF0dGVybkxlbmd0aChzdGFydENvdW50ZXIpIC8gMi4wKSkge1xuICAgICAgICAgICAgaWYgKChlbmRDb3VudGVyICsgOCA+PSB0aGlzLl9jb3VudGVycy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fY291bnRlcnNbZW5kQ291bnRlciArIDddID49ICh0aGlzLl9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoKGVuZENvdW50ZXIpIC8gMi4wKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9jaGFyVG9QYXR0ZXJuKGNoYXI6IHN0cmluZykge1xuICAgICAgICBjb25zdCBjaGFyQ29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoQUxQSEFCRVRbaV0gPT09IGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENIQVJBQ1RFUl9FTkNPRElOR1NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDB4MDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuKHJlc3VsdDogUmVhZG9ubHlBcnJheTxzdHJpbmc+LCBzdGFydENvdW50ZXI6IG51bWJlcikge1xuICAgICAgICBjb25zdCBjYXRlZ29yaXphdGlvbjogVGhyZXNob2xkID0ge1xuICAgICAgICAgICAgICAgIHNwYWNlOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hcnJvdzogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXG4gICAgICAgICAgICAgICAgICAgIHdpZGU6IHsgc2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmFyOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hcnJvdzogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXG4gICAgICAgICAgICAgICAgICAgIHdpZGU6IHsgc2l6ZTogMCwgY291bnRzOiAwLCBtaW46IDAsIG1heDogTnVtYmVyLk1BWF9WQUxVRSB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICBsZXQgcG9zID0gc3RhcnRDb3VudGVyO1xuICAgICAgICBsZXQgcGF0dGVybjogbnVtYmVyO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gdGhpcy5fY2hhclRvUGF0dGVybihyZXN1bHRbaV0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDY7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2luZCA9IChqICYgMSkgPT09IDIgPyBjYXRlZ29yaXphdGlvbi5iYXIgOiBjYXRlZ29yaXphdGlvbi5zcGFjZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXQgPSAocGF0dGVybiAmIDEpID09PSAxID8ga2luZC53aWRlIDoga2luZC5uYXJyb3c7XG4gICAgICAgICAgICAgICAgY2F0LnNpemUgKz0gdGhpcy5fY291bnRlcnNbcG9zICsgal07XG4gICAgICAgICAgICAgICAgY2F0LmNvdW50cysrO1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPj49IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gODtcbiAgICAgICAgfVxuXG4gICAgICAgIChbJ3NwYWNlJywgJ2JhciddIGFzIGNvbnN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld2tpbmQgPSBjYXRlZ29yaXphdGlvbltrZXldO1xuICAgICAgICAgICAgbmV3a2luZC53aWRlLm1pbiA9XG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcigobmV3a2luZC5uYXJyb3cuc2l6ZSAvIG5ld2tpbmQubmFycm93LmNvdW50cyArIG5ld2tpbmQud2lkZS5zaXplIC8gbmV3a2luZC53aWRlLmNvdW50cykgLyAyKTtcbiAgICAgICAgICAgIG5ld2tpbmQubmFycm93Lm1heCA9IE1hdGguY2VpbChuZXdraW5kLndpZGUubWluKTtcbiAgICAgICAgICAgIG5ld2tpbmQud2lkZS5tYXggPSBNYXRoLmNlaWwoKG5ld2tpbmQud2lkZS5zaXplICogTUFYX0FDQ0VQVEFCTEUgKyBQQURESU5HKSAvIG5ld2tpbmQud2lkZS5jb3VudHMpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2F0ZWdvcml6YXRpb247XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdmFsaWRhdGVSZXN1bHQocmVzdWx0OiBSZWFkb25seUFycmF5PHN0cmluZz4sIHN0YXJ0Q291bnRlcjogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHRocmVzaG9sZHMgPSB0aGlzLl90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuKHJlc3VsdCwgc3RhcnRDb3VudGVyKTtcbiAgICAgICAgbGV0IHBvcyA9IHN0YXJ0Q291bnRlcjtcbiAgICAgICAgbGV0IHBhdHRlcm46IG51bWJlcjtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuX2NoYXJUb1BhdHRlcm4ocmVzdWx0W2ldKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSA2OyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtpbmQgPSAoaiAmIDEpID09PSAwID8gdGhyZXNob2xkcy5iYXIgOiB0aHJlc2hvbGRzLnNwYWNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhdCA9IChwYXR0ZXJuICYgMSkgPT09IDEgPyBraW5kLndpZGUgOiBraW5kLm5hcnJvdztcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5fY291bnRlcnNbcG9zICsgal07XG4gICAgICAgICAgICAgICAgaWYgKHNpemUgPCBjYXQubWluIHx8IHNpemUgPiBjYXQubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0dGVybiA+Pj0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyIHwgbnVsbCk6IEJhcmNvZGUgfCBudWxsIHtcblxuICAgICAgICB0aGlzLl9jb3VudGVycyA9IHRoaXMuX2ZpbGxDb3VudGVycygpO1xuICAgICAgICBzdGFydCA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlcjtcblxuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgbGV0IHBhdHRlcm46IG51bWJlcjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuX3RvUGF0dGVybihuZXh0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkQ2hhciA9IHRoaXMuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZENoYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgIG5leHRTdGFydCArPSA4O1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAxICYmIHRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobmV4dFN0YXJ0IDwgdGhpcy5fY291bnRlcnMubGVuZ3RoKTtcblxuICAgICAgICAvLyB2ZXJpZnkgZW5kXG4gICAgICAgIGlmICgocmVzdWx0Lmxlbmd0aCAtIDIpIDwgTUlOX0VOQ09ERURfQ0hBUlMgfHwgIXRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmVyaWZ5IGVuZCB3aGl0ZSBzcGFjZVxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeVdoaXRlc3BhY2Uoc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlciwgbmV4dFN0YXJ0IC0gOCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92YWxpZGF0ZVJlc3VsdChyZXN1bHQsIHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRTdGFydCA9IG5leHRTdGFydCA+IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCA/IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCA6IG5leHRTdGFydDtcbiAgICAgICAgY29uc3QgZW5kID0gc3RhcnQuc3RhcnQgKyB0aGlzLl9zdW1Db3VudGVycyhzdGFydC5zdGFydENvdW50ZXIgYXMgbnVtYmVyLCBuZXh0U3RhcnQgLSA4KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULCAvLyBUT0RPOiBpIHRoaW5rIGl0IHNob3VsZCBub3QgYmUgcmVxdWlyZWQgdG8gcmV0dXJuIGZvcm1hdCBmcm9tIHRoaXMsIGFzIGJhcmNvZGVfcmVhZGVyIGZvcmNlIHNldHMgdGhlIGZvcm1hdCBhbnl3YXlcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBOZXdDb2RhYmFyUmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZUNvcnJlY3Rpb24sIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY2xhc3MgQ29kZTEyOFJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIENPREVfU0hJRlQgPSA5ODtcbiAgICBDT0RFX0MgPSA5OTtcbiAgICBDT0RFX0IgPSAxMDA7XG4gICAgQ09ERV9BID0gMTAxO1xuICAgIFNUQVJUX0NPREVfQSA9IDEwMztcbiAgICBTVEFSVF9DT0RFX0IgPSAxMDQ7XG4gICAgU1RBUlRfQ09ERV9DID0gMTA1O1xuICAgIFNUT1BfQ09ERSA9IDEwNjtcbiAgICBDT0RFX1BBVFRFUk4gPSBbXG4gICAgICAgICAgICBbMiwgMSwgMiwgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMiwgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMiwgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMiwgMiwgM10sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMywgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMywgMSwgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMiwgMSwgM10sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMywgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMywgMiwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMiwgMSwgM10sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMywgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMywgMSwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMiwgMywgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMSwgMywgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMiwgMywgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMywgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMywgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMywgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMywgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMSwgMywgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMiwgMywgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMywgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMiwgMywgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMywgMSwgMiwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMywgMSwgMSwgMiwgMiwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMSwgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMSwgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMywgMSwgMiwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMiwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMywgMiwgMiwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMiwgMSwgMiwgM10sXG4gICAgICAgICAgICBbMiwgMSwgMiwgMywgMiwgMV0sXG4gICAgICAgICAgICBbMiwgMywgMiwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMywgMiwgM10sXG4gICAgICAgICAgICBbMSwgMywgMSwgMSwgMiwgM10sXG4gICAgICAgICAgICBbMSwgMywgMSwgMywgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMywgMSwgM10sXG4gICAgICAgICAgICBbMSwgMywgMiwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMSwgMywgMiwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMywgMSwgM10sXG4gICAgICAgICAgICBbMiwgMywgMSwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMiwgMywgMSwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMSwgMywgM10sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMywgMywgMV0sXG4gICAgICAgICAgICBbMSwgMywgMiwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMywgMSwgMiwgM10sXG4gICAgICAgICAgICBbMSwgMSwgMywgMywgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMywgMywgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMywgMSwgMywgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMywgMywgMV0sXG4gICAgICAgICAgICBbMiwgMywgMSwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMywgMSwgMSwgM10sXG4gICAgICAgICAgICBbMiwgMSwgMywgMywgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMywgMSwgMywgMV0sXG4gICAgICAgICAgICBbMywgMSwgMSwgMSwgMiwgM10sXG4gICAgICAgICAgICBbMywgMSwgMSwgMywgMiwgMV0sXG4gICAgICAgICAgICBbMywgMywgMSwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMywgMSwgMiwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMywgMSwgMiwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMywgMywgMiwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMywgMSwgNCwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgNCwgMSwgMV0sXG4gICAgICAgICAgICBbNCwgMywgMSwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMiwgMiwgNF0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgNCwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMSwgMiwgNF0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgNCwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgNCwgMSwgMSwgMiwgMl0sXG4gICAgICAgICAgICBbMSwgNCwgMSwgMiwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgMiwgMSwgNF0sXG4gICAgICAgICAgICBbMSwgMSwgMiwgNCwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgMSwgMSwgNF0sXG4gICAgICAgICAgICBbMSwgMiwgMiwgNCwgMSwgMV0sXG4gICAgICAgICAgICBbMSwgNCwgMiwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgNCwgMiwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgNCwgMSwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMiwgMSwgMSwgMSwgNF0sXG4gICAgICAgICAgICBbNCwgMSwgMywgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgNCwgMSwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMywgNCwgMSwgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMiwgNCwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMSwgNCwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgMSwgMiwgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgNCwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbMSwgMiwgNCwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMiwgMSwgMl0sXG4gICAgICAgICAgICBbNCwgMiwgMSwgMSwgMSwgMl0sXG4gICAgICAgICAgICBbNCwgMiwgMSwgMiwgMSwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMiwgMSwgNCwgMV0sXG4gICAgICAgICAgICBbMiwgMSwgNCwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMiwgMSwgMiwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMSwgNCwgM10sXG4gICAgICAgICAgICBbMSwgMSwgMSwgMywgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMywgMSwgMSwgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMSwgMSwgM10sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMywgMSwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMSwgMSwgM10sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMywgMSwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgMywgMSwgNCwgMV0sXG4gICAgICAgICAgICBbMSwgMSwgNCwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMywgMSwgMSwgMSwgNCwgMV0sXG4gICAgICAgICAgICBbNCwgMSwgMSwgMSwgMywgMV0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgNCwgMSwgMl0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMiwgMSwgNF0sXG4gICAgICAgICAgICBbMiwgMSwgMSwgMiwgMywgMl0sXG4gICAgICAgICAgICBbMiwgMywgMywgMSwgMSwgMSwgMl0sXG4gICAgICAgIF07XG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjY0O1xuICAgIEFWR19DT0RFX0VSUk9SID0gMC4zMDtcbiAgICBGT1JNQVQgPSAnY29kZV8xMjgnO1xuICAgIE1PRFVMRV9JTkRJQ0VTID0geyBiYXI6IFswLCAyLCA0XSwgc3BhY2U6IFsxLCAzLCA1XSB9O1xuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVDb2RlKHN0YXJ0OiBudW1iZXIsIGNvcnJlY3Rpb24/OiBCYXJjb2RlQ29ycmVjdGlvbik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0LFxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIGJhcjogMSxcbiAgICAgICAgICAgICAgICBzcGFjZTogMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSAhdGhpcy5fcm93W29mZnNldF07XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvcnJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvcnJlY3QoY291bnRlciwgY29ycmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCB0aGlzLkNPREVfUEFUVEVSTi5sZW5ndGg7IGNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgdGhpcy5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdE1hdGNoLmNvZGUgPT09IC0xIHx8IGJlc3RNYXRjaC5lcnJvciA+IHRoaXMuQVZHX0NPREVfRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLmJhciA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uc3BhY2UgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfY29ycmVjdChjb3VudGVyOiBBcnJheTxudW1iZXI+LCBjb3JyZWN0aW9uOiBCYXJjb2RlQ29ycmVjdGlvbikge1xuICAgICAgICB0aGlzLl9jb3JyZWN0QmFycyhjb3VudGVyLCBjb3JyZWN0aW9uLmJhciwgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICB0aGlzLl9jb3JyZWN0QmFycyhjb3VudGVyLCBjb3JyZWN0aW9uLnNwYWNlLCB0aGlzLk1PRFVMRV9JTkRJQ0VTLnNwYWNlKTtcbiAgICB9O1xuXG4gICAgLy8gVE9ETzogX2ZpbmRTdGFydCBhbmQgZGVjb2RlQ29kZSBzaGFyZSBzaW1pbGFyIGNvZGUsIGNhbiB3ZSByZS11c2Ugc29tZT9cbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBjb25zdCBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IHtcbiAgICAgICAgICAgICAgICBiYXI6IDEsXG4gICAgICAgICAgICAgICAgc3BhY2U6IDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1bSA9IGNvdW50ZXIucmVkdWNlKChwcmV2LCBuZXh0KSA9PiBwcmV2ICsgbmV4dCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgPSB0aGlzLlNUQVJUX0NPREVfQTsgY29kZSA8PSB0aGlzLlNUQVJUX0NPREVfQzsgY29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCB0aGlzLkNPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciA8IHRoaXMuQVZHX0NPREVfRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLmJhciA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uc3BhY2UgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls0XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbNV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoc3RhcnRJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIC8vICAgICBkb25lID0gZmFsc2UsXG4gICAgICAgIC8vICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgLy8gICAgIG11bHRpcGxpZXIgPSAwLFxuICAgICAgICAvLyAgICAgY2hlY2tzdW0gPSAwLFxuICAgICAgICAvLyAgICAgY29kZXNldCxcbiAgICAgICAgLy8gICAgIHJhd1Jlc3VsdCA9IFtdLFxuICAgICAgICAvLyAgICAgZGVjb2RlZENvZGVzID0gW10sXG4gICAgICAgIC8vICAgICBzaGlmdE5leHQgPSBmYWxzZSxcbiAgICAgICAgLy8gICAgIHVuc2hpZnQsXG4gICAgICAgIC8vICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcblxuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0ge1xuICAgICAgICAgICAgY29kZTogc3RhcnRJbmZvLmNvZGUsXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydEluZm8uZW5kLFxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIGJhcjogc3RhcnRJbmZvLmNvcnJlY3Rpb24hLmJhcixcbiAgICAgICAgICAgICAgICBzcGFjZTogc3RhcnRJbmZvLmNvcnJlY3Rpb24hLnNwYWNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICBsZXQgY2hlY2tzdW0gPSBjb2RlLmNvZGU7XG4gICAgICAgIGxldCBjb2Rlc2V0ID0gKChjOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVEFSVF9DT0RFX0E6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RBUlRfQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUQVJUX0NPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ09ERV9DO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KShjb2RlLmNvZGUpO1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICBsZXQgc2hpZnROZXh0ID0gZmFsc2U7XG4gICAgICAgIGxldCB1bnNoaWZ0ID0gc2hpZnROZXh0O1xuICAgICAgICBsZXQgcmVtb3ZlTGFzdENoYXJhY3RlciA9IHRydWU7XG4gICAgICAgIGxldCBtdWx0aXBsaWVyID0gMDtcbiAgICAgICAgbGV0IHJhd1Jlc3VsdDogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICAgICAgICBsZXQgcmVzdWx0OiBBcnJheTxzdHJpbmcgfCBudW1iZXI+ID0gW107IC8vIFRPRE86IGkgdGhpbmsgdGhpcyBzaG91bGQgYmUgc3RyaW5nIG9ubHksIGJ1dCBpdCBjcmVhdGVzIHByb2JsZW1zIGlmIGl0IGlzXG5cbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICB1bnNoaWZ0ID0gc2hpZnROZXh0O1xuICAgICAgICAgICAgc2hpZnROZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlIS5lbmQsIGNvZGUhLmNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKGNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICByYXdSZXN1bHQucHVzaChjb2RlLmNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyKys7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrc3VtICs9IG11bHRpcGxpZXIgKiBjb2RlLmNvZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb2Rlc2V0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsgY29kZS5jb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZS5jb2RlIDwgOTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZS5jb2RlIC0gNjQpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0TmV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVE9QX0NPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDk2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsgY29kZS5jb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfU0hJRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0TmV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVE9QX0NPREU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlIDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgPCAxMCA/ICcwJyArIGNvZGUuY29kZSA6IGNvZGUuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSB0aGlzLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuc2hpZnQpIHtcbiAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gY29kZXNldCA9PT0gdGhpcy5DT0RFX0EgPyB0aGlzLkNPREVfQiA6IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZS5lbmQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGNvZGUpKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hlY2tzdW0gLT0gbXVsdGlwbGllciAqIHJhd1Jlc3VsdFtyYXdSZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChjaGVja3N1bSAlIDEwMyAhPT0gcmF3UmVzdWx0W3Jhd1Jlc3VsdC5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGxhc3QgY29kZSBmcm9tIHJlc3VsdCAoY2hlY2tzdW0pXG4gICAgICAgIGlmIChyZW1vdmVMYXN0Q2hhcmFjdGVyKSB7XG4gICAgICAgICAgICByZXN1bHQuc3BsaWNlKHJlc3VsdC5sZW5ndGggLSAxLCAxKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGNvZGUuZW5kLFxuICAgICAgICAgICAgY29kZXNldDogY29kZXNldCBhcyBudW1iZXIsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgZW5kSW5mbzogY29kZSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVJbmZvKTogQmFyY29kZUluZm8gfCBudWxsIHtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQ7XG5cbiAgICAgICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHNlbGYuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuXG4gICAgcHVibGljIGNhbGN1bGF0ZUNvcnJlY3Rpb24oZXhwZWN0ZWQ6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgbm9ybWFsaXplZDogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBpbmRpY2VzOiBSZWFkb25seUFycmF5PG51bWJlcj4pOiBudW1iZXIge1xuICAgICAgICB2YXIgbGVuZ3RoID0gaW5kaWNlcy5sZW5ndGgsXG4gICAgICAgICAgICBzdW1Ob3JtYWxpemVkID0gMCxcbiAgICAgICAgICAgIHN1bUV4cGVjdGVkID0gMDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHN1bUV4cGVjdGVkICs9IGV4cGVjdGVkW2luZGljZXNbbGVuZ3RoXV07XG4gICAgICAgICAgICBzdW1Ob3JtYWxpemVkICs9IG5vcm1hbGl6ZWRbaW5kaWNlc1tsZW5ndGhdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtRXhwZWN0ZWQgLyBzdW1Ob3JtYWxpemVkO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTEyOFJlYWRlcjtcbiIsIi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcbmltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IHR5cGUgQmFyY29kZVBvc2l0aW9uLCB0eXBlIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAqJC8rJSc7XG5jb25zdCBBTFBIQUJFVCA9IG5ldyBVaW50MTZBcnJheShbLi4uQUxQSEFCRVRIX1NUUklOR10ubWFwKChjaGFyKSA9PiBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbmNvbnN0IENIQVJBQ1RFUl9FTkNPRElOR1MgPSBuZXcgVWludDE2QXJyYXkoW1xuICAgIDB4MDM0LCAweDEyMSwgMHgwNjEsIDB4MTYwLCAweDAzMSwgMHgxMzAsIDB4MDcwLCAweDAyNSwgMHgxMjQsIDB4MDY0LCAweDEwOSwgMHgwNDksXG4gICAgMHgxNDgsIDB4MDE5LCAweDExOCwgMHgwNTgsIDB4MDBELCAweDEwQywgMHgwNEMsIDB4MDFDLCAweDEwMywgMHgwNDMsIDB4MTQyLCAweDAxMywgMHgxMTIsIDB4MDUyLCAweDAwNywgMHgxMDYsXG4gICAgMHgwNDYsIDB4MDE2LCAweDE4MSwgMHgwQzEsIDB4MUMwLCAweDA5MSwgMHgxOTAsIDB4MEQwLCAweDA4NSwgMHgxODQsIDB4MEM0LCAweDA5NCwgMHgwQTgsIDB4MEEyLCAweDA4QSwgMHgwMkEsXG5dKTtcbmNvbnN0IEFTVEVSSVNLID0gMHgwOTQ7XG5cbmNsYXNzIENvZGUzOVJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdjb2RlXzM5JztcblxuICAgIHByb3RlY3RlZCBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBzdGFydCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b1BhdHRlcm4oY291bnRlcikgPT09IEFTVEVSSVNLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aGl0ZVNwYWNlTXVzdFN0YXJ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSAoKGkgLSBwYXR0ZXJuU3RhcnQpIC8gNCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKHdoaXRlU3BhY2VNdXN0U3RhcnQsIHBhdHRlcm5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcGF0dGVyblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyWzBdICsgY291bnRlclsxXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzddID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls4XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3RvUGF0dGVybihjb3VudGVyczogVWludDE2QXJyYXkpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBudW1Db3VudGVycyA9IGNvdW50ZXJzLmxlbmd0aDtcbiAgICAgICAgbGV0IG1heE5hcnJvd1dpZHRoID0gMDtcbiAgICAgICAgbGV0IG51bVdpZGVCYXJzID0gbnVtQ291bnRlcnM7XG4gICAgICAgIGxldCB3aWRlQmFyV2lkdGggPSAwO1xuXG4gICAgICAgIHdoaWxlIChudW1XaWRlQmFycyA+IDMpIHtcbiAgICAgICAgICAgIG1heE5hcnJvd1dpZHRoID0gdGhpcy5fZmluZE5leHRXaWR0aChjb3VudGVycywgbWF4TmFycm93V2lkdGgpO1xuICAgICAgICAgICAgbnVtV2lkZUJhcnMgPSAwO1xuICAgICAgICAgICAgbGV0IHBhdHRlcm4gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldID4gbWF4TmFycm93V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiB8PSAxIDw8IChudW1Db3VudGVycyAtIDEgLSBpKTtcbiAgICAgICAgICAgICAgICAgICAgbnVtV2lkZUJhcnMrKztcbiAgICAgICAgICAgICAgICAgICAgd2lkZUJhcldpZHRoICs9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG51bVdpZGVCYXJzID09PSAzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVycyAmJiBudW1XaWRlQmFycyA+IDA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlcnNbaV0gPiBtYXhOYXJyb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtV2lkZUJhcnMtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY291bnRlcnNbaV0gKiAyKSA+PSB3aWRlQmFyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmluZE5leHRXaWR0aChjb3VudGVyczogVWludDE2QXJyYXksIGN1cnJlbnQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIGxldCBtaW5XaWR0aCA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldIDwgbWluV2lkdGggJiYgY291bnRlcnNbaV0gPiBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgbWluV2lkdGggPSBjb3VudGVyc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtaW5XaWR0aDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3BhdHRlcm5Ub0NoYXIocGF0dGVybjogbnVtYmVyKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKENIQVJBQ1RFUl9FTkNPRElOR1NbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBTFBIQUJFVFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UobGFzdFN0YXJ0OiBudW1iZXIsIG5leHRTdGFydDogbnVtYmVyLCBjb3VudGVyczogVWludDE2QXJyYXkpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgcGF0dGVyblNpemUgPSBBcnJheUhlbHBlci5zdW0oY291bnRlcnMpO1xuXG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IG5leHRTdGFydCAtIGxhc3RTdGFydCAtIHBhdHRlcm5TaXplO1xuICAgICAgICBpZiAoKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCAqIDMpID49IHBhdHRlcm5TaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljIGRlY29kZSgpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGxldCBjb3VudGVycyA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIHN0YXJ0LmVuZCk7XG5cbiAgICAgICAgbGV0IGRlY29kZWRDaGFyO1xuICAgICAgICBsZXQgbGFzdFN0YXJ0OiBudW1iZXI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvdW50ZXJzID0gdGhpcy5fdG9Db3VudGVycyhuZXh0U3RhcnQsIGNvdW50ZXJzKSBhcyBVaW50MTZBcnJheTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4oY291bnRlcnMpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ2hhciA9IHRoaXMuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZENoYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgIGxhc3RTdGFydCA9IG5leHRTdGFydDtcbiAgICAgICAgICAgIG5leHRTdGFydCArPSBBcnJheUhlbHBlci5zdW0oY291bnRlcnMpO1xuICAgICAgICAgICAgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIG5leHRTdGFydCk7XG4gICAgICAgIH0gd2hpbGUgKGRlY29kZWRDaGFyICE9PSAnKicpO1xuICAgICAgICByZXN1bHQucG9wKCk7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGxhc3RTdGFydCwgbmV4dFN0YXJ0LCBjb3VudGVycykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcbiAgICAgICAgICAgIGVuZDogbmV4dFN0YXJ0LFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydCxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGUzOVJlYWRlcjtcbiIsImltcG9ydCBDb2RlMzlSZWFkZXIgZnJvbSAnLi9jb2RlXzM5X3JlYWRlcic7XG5cbmNvbnN0IHBhdHRlcm5zID0ge1xuICAgIEFFSU86IC9bQUVJT10vZyxcbiAgICBBWjA5OiAvW0EtWjAtOV0vLFxufTtcblxuY29uc3QgY29kZTMyc2V0ID0gJzAxMjM0NTY3ODlCQ0RGR0hKS0xNTlBRUlNUVVZXWFlaJztcblxuY2xhc3MgQ29kZTMyUmVhZGVyIGV4dGVuZHMgQ29kZTM5UmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnY29kZV8zMl9yZWFkZXInO1xuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVDb2RlMzIoY29kZTogc3RyaW5nKSB7XG4gICAgICAgIGlmICgvW14wLTlCQ0RGR0hKS0xNTlBRUlNUVVZXWFlaXS8udGVzdChjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzID0gcmVzICogMzIgKyBjb2RlMzJzZXQuaW5kZXhPZihjb2RlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29kZTMyID0gYCR7cmVzfWA7XG4gICAgICAgIGlmIChjb2RlMzIubGVuZ3RoIDwgOSkge1xuICAgICAgICAgICAgY29kZTMyID0gKCcwMDAwMDAwMDAnICsgY29kZTMyKS5zbGljZSgtOSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdBJyArIGNvZGUzMjtcbiAgICB9XG5cbiAgICAvLyBUT0RPICh0aGlzIHdhcyB0b2RvIGluIG9yaWdpbmFsIHJlcG8sIG5vIHRleHQgd2FzIHRoZXJlLiBzb3JyeS4pXG4gICAgcHJvdGVjdGVkIF9jaGVja0NoZWNrc3VtKGNvZGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISFjb2RlO1xuICAgIH1cblxuICAgIHB1YmxpYyBkZWNvZGUoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmRlY29kZSgpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZSA9IHJlc3VsdC5jb2RlO1xuXG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHBhdHRlcm5zLkFFSU8sICcnKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2NoZWNrQ2hlY2tzdW0oY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29kZTMyID0gdGhpcy5fZGVjb2RlQ29kZTMyKGNvZGUpO1xuXG4gICAgICAgIGlmICghY29kZTMyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5jb2RlID0gY29kZTMyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTMyUmVhZGVyO1xuIiwiLyogZXNsaW50LWRpc2FibGUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcyAqL1xuaW1wb3J0IHsgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IENvZGUzOVJlYWRlciBmcm9tICcuL2NvZGVfMzlfcmVhZGVyJztcblxuY29uc3QgcGF0dGVybnMgPSB7XG4gICAgSU9ROiAvW0lPUV0vZyxcbiAgICBBWjA5OiAvW0EtWjAtOV17MTd9Lyxcbn07XG5cbmNsYXNzIENvZGUzOVZJTlJlYWRlciBleHRlbmRzIENvZGUzOVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2NvZGVfMzlfdmluJztcblxuICAgIC8vIFRPRE8gKHRoaXMgd2FzIHRvZG8gaW4gb3JpZ2luYWwgcmVwbywgbm8gdGV4dCB3YXMgdGhlcmUuIHNvcnJ5LilcbiAgICBwcm90ZWN0ZWQgX2NoZWNrQ2hlY2tzdW0oY29kZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIWNvZGU7XG4gICAgfVxuXG4gICAgLy8gQ3JpYmJlZCBmcm9tOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96eGluZy96eGluZy9ibG9iL21hc3Rlci9jb3JlL3NyYy9tYWluL2phdmEvY29tL2dvb2dsZS96eGluZy9jbGllbnQvcmVzdWx0L1ZJTlJlc3VsdFBhcnNlci5qYXZhXG4gICAgcHVibGljIGRlY29kZSgpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmRlY29kZSgpO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgeyBjb2RlIH0gPSByZXN1bHQ7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocGF0dGVybnMuSU9RLCAnJyk7XG5cbiAgICAgICAgaWYgKCFjb2RlLm1hdGNoKHBhdHRlcm5zLkFaMDkpKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCBBWjA5IHBhdHRlcm4gY29kZTonLCBjb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja0NoZWNrc3VtKGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5jb2RlID0gY29kZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGUzOVZJTlJlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuXG5jb25zdCBBTFBIQUJFVEhfU1RSSU5HID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWi0uICQvKyVhYmNkKic7XG5jb25zdCBBTFBIQUJFVCA9IG5ldyBVaW50MTZBcnJheShbLi4uQUxQSEFCRVRIX1NUUklOR10ubWFwKGNoYXIgPT4gY2hhci5jaGFyQ29kZUF0KDApKSk7XG5jb25zdCBDSEFSQUNURVJfRU5DT0RJTkdTID0gbmV3IFVpbnQxNkFycmF5KFtcbiAgICAweDExNCwgMHgxNDgsIDB4MTQ0LCAweDE0MiwgMHgxMjgsIDB4MTI0LCAweDEyMiwgMHgxNTAsIDB4MTEyLCAweDEwQSxcbiAgICAweDFBOCwgMHgxQTQsIDB4MUEyLCAweDE5NCwgMHgxOTIsIDB4MThBLCAweDE2OCwgMHgxNjQsIDB4MTYyLCAweDEzNCxcbiAgICAweDExQSwgMHgxNTgsIDB4MTRDLCAweDE0NiwgMHgxMkMsIDB4MTE2LCAweDFCNCwgMHgxQjIsIDB4MUFDLCAweDFBNixcbiAgICAweDE5NiwgMHgxOUEsIDB4MTZDLCAweDE2NiwgMHgxMzYsIDB4MTNBLCAweDEyRSwgMHgxRDQsIDB4MUQyLCAweDFDQSxcbiAgICAweDE2RSwgMHgxNzYsIDB4MUFFLCAweDEyNiwgMHgxREEsIDB4MUQ2LCAweDEzMiwgMHgxNUUsXG5dKTtcbmNvbnN0IEFTVEVSSVNLID0gMHgxNUU7XG5cbmNsYXNzIENvZGU5M1JlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdjb2RlXzkzJztcbiAgICBwcm90ZWN0ZWQgX3BhdHRlcm5Ub0NoYXIocGF0dGVybjogbnVtYmVyKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKENIQVJBQ1RFUl9FTkNPRElOR1NbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBTFBIQUJFVFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdG9QYXR0ZXJuKGNvdW50ZXJzOiBVaW50MTZBcnJheSk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBzdW0gPSBjb3VudGVycy5yZWR1Y2UoKHByZXYsIG5leHQpID0+IHByZXYgKyBuZXh0LCAwKTtcbiAgICAgICAgbGV0IHBhdHRlcm4gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vcm1hbGl6ZWQgPSBNYXRoLnJvdW5kKGNvdW50ZXJzW2ldICogOSAvIHN1bSk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZCA8IDEgfHwgbm9ybWFsaXplZCA+IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgJiAxKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9ybWFsaXplZDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSAocGF0dGVybiA8PCAxKSB8IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuIDw8PSBub3JtYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBzdGFydCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b1BhdHRlcm4oY291bnRlcikgPT09IEFTVEVSSVNLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aGl0ZVNwYWNlTXVzdFN0YXJ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSAoKGkgLSBwYXR0ZXJuU3RhcnQpIC8gNCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKHdoaXRlU3BhY2VNdXN0U3RhcnQsIHBhdHRlcm5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcGF0dGVyblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyWzBdICsgY291bnRlclsxXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzRdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls1XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlFbmQobGFzdFN0YXJ0OiBudW1iZXIsIG5leHRTdGFydDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChsYXN0U3RhcnQgPT09IG5leHRTdGFydCB8fCAhdGhpcy5fcm93W25leHRTdGFydF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVFeHRlbmRlZChjaGFyQXJyYXk6IEFycmF5PHN0cmluZz4pOiBzdHJpbmdbXSB8IG51bGwge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBjaGFyQXJyYXkubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGNoYXJBcnJheVtpXTtcbiAgICAgICAgICAgIGlmIChjaGFyID49ICdhJyAmJiBjaGFyIDw9ICdkJykge1xuICAgICAgICAgICAgICAgIGlmIChpID4gKGxlbmd0aCAtIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhciA9IGNoYXJBcnJheVsrK2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyQ29kZSA9IG5leHRDaGFyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgbGV0IGRlY29kZWRDaGFyO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA+PSAnQScgJiYgbmV4dENoYXIgPD0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDY0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdFJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSAzOCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdGJyAmJiBuZXh0Q2hhciA8PSAnSicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnSycgJiYgbmV4dENoYXIgPD0gJ08nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSArIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ1AnICYmIG5leHRDaGFyIDw9ICdTJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyA0Myk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdUJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdPJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSAzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID09PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9ICc6JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyAzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJyogY29kZV85M19yZWFkZXIgX2RlY29kZUV4dGVuZGVkIGhpdCBkZWZhdWx0IGNhc2UsIHRoaXMgbWF5IGJlIGFuIGVycm9yJywgZGVjb2RlZENoYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9tYXRjaENoZWNrQ2hhcihjaGFyQXJyYXk6IEFycmF5PHN0cmluZz4sIGluZGV4OiBudW1iZXIsIG1heFdlaWdodDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGFycmF5VG9DaGVjayA9IGNoYXJBcnJheS5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5VG9DaGVjay5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHdlaWdodGVkU3VtcyA9IGFycmF5VG9DaGVjay5yZWR1Y2UoKHN1bSwgY2hhciwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gKCgoaSAqIC0xKSArIChsZW5ndGggLSAxKSkgJSBtYXhXZWlnaHQpICsgMTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gQUxQSEFCRVQuaW5kZXhPZihjaGFyLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bSArICh3ZWlnaHQgKiB2YWx1ZSk7XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIGNvbnN0IGNoZWNrQ2hhciA9IEFMUEhBQkVUWyh3ZWlnaHRlZFN1bXMgJSA0NyldO1xuICAgICAgICByZXR1cm4gY2hlY2tDaGFyID09PSBjaGFyQXJyYXlbaW5kZXhdLmNoYXJDb2RlQXQoMCk7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5Q2hlY2tzdW1zKGNoYXJBcnJheTogQXJyYXk8c3RyaW5nPik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5LCBjaGFyQXJyYXkubGVuZ3RoIC0gMiwgMjApXG4gICAgICAgICAgICAmJiB0aGlzLl9tYXRjaENoZWNrQ2hhcihjaGFyQXJyYXksIGNoYXJBcnJheS5sZW5ndGggLSAxLCAxNSk7XG4gICAgfTtcblxuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIgfCBudWxsKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBzdGFydCA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb3VudGVycyA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBsZXQgcmVzdWx0OiBBcnJheTxzdHJpbmc+IHwgbnVsbCA9IFtdO1xuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIHN0YXJ0LmVuZCk7XG4gICAgICAgIGxldCBsYXN0U3RhcnQ7XG4gICAgICAgIGxldCBkZWNvZGVkQ2hhcjogc3RyaW5nIHwgbnVsbDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY291bnRlcnMgPSB0aGlzLl90b0NvdW50ZXJzKG5leHRTdGFydCwgY291bnRlcnMpIGFzIFVpbnQxNkFycmF5O1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX3RvUGF0dGVybihjb3VudGVycyk7XG4gICAgICAgICAgICBpZiAocGF0dGVybiA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDaGFyID0gdGhpcy5fcGF0dGVyblRvQ2hhcihwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChkZWNvZGVkQ2hhciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xuICAgICAgICAgICAgbGFzdFN0YXJ0ID0gbmV4dFN0YXJ0O1xuICAgICAgICAgICAgbmV4dFN0YXJ0ICs9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XG4gICAgICAgICAgICBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgbmV4dFN0YXJ0KTtcbiAgICAgICAgfSB3aGlsZSAoZGVjb2RlZENoYXIgIT09ICcqJyk7XG4gICAgICAgIHJlc3VsdC5wb3AoKTtcblxuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlFbmQobGFzdFN0YXJ0LCBuZXh0U3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q2hlY2tzdW1zKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIHJlc3VsdC5sZW5ndGggLSAyKTtcbiAgICAgICAgLy8geWVzLCB0aGlzIGlzIGFuIGFzc2lnbiBpbnNpZGUgYW4gaWYuXG4gICAgICAgIGlmICgocmVzdWx0ID0gdGhpcy5fZGVjb2RlRXh0ZW5kZWQocmVzdWx0KSkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcbiAgICAgICAgICAgIGVuZDogbmV4dFN0YXJ0LFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydCxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcblxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTkzUmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZVJlYWRlckNvbmZpZywgQmFyY29kZUluZm8sIEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC9tZXJnZSc7XG5cbi8vIGNvbnN0IENPREVfTF9TVEFSVCA9IDA7XG5jb25zdCBDT0RFX0dfU1RBUlQgPSAxMDtcbmV4cG9ydCB7IENPREVfR19TVEFSVCB9O1xuY29uc3QgU1RBUlRfUEFUVEVSTiA9IFsxLCAxLCAxXTtcbmNvbnN0IE1JRERMRV9QQVRURVJOID0gWzEsIDEsIDEsIDEsIDFdO1xuZXhwb3J0IHsgTUlERExFX1BBVFRFUk4gfTtcbmNvbnN0IEVYVEVOU0lPTl9TVEFSVF9QQVRURVJOID0gWzEsIDEsIDJdO1xuY29uc3QgQ09ERV9QQVRURVJOID0gW1xuICAgIFszLCAyLCAxLCAxXSxcbiAgICBbMiwgMiwgMiwgMV0sXG4gICAgWzIsIDEsIDIsIDJdLFxuICAgIFsxLCA0LCAxLCAxXSxcbiAgICBbMSwgMSwgMywgMl0sXG4gICAgWzEsIDIsIDMsIDFdLFxuICAgIFsxLCAxLCAxLCA0XSxcbiAgICBbMSwgMywgMSwgMl0sXG4gICAgWzEsIDIsIDEsIDNdLFxuICAgIFszLCAxLCAxLCAyXSxcbiAgICBbMSwgMSwgMiwgM10sXG4gICAgWzEsIDIsIDIsIDJdLFxuICAgIFsyLCAyLCAxLCAyXSxcbiAgICBbMSwgMSwgNCwgMV0sXG4gICAgWzIsIDMsIDEsIDFdLFxuICAgIFsxLCAzLCAyLCAxXSxcbiAgICBbNCwgMSwgMSwgMV0sXG4gICAgWzIsIDEsIDMsIDFdLFxuICAgIFszLCAxLCAyLCAxXSxcbiAgICBbMiwgMSwgMSwgM10sXG5dO1xuY29uc3QgQ09ERV9GUkVRVUVOQ1kgPSBbMCwgMTEsIDEzLCAxNCwgMTksIDI1LCAyOCwgMjEsIDIyLCAyNl07XG4vLyBjb25zdCBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNzA7XG5jb25zdCBBVkdfQ09ERV9FUlJPUiA9IDAuNDg7XG5cbmNsYXNzIEVBTlJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIEZPUk1BVCA9ICdlYW5fMTMnO1xuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMC43MDtcbiAgICBTVE9QX1BBVFRFUk4gPSBbMSwgMSwgMV07IC8vIFRPRE86IGRvZXMgdGhpcyBuZWVkIHRvIGJlIGluIHRoZSBjbGFzcz9cblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZz86IEJhcmNvZGVSZWFkZXJDb25maWcsIHN1cHBsZW1lbnRzPzogQXJyYXk8QmFyY29kZVJlYWRlcj4pIHtcbiAgICAgICAgc3VwZXIobWVyZ2UoeyBzdXBwbGVtZW50czogW10gfSwgY29uZmlnKSwgc3VwcGxlbWVudHMpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmluZFBhdHRlcm4ocGF0dGVybjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQ6IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbiwgdHJ5SGFyZGVyOiBib29sZWFuKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgQXJyYXk8bnVtYmVyPihwYXR0ZXJuLmxlbmd0aCkuZmlsbCgwKTtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoOiBCYXJjb2RlUG9zaXRpb24gPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSBBVkdfQ09ERV9FUlJPUjtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRQYXR0ZXJuJywgcGF0dGVybiwgb2Zmc2V0LCBpc1doaXRlLCB0cnlIYXJkZXIsIGVwc2lsb24pO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihgKiBsb29wIGk9JHtvZmZzZXR9IGxlbj0ke3RoaXMuX3Jvdy5sZW5ndGh9IGlzV2hpdGU9JHtpc1doaXRlfSBjb3VudGVyUG9zPSR7Y291bnRlclBvc31gKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIG1hdGNoUGF0dGVybicsIGVycm9yLCBjb3VudGVyLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgZXBzaWxvbiAmJiBiZXN0TWF0Y2guZXJyb3IgJiYgZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIGNvdW50ZXIucmVkdWNlKChzdW0sIHZhbHVlKSA9PiBzdW0gKyB2YWx1ZSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gYmVzdE1hdGNoJywgSlNPTi5zdHJpbmdpZnkoYmVzdE1hdGNoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBiZXN0TWF0Y2gnLCBKU09OLnN0cmluZ2lmeShiZXN0TWF0Y2gpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZCA/IGJlc3RNYXRjaCA6IG51bGw7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogZmluZFBhdHRlcm4gYW5kIGRlY29kZUNvZGUgYXBwZWFyIHRvIHNoYXJlIHF1aXRlIHNpbWlsYXIgY29kZSwgY2FuIGl0IGJlIHJlZHVjZWQ/XG4gICAgcHJvdGVjdGVkIF9kZWNvZGVDb2RlKHN0YXJ0OiBudW1iZXIsIGNvZGVyYW5nZT86IG51bWJlcik6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlJywgc3RhcnQsIGNvZGVyYW5nZSk7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHN0YXJ0O1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2g6IEJhcmNvZGVJbmZvID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnRcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IEFWR19DT0RFX0VSUk9SO1xuICAgICAgICBsZXQgaXNXaGl0ZSA9ICF0aGlzLl9yb3dbb2Zmc2V0XTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuXG4gICAgICAgIGlmICghY29kZXJhbmdlKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZSBiZWZvcmUgbGVuZ3RoJyk7XG4gICAgICAgICAgICBjb2RlcmFuZ2UgPSBDT0RFX1BBVFRFUk4ubGVuZ3RoO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGUgYWZ0ZXIgbGVuZ3RoJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvZGUgPSAwOyBjb2RlIDwgY29kZXJhbmdlOyBjb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIENPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvciEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlc3RNYXRjaC5lcnJvciEgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gYmVzdE1hdGNoJywgSlNPTi5zdHJpbmdpZnkoYmVzdE1hdGNoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kID8gYmVzdE1hdGNoIDogbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRTdGFydCcpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgc3RhcnRJbmZvOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogc3RhcnRJbmZvPScsIEpTT04uc3RyaW5naWZ5KHN0YXJ0SW5mbykpO1xuICAgICAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIChzdGFydEluZm8uZW5kIC0gc3RhcnRJbmZvLnN0YXJ0KTtcblxuICAgICAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZyBzdGFydEluZm8nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XG4gICAgICAgICAgICBzdGFydEluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcgbnVsbCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9jYWxjdWxhdGVGaXJzdERpZ2l0KGNvZGVGcmVxdWVuY3k6IG51bWJlcik6IG51bWJlciB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogY2FsY3VsYXRlRmlyc3REaWdpdCcsIGNvZGVGcmVxdWVuY3kpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENPREVfRlJFUVVFTkNZLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gQ09ERV9GUkVRVUVOQ1lbaV0pIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nJywgaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChpbkNvZGU6IEJhcmNvZGVQb3NpdGlvbiwgcmVzdWx0OiBBcnJheTxudW1iZXI+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlUGF5bG9hZCcsIGluQ29kZSwgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xuICAgICAgICBsZXQgb3V0Q29kZTogQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0geyAuLi5pbkNvZGUgfTtcbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAweDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIG91dENvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG91dENvZGUuZW5kKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlPScsIG91dENvZGUpO1xuICAgICAgICAgICAgaWYgKCFvdXRDb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgLT0gQ09ERV9HX1NUQVJUO1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAoNSAtIGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDAgPDwgKDUgLSBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG91dENvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlyc3REaWdpdCA9IHRoaXMuX2NhbGN1bGF0ZUZpcnN0RGlnaXQoY29kZUZyZXF1ZW5jeSk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaXJzdERpZ2l0PScsIGZpcnN0RGlnaXQpO1xuICAgICAgICBpZiAoZmlyc3REaWdpdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KGZpcnN0RGlnaXQpO1xuXG4gICAgICAgIGxldCBtaWRkbGVQYXR0ZXJuID0gdGhpcy5fZmluZFBhdHRlcm4oTUlERExFX1BBVFRFUk4sIG91dENvZGUuZW5kLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kUGF0dGVybj0nLCBKU09OLnN0cmluZ2lmeShtaWRkbGVQYXR0ZXJuKSk7XG5cbiAgICAgICAgaWYgKG1pZGRsZVBhdHRlcm4gPT09IG51bGwgfHwgIW1pZGRsZVBhdHRlcm4uZW5kKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIG51bGwnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2gobWlkZGxlUGF0dGVybik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIG1pZGRsZVBhdHRlcm4gPSB0aGlzLl9kZWNvZGVDb2RlKG1pZGRsZVBhdHRlcm4hLmVuZCwgQ09ERV9HX1NUQVJUKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlPScsIEpTT04uc3RyaW5naWZ5KG1pZGRsZVBhdHRlcm4pKTtcblxuICAgICAgICAgICAgaWYgKCFtaWRkbGVQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG1pZGRsZVBhdHRlcm4pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKG1pZGRsZVBhdHRlcm4gYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCBjb2RlPScsIEpTT04uc3RyaW5naWZ5KG1pZGRsZVBhdHRlcm4pKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGVuZCByZXN1bHQ9JywgSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgZGVjb2RlZENvZGVzPScsIGRlY29kZWRDb2Rlcyk7XG4gICAgICAgIHJldHVybiBtaWRkbGVQYXR0ZXJuIGFzIEJhcmNvZGVJbmZvO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlJywgSlNPTi5zdHJpbmdpZnkoZW5kSW5mbykpO1xuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArIChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpO1xuXG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcnLCBKU09OLnN0cmluZ2lmeShlbmRJbmZvKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfZmluZEVuZChvZmZzZXQ6IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZEVuZCcsIG9mZnNldCwgaXNXaGl0ZSk7XG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kUGF0dGVybih0aGlzLlNUT1BfUEFUVEVSTiwgb2Zmc2V0LCBpc1doaXRlLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIGVuZEluZm8gIT09IG51bGwgPyB0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykgOiBudWxsO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfY2hlY2tzdW0ocmVzdWx0OiBBcnJheTxudW1iZXI+KTogYm9vbGVhbiB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBfY2hlY2tzdW0nLCByZXN1bHQpO1xuICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gcmVzdWx0Lmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VtICo9IDM7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHJlc3VsdC5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgY2hlY2tzdW0nLCBzdW0gJSAxMCA9PT0gMCk7XG4gICAgICAgIHJldHVybiBzdW0gJSAxMCA9PT0gMDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9kZWNvZGVFeHRlbnNpb25zKG9mZnNldDogbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBvZmZzZXQpO1xuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybihFWFRFTlNJT05fU1RBUlRfUEFUVEVSTiwgc3RhcnQsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKHN0YXJ0SW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlRXh0ZW5zaW9ucycsIHRoaXMuc3VwcGxlbWVudHMpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogdGhlcmUgYXJlICcsIHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoLCAnIHN1cHBsZW1lbnRzJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdXBwbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGV4dGVuc2lvbnMgbG9vcCcsIGksIHRoaXMuc3VwcGxlbWVudHNbaV0sIHRoaXMuc3VwcGxlbWVudHNbaV0uX2RlY29kZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnN1cHBsZW1lbnRzW2ldLmRlY29kZSh0aGlzLl9yb3csIHN0YXJ0SW5mby5lbmQpO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGUgcmVzdWx0PScsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogcmVzdWx0LmNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcmVzdWx0LmVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LmRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5zdXBwbGVtZW50c1tpXS5GT1JNQVQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignKiBkZWNvZGVFeHRlbnNpb25zIGVycm9yIGluICcsIHRoaXMuc3VwcGxlbWVudHNbaV0sICc6ICcsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGRlY29kZUV4dGVuc2lvbnMnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHVibGljIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZScsIHJvdyk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGUnLCBzdGFydCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheTxudW1iZXI+KCk7XG4gICAgICAgIGNvbnN0IGRlY29kZWRDb2RlcyA9IG5ldyBBcnJheTxCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbj4oKTtcbiAgICAgICAgbGV0IHJlc3VsdEluZm86IEJhcmNvZGUgfCB7fSA9IHt9O1xuICAgICAgICBsZXQgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG5cbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVQb3NpdGlvbiB8IEJhcmNvZGVJbmZvIHwgbnVsbCA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0SW5mby5lbmRcbiAgICAgICAgfTtcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZVBheWxvYWQoY29kZSwgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xuXG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlID0gdGhpcy5fZmluZEVuZChjb2RlLmVuZCwgZmFsc2UpO1xuXG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgICAvLyBDaGVja3N1bVxuICAgICAgICBpZiAoIXRoaXMuX2NoZWNrc3VtKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHRoaXMuc3VwcGxlbWVudHM9JywgdGhpcy5zdXBwbGVtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLnN1cHBsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHN1cHBsZW1lbnQgPSB0aGlzLl9kZWNvZGVFeHRlbnNpb25zKGNvZGUuZW5kKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVFeHRlbnNpb25zIHJldHVybnMnLCBzdXBwbGVtZW50KTtcbiAgICAgICAgICAgIGlmICghc3VwcGxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXN1cHBsZW1lbnQuZGVjb2RlZENvZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGxhc3RDb2RlID0gc3VwcGxlbWVudC5kZWNvZGVkQ29kZXNbc3VwcGxlbWVudC5kZWNvZGVkQ29kZXMubGVuZ3RoIC0gMV0gYXMgQmFyY29kZUluZm87XG4gICAgICAgICAgICBjb25zdCBlbmRJbmZvID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBsYXN0Q29kZS5zdGFydCArICgoKGxhc3RDb2RlLmVuZCAtIGxhc3RDb2RlLnN0YXJ0KSAvIDIpIHwgMCksXG4gICAgICAgICAgICAgICAgZW5kOiBsYXN0Q29kZS5lbmRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdEluZm8gPSB7XG4gICAgICAgICAgICAgICAgc3VwcGxlbWVudCxcbiAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJykgKyBzdXBwbGVtZW50LmNvZGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogY29kZS5lbmQsXG4gICAgICAgICAgICBzdGFydEluZm8sXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICAuLi5yZXN1bHRJbmZvLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVBTlJlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIsIHsgQ09ERV9HX1NUQVJUIH0gZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuXG5jbGFzcyBFQU4yUmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnZWFuXzInO1xuICAgIHB1YmxpYyBkZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3JvdyA9IHJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IHN0YXJ0O1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9yb3cubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMiAmJiBvZmZzZXQgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUob2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgJSAxMCk7XG4gICAgICAgICAgICBpZiAoY29kZS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAoMSAtIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgY29kZS5lbmQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3csIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gMiB8fCAocGFyc2VJbnQocmVzdWx0LmpvaW4oJycpKSAlIDQpICE9PSBjb2RlRnJlcXVlbmN5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBlbmQ6IChjb2RlIGFzIEJhcmNvZGVJbmZvKS5lbmQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uLFxuICAgICAgICAgICAgc3RhcnQ6IChzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uKS5zdGFydCxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFQU4yUmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQgfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZSwgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jb25zdCBDSEVDS19ESUdJVF9FTkNPRElOR1MgPSBbMjQsIDIwLCAxOCwgMTcsIDEyLCA2LCAzLCAxMCwgOSwgNV07XG5cbmZ1bmN0aW9uIGRldGVybWluZUNoZWNrRGlnaXQoY29kZUZyZXF1ZW5jeTogbnVtYmVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGlmIChjb2RlRnJlcXVlbmN5ID09PSBDSEVDS19ESUdJVF9FTkNPRElOR1NbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBleHRlbnNpb25DaGVja3N1bShyZXN1bHQ6IEFycmF5PG51bWJlcj4pIHtcbiAgICBjb25zdCBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuICAgIGxldCBzdW0gPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgfVxuICAgIHN1bSAqPSAzO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgIH1cbiAgICBzdW0gKj0gMztcbiAgICByZXR1cm4gc3VtICUgMTA7XG59XG5cbmNsYXNzIEVBTjVSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIEZPUk1BVCA9ICdlYW5fNSc7XG4gICAgcHVibGljIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgdGhpcy5fcm93ID0gcm93O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX3Jvdy5sZW5ndGg7XG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IG51bGwgPSBudWxsO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1ICYmIG9mZnNldCA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSAlIDEwKTtcbiAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICg0IC0gaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSAhPT0gNCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdywgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRlbnNpb25DaGVja3N1bShyZXN1bHQpICE9PSBkZXRlcm1pbmVDaGVja0RpZ2l0KGNvZGVGcmVxdWVuY3kpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBlbmQ6IChjb2RlIGFzIEJhcmNvZGVJbmZvKS5lbmQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uLFxuICAgICAgICAgICAgc3RhcnQ6IChzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uKS5zdGFydCxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFQU41UmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQsIE1JRERMRV9QQVRURVJOIH0gZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY2xhc3MgRUFOOFJlYWRlciBleHRlbmRzIEVBTlJlYWRlciB7XG4gICAgRk9STUFUID0gJ2Vhbl84JztcbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoaW5Db2RlOiBCYXJjb2RlUG9zaXRpb24sIHJlc3VsdDogQXJyYXk8bnVtYmVyPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlUG9zaXRpb24+KTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IGluQ29kZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY29kZS5lbmQsIENPREVfR19TVEFSVCk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSA9IHRoaXMuX2ZpbmRQYXR0ZXJuKE1JRERMRV9QQVRURVJOLCBjb2RlLmVuZCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvZGUuZW5kLCBDT0RFX0dfU1RBUlQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb2RlIGFzIEJhcmNvZGVJbmZvO1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVBTjhSZWFkZXI7XG4iLCIvLyBUT0RPOiBpMm9mNV9yZWFkZXIgYW5kIDJvZjVfcmVhZGVyIHNoYXJlIHZlcnkgc2ltaWxhciBjb2RlLCBtYWtlIHVzZSBvZiB0aGF0XG5cbmltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGVSZWFkZXJDb25maWcsIEJhcmNvZGVJbmZvLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBtZXJnZSBmcm9tICdsb2Rhc2gvbWVyZ2UnO1xuXG5jb25zdCBOID0gMTtcbmNvbnN0IFcgPSAzO1xuXG5jbGFzcyBJMm9mNVJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIHByaXZhdGUgYmFyU3BhY2VSYXRpbyA9IFsxLCAxXTtcbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNzg7XG4gICAgQVZHX0NPREVfRVJST1IgPSAwLjM4O1xuXG4gICAgU1RBUlRfUEFUVEVSTiA9IFtOLCBOLCBOLCBOXTtcbiAgICBTVE9QX1BBVFRFUk4gPSBbTiwgTiwgV107XG4gICAgQ09ERV9QQVRURVJOID0gW1xuICAgICAgICBbTiwgTiwgVywgVywgTl0sXG4gICAgICAgIFtXLCBOLCBOLCBOLCBXXSxcbiAgICAgICAgW04sIFcsIE4sIE4sIFddLFxuICAgICAgICBbVywgVywgTiwgTiwgTl0sXG4gICAgICAgIFtOLCBOLCBXLCBOLCBXXSxcbiAgICAgICAgW1csIE4sIFcsIE4sIE5dLFxuICAgICAgICBbTiwgVywgVywgTiwgTl0sXG4gICAgICAgIFtOLCBOLCBOLCBXLCBXXSxcbiAgICAgICAgW1csIE4sIE4sIFcsIE5dLFxuICAgICAgICBbTiwgVywgTiwgVywgTl0sXG4gICAgXTtcbiAgICBNQVhfQ09SUkVDVElPTl9GQUNUT1IgPSA1O1xuICAgIEZPUk1BVCA9ICdpMm9mNSc7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRzOiBCYXJjb2RlUmVhZGVyQ29uZmlnKSB7XG4gICAgICAgIHN1cGVyKG1lcmdlKHsgbm9ybWFsaXplQmFyU3BhY2VXaWR0aDogZmFsc2UgfSwgb3B0cykpO1xuICAgICAgICBpZiAob3B0cy5ub3JtYWxpemVCYXJTcGFjZVdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLlNJTkdMRV9DT0RFX0VSUk9SID0gMC4zODtcbiAgICAgICAgICAgIHRoaXMuQVZHX0NPREVfRVJST1IgPSAwLjA5O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlnID0gb3B0cztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9tYXRjaFBhdHRlcm4oY291bnRlcjogQXJyYXk8bnVtYmVyPiwgY29kZTogUmVhZG9ubHlBcnJheTxudW1iZXI+KTogbnVtYmVyIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ZXJTdW0gPSBbMCwgMF07XG4gICAgICAgICAgICBjb25zdCBjb2RlU3VtID0gWzAsIDBdO1xuICAgICAgICAgICAgY29uc3QgY29ycmVjdGlvbiA9IFswLCAwXTtcbiAgICAgICAgICAgIGNvbnN0IGNvcnJlY3Rpb25SYXRpbyA9IHRoaXMuTUFYX0NPUlJFQ1RJT05fRkFDVE9SO1xuICAgICAgICAgICAgY29uc3QgY29ycmVjdGlvblJhdGlvSW52ZXJzZSA9IDEgLyBjb3JyZWN0aW9uUmF0aW87XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJTdW1baSAlIDJdICs9IGNvdW50ZXJbaV07XG4gICAgICAgICAgICAgICAgY29kZVN1bVtpICUgMl0gKz0gY29kZVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvcnJlY3Rpb25bMF0gPSBjb2RlU3VtWzBdIC8gY291bnRlclN1bVswXTtcbiAgICAgICAgICAgIGNvcnJlY3Rpb25bMV0gPSBjb2RlU3VtWzFdIC8gY291bnRlclN1bVsxXTtcblxuICAgICAgICAgICAgY29ycmVjdGlvblswXSA9IE1hdGgubWF4KE1hdGgubWluKGNvcnJlY3Rpb25bMF0sIGNvcnJlY3Rpb25SYXRpbyksIGNvcnJlY3Rpb25SYXRpb0ludmVyc2UpO1xuICAgICAgICAgICAgY29ycmVjdGlvblsxXSA9IE1hdGgubWF4KE1hdGgubWluKGNvcnJlY3Rpb25bMV0sIGNvcnJlY3Rpb25SYXRpbyksIGNvcnJlY3Rpb25SYXRpb0ludmVyc2UpO1xuICAgICAgICAgICAgdGhpcy5iYXJTcGFjZVJhdGlvID0gY29ycmVjdGlvbjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbaV0gKj0gdGhpcy5iYXJTcGFjZVJhdGlvW2kgJSAyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX21hdGNoUGF0dGVybihjb3VudGVyLCBjb2RlKTtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9maW5kUGF0dGVybihwYXR0ZXJuOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldD86IG51bWJlciwgaXNXaGl0ZTogYm9vbGVhbiA9IGZhbHNlLCB0cnlIYXJkZXI6IGJvb2xlYW4gPSBmYWxzZSk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IEFycmF5PG51bWJlcj4ocGF0dGVybi5sZW5ndGgpLmZpbGwoMCk7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoOiBCYXJjb2RlUG9zaXRpb24gPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSB0aGlzLkFWR19DT0RFX0VSUk9SO1xuXG4gICAgICAgIGlzV2hpdGUgPSBpc1doaXRlIHx8IGZhbHNlO1xuICAgICAgICB0cnlIYXJkZXIgPSB0cnlIYXJkZXIgfHwgZmFsc2U7XG5cbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdW0gPSBjb3VudGVyLnJlZHVjZSgocHJldiwgbmV4dCkgPT4gcHJldiArIG5leHQsIDApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfZmluZFN0YXJ0KCk6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBsZXQgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBzdGFydEluZm86IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgbmFycm93QmFyV2lkdGggPSAxO1xuXG4gICAgICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybih0aGlzLlNUQVJUX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hcnJvd0JhcldpZHRoID0gTWF0aC5mbG9vcigoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCkgLyA0KTtcbiAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSBuYXJyb3dCYXJXaWR0aCAqIDEwO1xuICAgICAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBzdGFydEluZm8uZW5kO1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRFbmQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kUGF0dGVybih0aGlzLlNUT1BfUEFUVEVSTik7XG4gICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG5cbiAgICAgICAgaWYgKGVuZEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV2ZXJzZSBudW1iZXJzXG4gICAgICAgIGNvbnN0IHRtcCA9IGVuZEluZm8uc3RhcnQ7XG4gICAgICAgIGVuZEluZm8uc3RhcnQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gZW5kSW5mby5lbmQ7XG4gICAgICAgIGVuZEluZm8uZW5kID0gdGhpcy5fcm93Lmxlbmd0aCAtIHRtcDtcblxuICAgICAgICByZXR1cm4gZW5kSW5mbyAhPT0gbnVsbCA/IHRoaXMuX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvKSA6IG51bGw7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfZGVjb2RlUGFpcihjb3VudGVyUGFpcjogQXJyYXk8QXJyYXk8bnVtYmVyPj4pOiBBcnJheTxCYXJjb2RlSW5mbz4gfCBudWxsIHtcbiAgICAgICAgY29uc3QgY29kZXM6IEFycmF5PEJhcmNvZGVJbmZvPiA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlclBhaXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvdW50ZXJQYWlyW2ldKTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZXM7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfZGVjb2RlQ29kZShjb3VudGVyOiBBcnJheTxudW1iZXI+KTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XG5cbiAgICAgICAgY29uc3QgYmVzdE1hdGNoOiBCYXJjb2RlSW5mbyA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IHRoaXMuQ09ERV9QQVRURVJOLmxlbmd0aDsgY29kZSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCB0aGlzLkNPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IhKSB7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IhIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzOiBSZWFkb25seUFycmF5PG51bWJlcj4sIHJlc3VsdDogQXJyYXk8c3RyaW5nPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlSW5mbyB8IEJhcmNvZGVQb3NpdGlvbj4pOiBBcnJheTxCYXJjb2RlSW5mbz4gfCBudWxsIHtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGNvbnN0IGNvdW50ZXJMZW5ndGggPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNvdW50ZXJQYWlyID0gW1swLCAwLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDAsIDBdXTtcbiAgICAgICAgbGV0IGNvZGVzOiBCYXJjb2RlSW5mb1tdIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKHBvcyA8IGNvdW50ZXJMZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBhaXJbMF1baV0gPSBjb3VudGVyc1twb3NdICogdGhpcy5iYXJTcGFjZVJhdGlvWzBdO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQYWlyWzFdW2ldID0gY291bnRlcnNbcG9zICsgMV0gKiB0aGlzLmJhclNwYWNlUmF0aW9bMV07XG4gICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2RlcyA9IHRoaXMuX2RlY29kZVBhaXIoY291bnRlclBhaXIpO1xuICAgICAgICAgICAgaWYgKCFjb2Rlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGVzW2ldLmNvZGUgKyAnJyk7XG4gICAgICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlcztcbiAgICB9O1xuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIHJldHVybiAoY291bnRlcnMubGVuZ3RoICUgMTAgPT09IDApO1xuICAgIH07XG5cbiAgICBwdWJsaWMgZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgICAgICAgdmFyIGRlY29kZWRDb2RlcyA9IG5ldyBBcnJheTxCYXJjb2RlUG9zaXRpb24+KCk7XG5cbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChzdGFydEluZm8pO1xuXG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kRW5kKCk7XG4gICAgICAgIGlmICghZW5kSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb3VudGVycyA9IHRoaXMuX2ZpbGxDb3VudGVycyhzdGFydEluZm8uZW5kLCBlbmRJbmZvLnN0YXJ0LCBmYWxzZSk7XG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q291bnRlckxlbmd0aChjb3VudGVycykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLl9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggJSAyICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goZW5kSW5mbyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmRJbmZvLmVuZCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEkyb2Y1UmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQgfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBVUENFUmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBDT0RFX0ZSRVFVRU5DWSA9IFtcbiAgICAgICAgWyA1NiwgNTIsIDUwLCA0OSwgNDQsIDM4LCAzNSwgNDIsIDQxLCAzNyBdLFxuICAgICAgICBbNywgMTEsIDEzLCAxNCwgMTksIDI1LCAyOCwgMjEsIDIyLCAyNl1dO1xuICAgIFNUT1BfUEFUVEVSTiA9IFsxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3XTtcbiAgICBGT1JNQVQgPSAndXBjX2UnO1xuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChpbkNvZGU6IEJhcmNvZGVQb3NpdGlvbiwgcmVzdWx0OiBBcnJheTxudW1iZXI+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBsZXQgb3V0Q29kZTogQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0geyAuLi5pbkNvZGUgfTtcbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAweDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIG91dENvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG91dENvZGUuZW5kKTtcbiAgICAgICAgICAgIGlmICghb3V0Q29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgICAgIChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlID0gKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgLSBDT0RFX0dfU1RBUlQ7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAoMSA8PCAoNSAtIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG91dENvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZGV0ZXJtaW5lUGFyaXR5KGNvZGVGcmVxdWVuY3ksIHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRDb2RlIGFzIEJhcmNvZGVJbmZvO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2RldGVybWluZVBhcml0eShjb2RlRnJlcXVlbmN5OiBudW1iZXIsIHJlc3VsdDogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBmb3IgKGxldCBuclN5c3RlbSA9IDA7IG5yU3lzdGVtIDwgdGhpcy5DT0RFX0ZSRVFVRU5DWS5sZW5ndGg7IG5yU3lzdGVtKyspe1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLkNPREVfRlJFUVVFTkNZW25yU3lzdGVtXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlRnJlcXVlbmN5ID09PSB0aGlzLkNPREVfRlJFUVVFTkNZW25yU3lzdGVtXVtpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudW5zaGlmdChuclN5c3RlbSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2NvbnZlcnRUb1VQQ0EocmVzdWx0OiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGxldCB1cGNhID0gW3Jlc3VsdFswXV07XG4gICAgICAgIGNvbnN0IGxhc3REaWdpdCA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMl07XG5cbiAgICAgICAgaWYgKGxhc3REaWdpdCA8PSAyKSB7XG4gICAgICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDMpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoW2xhc3REaWdpdCwgMCwgMCwgMCwgMF0pXG4gICAgICAgICAgICAgICAgLmNvbmNhdChyZXN1bHQuc2xpY2UoMywgNikpO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gMykge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA0KSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCAwXSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KHJlc3VsdC5zbGljZSg0LCA2KSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdERpZ2l0ID09PSA0KSB7XG4gICAgICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDUpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoWzAsIDAsIDAsIDAsIDAsIHJlc3VsdFs1XV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA2KSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCBsYXN0RGlnaXRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwY2EucHVzaChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdKTtcbiAgICAgICAgcmV0dXJuIHVwY2E7XG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBfY2hlY2tzdW0ocmVzdWx0OiBBcnJheTxudW1iZXI+KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBzdXBlci5fY2hlY2tzdW0odGhpcy5fY29udmVydFRvVVBDQShyZXN1bHQpKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRFbmQob2Zmc2V0OiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9maW5kRW5kKG9mZnNldCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IFVQQ0VSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyIGZyb20gJy4vZWFuX3JlYWRlcic7XG5pbXBvcnQgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuY2xhc3MgVVBDUmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAndXBjX2EnO1xuICAgIGRlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRUFOUmVhZGVyLnByb3RvdHlwZS5kZWNvZGUuY2FsbCh0aGlzKTtcblxuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5jb2RlICYmIHJlc3VsdC5jb2RlLmxlbmd0aCA9PT0gMTMgJiYgcmVzdWx0LmNvZGUuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb2RlID0gcmVzdWx0LmNvZGUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFVQQ1JlYWRlcjtcbiIsImNvbnN0IEJyZXNlbmhhbSA9IHt9O1xuXG5jb25zdCBTbG9wZSA9IHtcbiAgICBESVI6IHtcbiAgICAgICAgVVA6IDEsXG4gICAgICAgIERPV046IC0xLFxuICAgIH0sXG59O1xuLyoqXG4gKiBTY2FucyBhIGxpbmUgb2YgdGhlIGdpdmVuIGltYWdlIGZyb20gcG9pbnQgcDEgdG8gcDIgYW5kIHJldHVybnMgYSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmdcbiAqIGdyYXktc2NhbGUgdmFsdWVzICgwLTI1NSkgb2YgdGhlIHVuZGVybHlpbmcgcGl4ZWxzIGluIGFkZGl0aW9uIHRvIHRoZSBtaW5cbiAqIGFuZCBtYXggdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IGltYWdlV3JhcHBlclxuICogQHBhcmFtIHtPYmplY3R9IHAxIFRoZSBzdGFydCBwb2ludCB7eCx5fVxuICogQHBhcmFtIHtPYmplY3R9IHAyIFRoZSBlbmQgcG9pbnQge3gseX1cbiAqIEByZXR1cm5zIHtsaW5lLCBtaW4sIG1heH1cbiAqL1xuQnJlc2VuaGFtLmdldEJhcmNvZGVMaW5lID0gZnVuY3Rpb24gKGltYWdlV3JhcHBlciwgcDEsIHAyKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgIGxldCB4MCA9IHAxLnggfCAwO1xuICAgIGxldCB5MCA9IHAxLnkgfCAwO1xuICAgIGxldCB4MSA9IHAyLnggfCAwO1xuICAgIGxldCB5MSA9IHAyLnkgfCAwO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cbiAgICBjb25zdCBzdGVlcCA9IE1hdGguYWJzKHkxIC0geTApID4gTWF0aC5hYnMoeDEgLSB4MCk7XG4gICAgbGV0IGVycm9yO1xuICAgIGxldCB5O1xuICAgIGxldCB0bXA7XG4gICAgbGV0IHg7XG4gICAgY29uc3QgbGluZSA9IFtdO1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgdmFsO1xuICAgIGxldCBtaW4gPSAyNTU7XG4gICAgbGV0IG1heCA9IDA7XG5cbiAgICBmdW5jdGlvbiByZWFkKGEsIGIpIHtcbiAgICAgICAgdmFsID0gaW1hZ2VEYXRhW2IgKiB3aWR0aCArIGFdO1xuICAgICAgICBtaW4gPSB2YWwgPCBtaW4gPyB2YWwgOiBtaW47XG4gICAgICAgIG1heCA9IHZhbCA+IG1heCA/IHZhbCA6IG1heDtcbiAgICAgICAgbGluZS5wdXNoKHZhbCk7XG4gICAgfVxuXG4gICAgaWYgKHN0ZWVwKSB7XG4gICAgICAgIHRtcCA9IHgwO1xuICAgICAgICB4MCA9IHkwO1xuICAgICAgICB5MCA9IHRtcDtcblxuICAgICAgICB0bXAgPSB4MTtcbiAgICAgICAgeDEgPSB5MTtcbiAgICAgICAgeTEgPSB0bXA7XG4gICAgfVxuICAgIGlmICh4MCA+IHgxKSB7XG4gICAgICAgIHRtcCA9IHgwO1xuICAgICAgICB4MCA9IHgxO1xuICAgICAgICB4MSA9IHRtcDtcblxuICAgICAgICB0bXAgPSB5MDtcbiAgICAgICAgeTAgPSB5MTtcbiAgICAgICAgeTEgPSB0bXA7XG4gICAgfVxuICAgIGNvbnN0IGRlbHRhWCA9IHgxIC0geDA7XG4gICAgY29uc3QgZGVsdGFZID0gTWF0aC5hYnMoeTEgLSB5MCk7XG4gICAgZXJyb3IgPSAoZGVsdGFYIC8gMikgfCAwO1xuICAgIHkgPSB5MDtcbiAgICBjb25zdCB5U3RlcCA9IHkwIDwgeTEgPyAxIDogLTE7XG4gICAgZm9yICh4ID0geDA7IHggPCB4MTsgeCsrKSB7XG4gICAgICAgIGlmIChzdGVlcCkge1xuICAgICAgICAgICAgcmVhZCh5LCB4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlYWQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IgLT0gZGVsdGFZO1xuICAgICAgICBpZiAoZXJyb3IgPCAwKSB7XG4gICAgICAgICAgICB5ICs9IHlTdGVwO1xuICAgICAgICAgICAgZXJyb3IgKz0gZGVsdGFYO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgbWluLFxuICAgICAgICBtYXgsXG4gICAgfTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHJlc3VsdCBmcm9tIGdldEJhcmNvZGVMaW5lIGludG8gYSBiaW5hcnkgcmVwcmVzZW50YXRpb25cbiAqIGFsc28gY29uc2lkZXJpbmcgdGhlIGZyZXF1ZW5jeSBhbmQgc2xvcGUgb2YgdGhlIHNpZ25hbCBmb3IgbW9yZSByb2J1c3QgcmVzdWx0c1xuICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCB7bGluZSwgbWluLCBtYXh9XG4gKi9cbkJyZXNlbmhhbS50b0JpbmFyeUxpbmUgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgY29uc3QgeyBtaW4gfSA9IHJlc3VsdDtcbiAgICBjb25zdCB7IG1heCB9ID0gcmVzdWx0O1xuICAgIGNvbnN0IHsgbGluZSB9ID0gcmVzdWx0O1xuICAgIGxldCBzbG9wZTtcbiAgICBsZXQgc2xvcGUyO1xuICAgIGNvbnN0IGNlbnRlciA9IG1pbiArIChtYXggLSBtaW4pIC8gMjtcbiAgICBjb25zdCBleHRyZW1hID0gW107XG4gICAgbGV0IGN1cnJlbnREaXI7XG4gICAgbGV0IGRpcjtcbiAgICBsZXQgdGhyZXNob2xkID0gKG1heCAtIG1pbikgLyAxMjtcbiAgICBjb25zdCByVGhyZXNob2xkID0gLXRocmVzaG9sZDtcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcblxuICAgIC8vIDEuIGZpbmQgZXh0cmVtYVxuICAgIGN1cnJlbnREaXIgPSBsaW5lWzBdID4gY2VudGVyID8gU2xvcGUuRElSLlVQIDogU2xvcGUuRElSLkRPV047XG4gICAgZXh0cmVtYS5wdXNoKHtcbiAgICAgICAgcG9zOiAwLFxuICAgICAgICB2YWw6IGxpbmVbMF0sXG4gICAgfSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgIHNsb3BlID0gKGxpbmVbaSArIDFdIC0gbGluZVtpXSk7XG4gICAgICAgIHNsb3BlMiA9IChsaW5lW2kgKyAyXSAtIGxpbmVbaSArIDFdKTtcbiAgICAgICAgaWYgKChzbG9wZSArIHNsb3BlMikgPCByVGhyZXNob2xkICYmIGxpbmVbaSArIDFdIDwgKGNlbnRlciAqIDEuNSkpIHtcbiAgICAgICAgICAgIGRpciA9IFNsb3BlLkRJUi5ET1dOO1xuICAgICAgICB9IGVsc2UgaWYgKChzbG9wZSArIHNsb3BlMikgPiB0aHJlc2hvbGQgJiYgbGluZVtpICsgMV0gPiAoY2VudGVyICogMC41KSkge1xuICAgICAgICAgICAgZGlyID0gU2xvcGUuRElSLlVQO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlyID0gY3VycmVudERpcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50RGlyICE9PSBkaXIpIHtcbiAgICAgICAgICAgIGV4dHJlbWEucHVzaCh7XG4gICAgICAgICAgICAgICAgcG9zOiBpLFxuICAgICAgICAgICAgICAgIHZhbDogbGluZVtpXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudERpciA9IGRpcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleHRyZW1hLnB1c2goe1xuICAgICAgICBwb3M6IGxpbmUubGVuZ3RoLFxuICAgICAgICB2YWw6IGxpbmVbbGluZS5sZW5ndGggLSAxXSxcbiAgICB9KTtcblxuICAgIGZvciAoaiA9IGV4dHJlbWFbMF0ucG9zOyBqIDwgZXh0cmVtYVsxXS5wb3M7IGorKykge1xuICAgICAgICBsaW5lW2pdID0gbGluZVtqXSA+IGNlbnRlciA/IDAgOiAxO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBleHRyZW1hIGFuZCBjb252ZXJ0IHRvIGJpbmFyeSBiYXNlZCBvbiBhdmcgYmV0d2VlbiBtaW5tYXhcbiAgICBmb3IgKGkgPSAxOyBpIDwgZXh0cmVtYS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGV4dHJlbWFbaSArIDFdLnZhbCA+IGV4dHJlbWFbaV0udmFsKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoZXh0cmVtYVtpXS52YWwgKyAoKGV4dHJlbWFbaSArIDFdLnZhbCAtIGV4dHJlbWFbaV0udmFsKSAvIDMpICogMikgfCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyZXNob2xkID0gKGV4dHJlbWFbaSArIDFdLnZhbCArICgoZXh0cmVtYVtpXS52YWwgLSBleHRyZW1hW2kgKyAxXS52YWwpIC8gMykpIHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaiA9IGV4dHJlbWFbaV0ucG9zOyBqIDwgZXh0cmVtYVtpICsgMV0ucG9zOyBqKyspIHtcbiAgICAgICAgICAgIGxpbmVbal0gPSBsaW5lW2pdID4gdGhyZXNob2xkID8gMCA6IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5lLFxuICAgICAgICB0aHJlc2hvbGQsXG4gICAgfTtcbn07XG5cbi8qKlxuICogVXNlZCBmb3IgZGV2ZWxvcG1lbnQgb25seVxuICovXG5CcmVzZW5oYW0uZGVidWcgPSB7XG4gICAgcHJpbnRGcmVxdWVuY3kobGluZSwgY2FudmFzKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGxpbmUubGVuZ3RoO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDI1NjtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibHVlJztcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oaSwgMjU1KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaSwgMjU1IC0gbGluZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIHByaW50UGF0dGVybihsaW5lLCBjYW52YXMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7IGxldFxuICAgICAgICAgICAgaTtcblxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLndpZHRoID0gbGluZS5sZW5ndGg7XG4gICAgICAgIGN0eC5maWxsQ29sb3IgPSAnYmxhY2snO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpbmVbaV0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoaSwgMCwgMSwgMTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBCcmVzZW5oYW07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tY3ljbGUgKi9cblxuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBUd29PZkZpdmVSZWFkZXIgZnJvbSAnLi4vcmVhZGVyLzJvZjVfcmVhZGVyJztcbmltcG9ydCBDb2RhYmFyUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RhYmFyX3JlYWRlcic7XG5pbXBvcnQgQ29kZTEyOFJlYWRlciBmcm9tICcuLi9yZWFkZXIvY29kZV8xMjhfcmVhZGVyJztcbmltcG9ydCBDb2RlMzJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMzJfcmVhZGVyJztcbmltcG9ydCBDb2RlMzlSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMzlfcmVhZGVyJztcbmltcG9ydCBDb2RlMzlWSU5SZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGVfMzlfdmluX3JlYWRlcic7XG5pbXBvcnQgQ29kZTkzUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzkzX3JlYWRlcic7XG5pbXBvcnQgRUFOMlJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuXzJfcmVhZGVyJztcbmltcG9ydCBFQU41UmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fNV9yZWFkZXInO1xuaW1wb3J0IEVBTjhSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl84X3JlYWRlcic7XG5pbXBvcnQgRUFOUmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fcmVhZGVyJztcbmltcG9ydCBJMm9mNVJlYWRlciBmcm9tICcuLi9yZWFkZXIvaTJvZjVfcmVhZGVyJztcbmltcG9ydCBVUENFUmVhZGVyIGZyb20gJy4uL3JlYWRlci91cGNfZV9yZWFkZXInO1xuaW1wb3J0IFVQQ1JlYWRlciBmcm9tICcuLi9yZWFkZXIvdXBjX3JlYWRlcic7XG5pbXBvcnQgQnJlc2VuaGFtIGZyb20gJy4vYnJlc2VuaGFtJztcblxuY29uc3QgUkVBREVSUyA9IHtcbiAgICBjb2RlXzEyOF9yZWFkZXI6IENvZGUxMjhSZWFkZXIsXG4gICAgZWFuX3JlYWRlcjogRUFOUmVhZGVyLFxuICAgIGVhbl81X3JlYWRlcjogRUFONVJlYWRlcixcbiAgICBlYW5fMl9yZWFkZXI6IEVBTjJSZWFkZXIsXG4gICAgZWFuXzhfcmVhZGVyOiBFQU44UmVhZGVyLFxuICAgIGNvZGVfMzlfcmVhZGVyOiBDb2RlMzlSZWFkZXIsXG4gICAgY29kZV8zOV92aW5fcmVhZGVyOiBDb2RlMzlWSU5SZWFkZXIsXG4gICAgY29kYWJhcl9yZWFkZXI6IENvZGFiYXJSZWFkZXIsXG4gICAgdXBjX3JlYWRlcjogVVBDUmVhZGVyLFxuICAgIHVwY19lX3JlYWRlcjogVVBDRVJlYWRlcixcbiAgICBpMm9mNV9yZWFkZXI6IEkyb2Y1UmVhZGVyLFxuICAgICcyb2Y1X3JlYWRlcic6IFR3b09mRml2ZVJlYWRlcixcbiAgICBjb2RlXzkzX3JlYWRlcjogQ29kZTkzUmVhZGVyLFxuICAgIGNvZGVfMzJfcmVhZGVyOiBDb2RlMzJSZWFkZXIsXG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgcmVnaXN0ZXJSZWFkZXI6IChuYW1lLCByZWFkZXIpID0+IHtcbiAgICAgICAgUkVBREVSU1tuYW1lXSA9IHJlYWRlcjtcbiAgICB9LFxuICAgIGNyZWF0ZShjb25maWcsIGlucHV0SW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIGNvbnN0IF9jYW52YXMgPSB7XG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG51bGwsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogbnVsbCxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbToge1xuICAgICAgICAgICAgICAgIGZyZXF1ZW5jeTogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBfYmFyY29kZVJlYWRlcnMgPSBbXTtcblxuICAgICAgICBpbml0Q2FudmFzKCk7XG4gICAgICAgIGluaXRSZWFkZXJzKCk7XG4gICAgICAgIGluaXRDb25maWcoKTtcblxuICAgICAgICBmdW5jdGlvbiBpbml0Q2FudmFzKCkge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJGRlYnVnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2RlYnVnLmRldGVjdGlvbicpO1xuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLmZyZXF1ZW5jeSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NhbnZhcy5mcmVxdWVuY3knKTtcbiAgICAgICAgICAgICAgICBpZiAoIV9jYW52YXMuZG9tLmZyZXF1ZW5jeSkge1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20uZnJlcXVlbmN5LmNsYXNzTmFtZSA9ICdmcmVxdWVuY3knO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZGVidWcuYXBwZW5kQ2hpbGQoX2NhbnZhcy5kb20uZnJlcXVlbmN5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5mcmVxdWVuY3kgPSBfY2FudmFzLmRvbS5mcmVxdWVuY3kuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMucGF0dGVybkJ1ZmZlcicpO1xuICAgICAgICAgICAgICAgIGlmICghX2NhbnZhcy5kb20ucGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLnBhdHRlcm4uY2xhc3NOYW1lID0gJ3BhdHRlcm5CdWZmZXInO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZGVidWcuYXBwZW5kQ2hpbGQoX2NhbnZhcy5kb20ucGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2NhbnZhcy5jdHgucGF0dGVybiA9IF9jYW52YXMuZG9tLnBhdHRlcm4uZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLm92ZXJsYXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMuZHJhd2luZ0J1ZmZlcicpO1xuICAgICAgICAgICAgICAgIGlmIChfY2FudmFzLmRvbS5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuY3R4Lm92ZXJsYXkgPSBfY2FudmFzLmRvbS5vdmVybGF5LmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdFJlYWRlcnMoKSB7XG4gICAgICAgICAgICBjb25maWcucmVhZGVycy5mb3JFYWNoKChyZWFkZXJDb25maWcpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVhZGVyO1xuICAgICAgICAgICAgICAgIGxldCBjb25maWd1cmF0aW9uID0ge307XG4gICAgICAgICAgICAgICAgbGV0IHN1cHBsZW1lbnRzID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlYWRlckNvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gcmVhZGVyQ29uZmlnLmZvcm1hdDtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbiA9IHJlYWRlckNvbmZpZy5jb25maWc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVhZGVyQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSByZWFkZXJDb25maWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0JlZm9yZSByZWdpc3RlcmluZyByZWFkZXI6ICcsIHJlYWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uLnN1cHBsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBsZW1lbnRzID0gY29uZmlndXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLnN1cHBsZW1lbnRzLm1hcCgoc3VwcGxlbWVudCkgPT4gbmV3IFJFQURFUlNbc3VwcGxlbWVudF0oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlck9iaiA9IG5ldyBSRUFERVJTW3JlYWRlcl0oY29uZmlndXJhdGlvbiwgc3VwcGxlbWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBfYmFyY29kZVJlYWRlcnMucHVzaChyZWFkZXJPYmopO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCcqIEVycm9yIGNvbnN0cnVjdGluZyByZWFkZXIgJywgcmVhZGVyLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFJlZ2lzdGVyZWQgUmVhZGVyczogJHtfYmFyY29kZVJlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgocmVhZGVyKSA9PiBKU09OLnN0cmluZ2lmeSh7IGZvcm1hdDogcmVhZGVyLkZPUk1BVCwgY29uZmlnOiByZWFkZXIuY29uZmlnIH0pKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRDb25maWcoKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXMgPSBbe1xuICAgICAgICAgICAgICAgICAgICBub2RlOiBfY2FudmFzLmRvbS5mcmVxdWVuY3ksXG4gICAgICAgICAgICAgICAgICAgIHByb3A6IGNvbmZpZy5kZWJ1Zy5zaG93RnJlcXVlbmN5LFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogX2NhbnZhcy5kb20ucGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgcHJvcDogY29uZmlnLmRlYnVnLnNob3dQYXR0ZXJuLFxuICAgICAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlzW2ldLnByb3AgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc1tpXS5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzW2ldLm5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBleHRlbmQgdGhlIGxpbmUgb24gYm90aCBlbmRzXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRFeHRlbmRlZExpbmUobGluZSwgYW5nbGUsIGV4dCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZXh0ZW5kTGluZShhbW91bnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHRlbnNpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHk6IGFtb3VudCAqIE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgICAgICAgICAgeDogYW1vdW50ICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgICAgICAgICBsaW5lWzBdLnkgLT0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgbGluZVswXS54IC09IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueSArPSBleHRlbnNpb24ueTtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnggKz0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBpbnNpZGUgaW1hZ2VcbiAgICAgICAgICAgIGV4dGVuZExpbmUoZXh0KTtcbiAgICAgICAgICAgIHdoaWxlIChleHQgPiAxICYmICghaW5wdXRJbWFnZVdyYXBwZXIuaW5JbWFnZVdpdGhCb3JkZXIobGluZVswXSlcbiAgICAgICAgICAgICAgICAgICAgfHwgIWlucHV0SW1hZ2VXcmFwcGVyLmluSW1hZ2VXaXRoQm9yZGVyKGxpbmVbMV0pKSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgICAgIGV4dCAtPSBNYXRoLmNlaWwoZXh0IC8gMik7XG4gICAgICAgICAgICAgICAgZXh0ZW5kTGluZSgtZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0TGluZShib3gpIHtcbiAgICAgICAgICAgIHJldHVybiBbe1xuICAgICAgICAgICAgICAgIHg6IChib3hbMV1bMF0gLSBib3hbMF1bMF0pIC8gMiArIGJveFswXVswXSxcbiAgICAgICAgICAgICAgICB5OiAoYm94WzFdWzFdIC0gYm94WzBdWzFdKSAvIDIgKyBib3hbMF1bMV0sXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgeDogKGJveFszXVswXSAtIGJveFsyXVswXSkgLyAyICsgYm94WzJdWzBdLFxuICAgICAgICAgICAgICAgIHk6IChib3hbM11bMV0gLSBib3hbMl1bMV0pIC8gMiArIGJveFsyXVsxXSxcbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdHJ5RGVjb2RlKGxpbmUpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBjb25zdCBiYXJjb2RlTGluZSA9IEJyZXNlbmhhbS5nZXRCYXJjb2RlTGluZShpbnB1dEltYWdlV3JhcHBlciwgbGluZVswXSwgbGluZVsxXSk7XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnLnNob3dGcmVxdWVuY3kpIHtcbiAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGxpbmUsIHsgeDogJ3gnLCB5OiAneScgfSwgX2NhbnZhcy5jdHgub3ZlcmxheSwgeyBjb2xvcjogJ3JlZCcsIGxpbmVXaWR0aDogMyB9KTtcbiAgICAgICAgICAgICAgICBCcmVzZW5oYW0uZGVidWcucHJpbnRGcmVxdWVuY3koYmFyY29kZUxpbmUubGluZSwgX2NhbnZhcy5kb20uZnJlcXVlbmN5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQnJlc2VuaGFtLnRvQmluYXJ5TGluZShiYXJjb2RlTGluZSk7XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnLnNob3dQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgQnJlc2VuaGFtLmRlYnVnLnByaW50UGF0dGVybihiYXJjb2RlTGluZS5saW5lLCBfY2FudmFzLmRvbS5wYXR0ZXJuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IF9iYXJjb2RlUmVhZGVycy5sZW5ndGggJiYgcmVzdWx0ID09PSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfYmFyY29kZVJlYWRlcnNbaV0uZGVjb2RlUGF0dGVybihiYXJjb2RlTGluZS5saW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29kZVJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgIGJhcmNvZGVMaW5lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBzbGljZXMgdGhlIGdpdmVuIGFyZWEgYXBhcnQgYW5kIHRyaWVzIHRvIGRldGVjdCBhIGJhcmNvZGUtcGF0dGVyblxuICAgICAgICAgKiBmb3IgZWFjaCBzbGljZS4gSXQgcmV0dXJucyB0aGUgZGVjb2RlZCBiYXJjb2RlLCBvciBudWxsIGlmIG5vdGhpbmcgd2FzIGZvdW5kXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGJveFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5lXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lQW5nbGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHRyeURlY29kZUJydXRlRm9yY2UoYm94LCBsaW5lLCBsaW5lQW5nbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZGVMZW5ndGggPSBNYXRoLnNxcnQoTWF0aC5wb3coYm94WzFdWzBdIC0gYm94WzBdWzBdLCAyKSArIE1hdGgucG93KChib3hbMV1bMV0gLSBib3hbMF1bMV0pLCAyKSk7XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlcyA9IDE2O1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZGlyO1xuICAgICAgICAgICAgbGV0IGV4dGVuc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IHhkaXIgPSBNYXRoLnNpbihsaW5lQW5nbGUpO1xuICAgICAgICAgICAgY29uc3QgeWRpciA9IE1hdGguY29zKGxpbmVBbmdsZSk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBzbGljZXMgJiYgcmVzdWx0ID09PSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGxpbmUgcGVycGVuZGljdWxhciB0byBhbmdsZVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXhlZC1vcGVyYXRvcnNcbiAgICAgICAgICAgICAgICBkaXIgPSBzaWRlTGVuZ3RoIC8gc2xpY2VzICogaSAqIChpICUgMiA9PT0gMCA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB5OiBkaXIgKiB4ZGlyLFxuICAgICAgICAgICAgICAgICAgICB4OiBkaXIgKiB5ZGlyLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgICAgICAgICBsaW5lWzBdLnkgKz0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICAgICAgbGluZVswXS54IC09IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueSArPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnggLT0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlKGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldExpbmVMZW5ndGgobGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChcbiAgICAgICAgICAgICAgICBNYXRoLnBvdyhNYXRoLmFicyhsaW5lWzFdLnkgLSBsaW5lWzBdLnkpLCAyKVxuICAgICAgICAgICAgICAgICsgTWF0aC5wb3coTWF0aC5hYnMobGluZVsxXS54IC0gbGluZVswXS54KSwgMiksXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gZGVjb2RlRnJvbUltYWdlKGltYWdlV3JhcHBlcikge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiBfYmFyY29kZVJlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVhZGVyLmRlY29kZUltYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHJlYWRlci5kZWNvZGVJbWFnZShpbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdpdGggdGhlIGhlbHAgb2YgdGhlIGNvbmZpZ3VyZWQgcmVhZGVycyAoQ29kZTEyOCBvciBFQU4pIHRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gZGV0ZWN0IGFcbiAgICAgICAgICogdmFsaWQgYmFyY29kZSBwYXR0ZXJuIHdpdGhpbiB0aGUgZ2l2ZW4gYXJlYS5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGJveCBUaGUgYXJlYSB0byBzZWFyY2ggaW5cbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gdGhlIHJlc3VsdCB7Y29kZVJlc3VsdCwgbGluZSwgYW5nbGUsIHBhdHRlcm4sIHRocmVzaG9sZH1cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpIHtcbiAgICAgICAgICAgIGxldCBsaW5lO1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gX2NhbnZhcy5jdHgub3ZlcmxheTtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRlYnVnLmRyYXdCb3VuZGluZ0JveCAmJiBjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChib3gsIHsgeDogMCwgeTogMSB9LCBjdHgsIHsgY29sb3I6ICdibHVlJywgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZSA9IGdldExpbmUoYm94KTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVMZW5ndGggPSBnZXRMaW5lTGVuZ3RoKGxpbmUpO1xuICAgICAgICAgICAgY29uc3QgbGluZUFuZ2xlID0gTWF0aC5hdGFuMihsaW5lWzFdLnkgLSBsaW5lWzBdLnksIGxpbmVbMV0ueCAtIGxpbmVbMF0ueCk7XG4gICAgICAgICAgICBsaW5lID0gZ2V0RXh0ZW5kZWRMaW5lKGxpbmUsIGxpbmVBbmdsZSwgTWF0aC5mbG9vcihsaW5lTGVuZ3RoICogMC4xKSk7XG4gICAgICAgICAgICBpZiAobGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgPSB0cnlEZWNvZGUobGluZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5RGVjb2RlQnJ1dGVGb3JjZShib3gsIGxpbmUsIGxpbmVBbmdsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiByZXN1bHQgJiYgY29uZmlnLmRlYnVnLmRyYXdTY2FubGluZSAmJiBjdHgpIHtcbiAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGxpbmUsIHsgeDogJ3gnLCB5OiAneScgfSwgY3R4LCB7IGNvbG9yOiAncmVkJywgbGluZVdpZHRoOiAzIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvZGVSZXN1bHQ6IHJlc3VsdC5jb2RlUmVzdWx0LFxuICAgICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICAgICAgYW5nbGU6IGxpbmVBbmdsZSxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiByZXN1bHQuYmFyY29kZUxpbmUubGluZSxcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IHJlc3VsdC5iYXJjb2RlTGluZS50aHJlc2hvbGQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMoYm94ZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaTsgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXJjb2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbXVsdGlwbGUgfSA9IGNvbmZpZztcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCkgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ib3ggPSBib3g7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2Rlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmNvZGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBiYXJjb2RlcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jIGRlY29kZUZyb21JbWFnZShpbWFnZVdyYXBwZXJJbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRlY29kZUZyb21JbWFnZShpbWFnZVdyYXBwZXJJbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoUkVBREVSU1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCByZWdpc3RlciBleGlzdGluZyByZWFkZXInLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUkVBREVSU1tuYW1lXSA9IHJlYWRlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRSZWFkZXJzKHJlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBjb25maWcucmVhZGVycyA9IHJlYWRlcnM7XG4gICAgICAgICAgICAgICAgX2JhcmNvZGVSZWFkZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgaW5pdFJlYWRlcnMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBUd29PZkZpdmVSZWFkZXIgZnJvbSAnLi8yb2Y1X3JlYWRlcic7XG5pbXBvcnQgTmV3Q29kYWJhclJlYWRlciBmcm9tICcuL2NvZGFiYXJfcmVhZGVyJztcbmltcG9ydCBDb2RlMTI4UmVhZGVyIGZyb20gJy4vY29kZV8xMjhfcmVhZGVyJztcbmltcG9ydCBDb2RlMzJSZWFkZXIgZnJvbSAnLi9jb2RlXzMyX3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4vY29kZV8zOV9yZWFkZXInO1xuaW1wb3J0IENvZGUzOVZJTlJlYWRlciBmcm9tICcuL2NvZGVfMzlfdmluX3JlYWRlcic7XG5pbXBvcnQgQ29kZTkzUmVhZGVyIGZyb20gJy4vY29kZV85M19yZWFkZXInO1xuaW1wb3J0IEVBTjJSZWFkZXIgZnJvbSAnLi9lYW5fMl9yZWFkZXInO1xuaW1wb3J0IEVBTjVSZWFkZXIgZnJvbSAnLi9lYW5fNV9yZWFkZXInO1xuaW1wb3J0IEVBTjhSZWFkZXIgZnJvbSAnLi9lYW5fOF9yZWFkZXInO1xuaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IEkyb2Y1UmVhZGVyIGZyb20gJy4vaTJvZjVfcmVhZGVyJztcbmltcG9ydCBVUENFUmVhZGVyIGZyb20gJy4vdXBjX2VfcmVhZGVyJztcbmltcG9ydCBVUENSZWFkZXIgZnJvbSAnLi91cGNfcmVhZGVyJztcblxuZXhwb3J0IHtcbiAgICBCYXJjb2RlUmVhZGVyLFxuICAgIFR3b09mRml2ZVJlYWRlcixcbiAgICBOZXdDb2RhYmFyUmVhZGVyLFxuICAgIENvZGUxMjhSZWFkZXIsXG4gICAgQ29kZTMyUmVhZGVyLFxuICAgIENvZGUzOVJlYWRlcixcbiAgICBDb2RlMzlWSU5SZWFkZXIsXG4gICAgQ29kZTkzUmVhZGVyLFxuICAgIEVBTjJSZWFkZXIsXG4gICAgRUFONVJlYWRlcixcbiAgICBFQU44UmVhZGVyLFxuICAgIEVBTlJlYWRlcixcbiAgICBJMm9mNVJlYWRlcixcbiAgICBVUENFUmVhZGVyLFxuICAgIFVQQ1JlYWRlciwgICAgXG59XG4iLCJ0eXBlIEV2ZW50TmFtZSA9IHN0cmluZztcblxuaW50ZXJmYWNlIFN1YnNjcmlwdGlvbiB7XG4gICAgYXN5bmM/OiBib29sZWFuO1xuICAgIGNhbGxiYWNrOiBGdW5jdGlvbjtcbiAgICBvbmNlPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIEV2ZW50RGF0YSB7XG4gICAgc3Vic2NyaWJlcnM6IEFycmF5PFN1YnNjcmlwdGlvbj47XG59XG5cbmludGVyZmFjZSBFdmVudHMge1xuICAgIFtrZXk6IHN0cmluZ106IEV2ZW50RGF0YTtcbn1cblxuaW50ZXJmYWNlIEV2ZW50SW50ZXJmYWNlIHtcbiAgICBzdWJzY3JpYmUoZXZlbnQ6IEV2ZW50TmFtZSwgY2FsbGJhY2s6IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uLCBhc3luYz86IGJvb2xlYW4pOiB2b2lkO1xuICAgIHB1Ymxpc2goZXZlbnROYW1lOiBFdmVudE5hbWUsIGRhdGE/OiBuZXZlcik6IHZvaWQ7XG4gICAgb25jZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgdW5zdWJzY3JpYmUoZXZlbnROYW1lPzogRXZlbnROYW1lLCBjYWxsYmFjaz86IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uKTogdm9pZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIEV2ZW50SW50ZXJmYWNlKCk6IEV2ZW50SW50ZXJmYWNlIHtcbiAgICBsZXQgZXZlbnRzOiBFdmVudHMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGdldEV2ZW50KGV2ZW50TmFtZTogRXZlbnROYW1lKTogRXZlbnREYXRhIHtcbiAgICAgICAgaWYgKCFldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgZXZlbnRzW2V2ZW50TmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnM6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJFdmVudHMoKTogdm9pZCB7XG4gICAgICAgIGV2ZW50cyA9IHt9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1Ymxpc2hTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24sIGRhdGE6IG5ldmVyKTogdm9pZCB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgIH0sIDQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3N1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBsZXQgc3Vic2NyaXB0aW9uO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBhc3luYyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGlmICghc3Vic2NyaXB0aW9uLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayB3YXMgbm90IHNwZWNpZmllZCBvbiBvcHRpb25zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZXRFdmVudChldmVudCkuc3Vic2NyaWJlcnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICAgICAgcmV0dXJuIF9zdWJzY3JpYmUoZXZlbnQsIGNhbGxiYWNrLCBhc3luYyk7XG4gICAgICAgIH0sXG4gICAgICAgIHB1Ymxpc2goZXZlbnROYW1lOiBFdmVudE5hbWUsIGRhdGE/OiBuZXZlcik6IHZvaWQge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBnZXRFdmVudChldmVudE5hbWUpO1xuICAgICAgICAgICAgY29uc3QgeyBzdWJzY3JpYmVycyB9ID0gZXZlbnQ7XG5cbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggb25lLXRpbWUgc3Vic2NyaXB0aW9uc1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMuZmlsdGVyKChzdWJzY3JpYmVyKSA9PiAhIXN1YnNjcmliZXIub25jZSkuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHB1Ymxpc2hTdWJzY3JpcHRpb24oc3Vic2NyaWJlciwgZGF0YSBhcyBuZXZlcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc3Vic2NyaWJlclxuICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycy5maWx0ZXIoKHN1YnNjcmliZXIpID0+ICFzdWJzY3JpYmVyLm9uY2UpO1xuXG4gICAgICAgICAgICAvLyBwdWJsaXNoIHRoZSByZXN0XG4gICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycy5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyLCBkYXRhIGFzIG5ldmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbmNlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiwgYXN5bmMgPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICAgICAgX3N1YnNjcmliZShldmVudCwge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGFzeW5jLFxuICAgICAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zdWJzY3JpYmUoZXZlbnROYW1lPzogRXZlbnROYW1lLCBjYWxsYmFjaz86IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uKTogdm9pZCB7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBnZXRFdmVudChldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChldmVudCAmJiBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycyA9IGV2ZW50LnN1YnNjcmliZXJzLmZpbHRlcigoc3Vic2NyaWJlcikgPT4gc3Vic2NyaWJlci5jYWxsYmFjayAhPT0gY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhckV2ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59KCkpO1xuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvZGU/OiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihtOiBzdHJpbmcsIGNvZGU/OiBudW1iZXIpIHtcbiAgICAgICAgc3VwZXIobSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBFeGNlcHRpb24ucHJvdG90eXBlKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4uL3F1YWdnYS9FeGNlcHRpb24nO1xuXG5jb25zdCBFUlJPUl9ERVNDID0gJ1RoaXMgbWF5IG1lYW4gdGhhdCB0aGUgdXNlciBoYXMgZGVjbGluZWQgY2FtZXJhIGFjY2Vzcywgb3IgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBtZWRpYSBBUElzLiBJZiB5b3UgYXJlIHJ1bm5pbmcgaW4gaU9TLCB5b3UgbXVzdCB1c2UgU2FmYXJpLic7XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnVtZXJhdGVEZXZpY2VzKCk6IFByb21pc2U8QXJyYXk8TWVkaWFEZXZpY2VJbmZvPj4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3I6IEVycm9yID0gbmV3IEV4Y2VwdGlvbihgZW51bWVyYXRlRGV2aWNlcyBpcyBub3QgZGVmaW5lZC4gJHtFUlJPUl9ERVNDfWAsIC0xKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVc2VyTWVkaWEoY29uc3RyYWludHM6IE1lZGlhU3RyZWFtQ29uc3RyYWludHMpOiBQcm9taXNlPE1lZGlhU3RyZWFtPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3I6IEVycm9yID0gbmV3IEV4Y2VwdGlvbihgZ2V0VXNlck1lZGlhIGlzIG5vdCBkZWZpbmVkLiAke0VSUk9SX0RFU0N9YCwgLTEpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbn1cbiIsIi8vIFRPRE86IHdoZW4gdGhpcyBmaWxlIHdhcyB3cml0dGVuIHllYXJzIGFnbywgSFRNTE1lZGlhRWxlbWVudC5wbGF5KCkgZGlkIG5vdCByZXR1cm4gYSB1c2VmdWwgdmFsdWVcbi8vIHRvIGxldCB1cyBrbm93IHdoZW4gdGhlIHZpZGVvIHN0YXJ0ZWQgcGxheWluZy4gIE5vdywgaXQgZG9lcy4gIFNvLCB3ZSBzaG91bGRuJ3QgbmVlZCB0byBydW4gdGhpc1xuLy8gb2RkIHdhaXRGb3JWaWRlbygpIGZ1bmN0aW9uIHRoYXQgcG9sbHMgdG8gc2VlIGlmIHRoZSB2aWRlbyBoYXMgc3RhcnRlZC5cbmltcG9ydCBwaWNrIGZyb20gJ2xvZGFzaC9waWNrJztcbmltcG9ydCB0eXBlIHtcbiAgICBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCxcbiAgICBRdWFnZ2FKU0NhbWVyYUFjY2VzcyBhcyBDYW1lcmFBY2Nlc3NUeXBlLFxufSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcbmltcG9ydCB7IGdldFVzZXJNZWRpYSwgZW51bWVyYXRlRGV2aWNlcyB9IGZyb20gJy4uL2NvbW1vbi9tZWRpYURldmljZXMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9xdWFnZ2EvRXhjZXB0aW9uJztcblxubGV0IHN0cmVhbVJlZjogTWVkaWFTdHJlYW0gfCBudWxsO1xuXG5mdW5jdGlvbiB3YWl0Rm9yVmlkZW8odmlkZW86IEhUTUxWaWRlb0VsZW1lbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgYXR0ZW1wdHMgPSAxMDtcblxuICAgICAgICBmdW5jdGlvbiBjaGVja1ZpZGVvKCk6IHZvaWQge1xuICAgICAgICAgICAgaWYgKGF0dGVtcHRzID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh2aWRlby52aWRlb1dpZHRoID4gMTAgJiYgdmlkZW8udmlkZW9IZWlnaHQgPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgKiBkZXY6IGNoZWNrVmlkZW8gZm91bmQgJHt2aWRlby52aWRlb1dpZHRofXB4IHggJHt2aWRlby52aWRlb0hlaWdodH1weGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjaGVja1ZpZGVvLCA1MDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFeGNlcHRpb24oJ1VuYWJsZSB0byBwbGF5IHZpZGVvIHN0cmVhbS4gSXMgd2ViY2FtIHdvcmtpbmc/JywgLTEpKTsgLy8gVE9ETzogYWRkIGVycm9yIGNvZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0dGVtcHRzLS07XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tWaWRlbygpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFRyaWVzIHRvIGF0dGFjaCB0aGUgY2FtZXJhLXN0cmVhbSB0byBhIGdpdmVuIHZpZGVvLWVsZW1lbnRcbiAqIGFuZCBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB0aGUgY29udGVudCBpcyByZWFkeVxuICogQHBhcmFtIHtPYmplY3R9IGNvbnN0cmFpbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gdmlkZW9cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5pdENhbWVyYSh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCB8IG51bGwsIGNvbnN0cmFpbnRzOiBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICBzdHJlYW1SZWYgPSBzdHJlYW07XG4gICAgaWYgKHZpZGVvKSB7XG4gICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCAndHJ1ZScpO1xuICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ211dGVkJywgJ3RydWUnKTtcbiAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsICd0cnVlJyk7IC8vIG5vdCBsaXN0ZWQgb24gTUROLi4uXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICB2aWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgKCkgPT4ge1xuICAgICAgICAgICAgdmlkZW8ucGxheSgpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJyogRXJyb3Igd2hpbGUgdHJ5aW5nIHRvIHBsYXkgdmlkZW8gc3RyZWFtOicsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3YWl0Rm9yVmlkZW8odmlkZW8pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzOiBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCk6IE1lZGlhVHJhY2tDb25zdHJhaW50cyB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHBpY2sodmlkZW9Db25zdHJhaW50cywgWyd3aWR0aCcsICdoZWlnaHQnLCAnZmFjaW5nTW9kZScsXG4gICAgICAgICdhc3BlY3RSYXRpbycsICdkZXZpY2VJZCddKTtcblxuICAgIGlmICh0eXBlb2YgdmlkZW9Db25zdHJhaW50cy5taW5Bc3BlY3RSYXRpbyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICYmIHZpZGVvQ29uc3RyYWludHMubWluQXNwZWN0UmF0aW8gPiAwKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQuYXNwZWN0UmF0aW8gPSB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvO1xuICAgICAgICBjb25zb2xlLmxvZygnV0FSTklORzogQ29uc3RyYWludCBcXCdtaW5Bc3BlY3RSYXRpb1xcJyBpcyBkZXByZWNhdGVkOyBVc2UgXFwnYXNwZWN0UmF0aW9cXCcgaW5zdGVhZCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZpZGVvQ29uc3RyYWludHMuZmFjaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBub3JtYWxpemVkLmZhY2luZ01vZGUgPSB2aWRlb0NvbnN0cmFpbnRzLmZhY2luZztcbiAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IENvbnN0cmFpbnQgXFwnZmFjaW5nXFwnIGlzIGRlcHJlY2F0ZWQuIFVzZSBcXCdmYWNpbmdNb2RlXFwnIGluc3RlYWRcXCcnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbi8vIFRPRE86ICMxOTIgSSBkb24ndCB0aGluayB0aGVyZSdzIGFueSBnb29kIHJlYXNvbiBwaWNrQ29uc3RyYWludHMgc2hvdWxkIHJldHVybiBhIFByb21pc2UsXG4vLyBJIHRoaW5rIGl0IHdhcyBqdXN0IHRoYXQgd2F5IHNvIGl0IGNvdWxkIGJlIGNoYWluZWQgdG8gb3RoZXIgZnVuY3Rpb25zIHRoYXQgZGlkIHJldHVybiBhIFByb21pc2UuXG4vLyBUaGF0J3Mgbm90IG5lY2Vzc2FyeSB3aXRoIGFzeW5jIGZ1bmN0aW9ucyBiZWluZyBhIHRoaW5nLCBzbyB0aGF0IHNob3VsZCBiZSBmaXhlZC5cbmV4cG9ydCBmdW5jdGlvbiBwaWNrQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzV2l0aERlcHJlY2F0ZWQgPSB7fSk6IFByb21pc2U8TWVkaWFTdHJlYW1Db25zdHJhaW50cz4ge1xuICAgIGNvbnN0IHZpZGVvID0gZGVwcmVjYXRlZENvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHMpO1xuXG4gICAgaWYgKHZpZGVvICYmIHZpZGVvLmRldmljZUlkICYmIHZpZGVvLmZhY2luZ01vZGUpIHtcbiAgICAgICAgZGVsZXRlIHZpZGVvLmZhY2luZ01vZGU7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBhdWRpbzogZmFsc2UsIHZpZGVvIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBlbnVtZXJhdGVWaWRlb0RldmljZXMoKTogUHJvbWlzZTxBcnJheTxNZWRpYURldmljZUluZm8+PiB7XG4gICAgY29uc3QgZGV2aWNlcyA9IGF3YWl0IGVudW1lcmF0ZURldmljZXMoKTtcbiAgICByZXR1cm4gZGV2aWNlcy5maWx0ZXIoKGRldmljZTogTWVkaWFEZXZpY2VJbmZvKSA9PiBkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlVHJhY2soKTogTWVkaWFTdHJlYW1UcmFjayB8IG51bGwge1xuICAgIGlmICghc3RyZWFtUmVmKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB0cmFja3MgPSBzdHJlYW1SZWYuZ2V0VmlkZW9UcmFja3MoKTtcbiAgICByZXR1cm4gdHJhY2tzICYmIHRyYWNrcz8ubGVuZ3RoID8gdHJhY2tzWzBdIDogbnVsbDtcbn1cblxuLyoqXG4gKiBVc2VkIGZvciBhY2Nlc3NpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGFjdGl2ZSBzdHJlYW0gdHJhY2sgYW5kIGF2YWlsYWJsZSB2aWRlbyBkZXZpY2VzLlxuICovXG5jb25zdCBRdWFnZ2FKU0NhbWVyYUFjY2VzczogQ2FtZXJhQWNjZXNzVHlwZSA9IHtcbiAgICByZXF1ZXN0ZWRWaWRlb0VsZW1lbnQ6IG51bGwsXG4gICAgYXN5bmMgcmVxdWVzdCh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCB8IG51bGwsIHZpZGVvQ29uc3RyYWludHM/OiBNZWRpYVRyYWNrQ29uc3RyYWludHNXaXRoRGVwcmVjYXRlZCk6IFByb21pc2U8YW55PiB7XG4gICAgICAgIFF1YWdnYUpTQ2FtZXJhQWNjZXNzLnJlcXVlc3RlZFZpZGVvRWxlbWVudCA9IHZpZGVvO1xuICAgICAgICBjb25zdCBuZXdDb25zdHJhaW50cyA9IGF3YWl0IHBpY2tDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKTtcbiAgICAgICAgcmV0dXJuIGluaXRDYW1lcmEodmlkZW8sIG5ld0NvbnN0cmFpbnRzKTtcbiAgICB9LFxuICAgIHJlbGVhc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbVJlZiAmJiBzdHJlYW1SZWYuZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgICAgaWYgKFF1YWdnYUpTQ2FtZXJhQWNjZXNzLnJlcXVlc3RlZFZpZGVvRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MucmVxdWVzdGVkVmlkZW9FbGVtZW50LnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tzICYmIHRyYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tzWzBdLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyZWFtUmVmID0gbnVsbDtcbiAgICAgICAgICAgICAgICBRdWFnZ2FKU0NhbWVyYUFjY2Vzcy5yZXF1ZXN0ZWRWaWRlb0VsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGVudW1lcmF0ZVZpZGVvRGV2aWNlcyxcbiAgICBnZXRBY3RpdmVTdHJlYW1MYWJlbCgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCB0cmFjayA9IGdldEFjdGl2ZVRyYWNrKCk7XG4gICAgICAgIHJldHVybiB0cmFjayA/IHRyYWNrLmxhYmVsIDogJyc7XG4gICAgfSxcbiAgICBnZXRBY3RpdmVUcmFjayxcbiAgICBhc3luYyBkaXNhYmxlVG9yY2goKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gZ2V0QWN0aXZlVHJhY2soKTtcbiAgICAgICAgLy8gVE9ETzogc2hvdWxkIHdlIGFjcXVpcmUgY2FtZXJhIGFjY2VzcyBldmVuIGlmIHRoZXJlJ3Mgbm8gY3VycmVudCBjYW1lcmEgb3Blbj9cbiAgICAgICAgLy8gVE9ETzogd2hhdCBoYXBwZW5zIG9uIGlPUyBvciBhbm90aGVyIGRldmljZSB3aGVyZSB0b3JjaCBpc24ndCBzdXBwb3J0ZWQgYXQgYWxsPyBTaG91bGQgd2UgdGhyb3cgYW4gZXJyb3I/XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAvLyB0eXBlc2NyaXB0IGRvZXNuJ3Qga25vdyB0aGUgdG9yY2ggcHJvcGVydHlcbiAgICAgICAgICAgIGF3YWl0IHRyYWNrLmFwcGx5Q29uc3RyYWludHMoeyBhZHZhbmNlZDogW3sgdG9yY2g6IGZhbHNlIH1dIH0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBlbmFibGVUb3JjaCgpIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBnZXRBY3RpdmVUcmFjaygpO1xuICAgICAgICAvLyBUT0RPOiBzaG91bGQgd2UgYWNxdWlyZSBjYW1lcmEgYWNjZXNzIGV2ZW4gaWYgdGhlcmUncyBubyBjdXJyZW50IGNhbWVyYSBvcGVuP1xuICAgICAgICAvLyBUT0RPOiB3aGF0IGhhcHBlbnMgb24gaU9TIG9yIGFub3RoZXIgZGV2aWNlIHdoZXJlIHRvcmNoIGlzbid0IHN1cHBvcnRlZCBhdCBhbGw/IFNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvcj9cbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIC8vIHR5cGVzY3JpcHQgZG9lc24ndCBrbm93IHRoZSB0b3JjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgYXdhaXQgdHJhY2suYXBwbHlDb25zdHJhaW50cyh7IGFkdmFuY2VkOiBbeyB0b3JjaDogdHJ1ZSB9XSB9KTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FKU0NhbWVyYUFjY2VzcztcbiIsImltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5pbXBvcnQge1xuICAgIFF1YWdnYUpTQ29kZVJlc3VsdCxcbiAgICBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvcixcbiAgICBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvckZpbHRlckZ1bmN0aW9uLFxuICAgIFhZU2l6ZSxcbiAgICBRdWFnZ2FJbWFnZURhdGEsXG59IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5mdW5jdGlvbiBjb250YWlucyhjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQsIGxpc3Q6IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gbGlzdCAmJiBsaXN0LnNvbWUoKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGl0ZW0pIGFzIEFycmF5PGtleW9mIFF1YWdnYUpTQ29kZVJlc3VsdD47XG4gICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KChrZXkpID0+IGl0ZW1ba2V5XSA9PT0gY29kZVJlc3VsdFtrZXldKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcGFzc2VzRmlsdGVyKFxuICAgIGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCxcbiAgICBmaWx0ZXI6IFF1YWdnYUpTUmVzdWx0Q29sbGVjdG9yRmlsdGVyRnVuY3Rpb24gfCB1bmRlZmluZWQsXG4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyA/IGZpbHRlcihjb2RlUmVzdWx0KSA6IHRydWU7XG59XG5cbmludGVyZmFjZSBSZXN1bHRDb2xsZWN0b3Ige1xuICAgIGFkZFJlc3VsdDogKGRhdGE6IFF1YWdnYUltYWdlRGF0YSwgaW1hZ2VTaXplOiBYWVNpemUsIGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCkgPT4gdm9pZDtcbiAgICBnZXRSZXN1bHRzOiAoKSA9PiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgY3JlYXRlKGNvbmZpZzogUXVhZ2dhSlNSZXN1bHRDb2xsZWN0b3IpOiBSZXN1bHRDb2xsZWN0b3Ige1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykgYXMgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICAgICAgICBjb25zdCByZXN1bHRzOiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+ID0gW107XG4gICAgICAgIGxldCBjYXBhY2l0eSA9IGNvbmZpZy5jYXBhY2l0eSA/PyAyMDtcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IGNvbmZpZy5jYXB0dXJlID09PSB0cnVlO1xuXG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoZXNDb25zdHJhaW50cyhjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQpOiBib29sZWFuIHtcbiAgICAgICAgICAgIHJldHVybiAhIWNhcGFjaXR5XG4gICAgICAgICAgICAgICAgJiYgY29kZVJlc3VsdFxuICAgICAgICAgICAgICAgICYmICFjb250YWlucyhjb2RlUmVzdWx0LCBjb25maWcuYmxhY2tsaXN0IGFzIEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4pXG4gICAgICAgICAgICAgICAgJiYgcGFzc2VzRmlsdGVyKGNvZGVSZXN1bHQsIGNvbmZpZy5maWx0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZFJlc3VsdChkYXRhOiBRdWFnZ2FJbWFnZURhdGEsIGltYWdlU2l6ZTogWFlTaXplLCBjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQpOiB2b2lkIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQ6IGFueSA9IHsgfTsgLy8gdGhpcyBpcyAnYW55JyB0byBhdm9pZCBoYXZpbmcgdG8gY29uc3RydWN0IGEgd2hvbGUgUXVhZ2dhSlNDb2RlUmVzdWx0IDp8XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNDb25zdHJhaW50cyhjb2RlUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICBjYXBhY2l0eS0tO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29kZVJlc3VsdCA9IGNvZGVSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWFnZVNpemUueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZVNpemUueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd0ltYWdlKGRhdGEsIGltYWdlU2l6ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5mcmFtZSA9IGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UmVzdWx0cygpOiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCBEZXZDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0ge1xuICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgIG5hbWU6ICdMaXZlJyxcbiAgICAgICAgdHlwZTogJ0xpdmVTdHJlYW0nLFxuICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgIGhlaWdodDogNDgwLFxuICAgICAgICAgICAgLy8gYXNwZWN0UmF0aW86IDY0MC80ODAsIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLCAvLyBvciB1c2VyXG4gICAgICAgICAgICAvLyBkZXZpY2VJZDogXCIzODc0NTk4MzQ1NzM4NzU5ODM3NTk4Mzc1OTgzNFwiXG4gICAgICAgIH0sXG4gICAgICAgIGFyZWE6IHtcbiAgICAgICAgICAgIHRvcDogJzAlJyxcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxuICAgICAgICAgICAgbGVmdDogJzAlJyxcbiAgICAgICAgICAgIGJvdHRvbTogJzAlJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlQ2hhbm5lbDogZmFsc2UsIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcbiAgICB9LFxuICAgIGxvY2F0ZTogdHJ1ZSxcbiAgICBudW1PZldvcmtlcnM6IDAsXG4gICAgZGVjb2Rlcjoge1xuICAgICAgICByZWFkZXJzOiBbXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJyxcbiAgICAgICAgXSxcbiAgICAgICAgZGVidWc6IHtcbiAgICAgICAgICAgIGRyYXdCb3VuZGluZ0JveDogZmFsc2UsXG4gICAgICAgICAgICBzaG93RnJlcXVlbmN5OiBmYWxzZSxcbiAgICAgICAgICAgIGRyYXdTY2FubGluZTogZmFsc2UsXG4gICAgICAgICAgICBzaG93UGF0dGVybjogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBsb2NhdG9yOiB7XG4gICAgICAgIGhhbGZTYW1wbGU6IHRydWUsXG4gICAgICAgIHBhdGNoU2l6ZTogJ21lZGl1bScsIC8vIHgtc21hbGwsIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXG4gICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgICBzaG93Q2FudmFzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dQYXRjaGVzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dGb3VuZFBhdGNoZXM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1NrZWxldG9uOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1BhdGNoTGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dSZW1haW5pbmdQYXRjaExhYmVsczogZmFsc2UsXG4gICAgICAgICAgICBib3hGcm9tUGF0Y2hlczoge1xuICAgICAgICAgICAgICAgIHNob3dUcmFuc2Zvcm1lZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd1RyYW5zZm9ybWVkQm94OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93QkI6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgRGV2Q29uZmlnO1xuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuY29uc3QgTm9kZUNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QgPSB7XG4gICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgdHlwZTogJ0ltYWdlU3RyZWFtJyxcbiAgICAgICAgc2VxdWVuY2U6IGZhbHNlLFxuICAgICAgICBzaXplOiA4MDAsXG4gICAgICAgIGFyZWE6IHtcbiAgICAgICAgICAgIHRvcDogJzAlJyxcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxuICAgICAgICAgICAgbGVmdDogJzAlJyxcbiAgICAgICAgICAgIGJvdHRvbTogJzAlJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlQ2hhbm5lbDogZmFsc2UsIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcbiAgICB9LFxuICAgIGxvY2F0ZTogdHJ1ZSxcbiAgICBudW1PZldvcmtlcnM6IDAsXG4gICAgZGVjb2Rlcjoge1xuICAgICAgICByZWFkZXJzOiBbXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGxvY2F0b3I6IHtcbiAgICAgICAgaGFsZlNhbXBsZTogdHJ1ZSxcbiAgICAgICAgcGF0Y2hTaXplOiAnbWVkaXVtJywgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgTm9kZUNvbmZpZztcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmNvbnN0IFByb2RDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0ge1xuICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgIG5hbWU6ICdMaXZlJyxcbiAgICAgICAgdHlwZTogJ0xpdmVTdHJlYW0nLFxuICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgIGhlaWdodDogNDgwLFxuICAgICAgICAgICAgLy8gYXNwZWN0UmF0aW86IDY0MC80ODAsIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLCAvLyBvciB1c2VyXG4gICAgICAgICAgICAvLyBkZXZpY2VJZDogXCIzODc0NTk4MzQ1NzM4NzU5ODM3NTk4Mzc1OTgzNFwiXG4gICAgICAgIH0sXG4gICAgICAgIGFyZWE6IHtcbiAgICAgICAgICAgIHRvcDogJzAlJyxcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxuICAgICAgICAgICAgbGVmdDogJzAlJyxcbiAgICAgICAgICAgIGJvdHRvbTogJzAlJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlQ2hhbm5lbDogZmFsc2UsIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcbiAgICB9LFxuICAgIGxvY2F0ZTogdHJ1ZSxcbiAgICBudW1PZldvcmtlcnM6IDQsXG4gICAgZGVjb2Rlcjoge1xuICAgICAgICByZWFkZXJzOiBbXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGxvY2F0b3I6IHtcbiAgICAgICAgaGFsZlNhbXBsZTogdHJ1ZSxcbiAgICAgICAgcGF0Y2hTaXplOiAnbWVkaXVtJywgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvZENvbmZpZztcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5pbXBvcnQgRGV2Q29uZmlnIGZyb20gJy4vY29uZmlnLmRldic7XG5pbXBvcnQgTm9kZUNvbmZpZyBmcm9tICcuL2NvbmZpZy5ub2RlJztcbmltcG9ydCBQcm9kQ29uZmlnIGZyb20gJy4vY29uZmlnLnByb2QnO1xuXG4vLyBAdHMtaWdub3JlIC8vIFRPRE86IHRoaXMgcHJvZHVjZXMgYSBiaXphcnJlIHR5cGVzY3JpcHQgZXJyb3Jcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuY29uc3QgUXVhZ2dhQ29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IEVOVi5kZXZlbG9wbWVudFxuICAgID8gRGV2Q29uZmlnXG4gICAgOiBFTlYubm9kZVxuICAgICAgICA/IE5vZGVDb25maWdcbiAgICAgICAgOiBQcm9kQ29uZmlnO1xuXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FDb25maWc7XG4iLCIvLyBOT1RFIEZPUiBBTllPTkUgSU4gSEVSRSBJTiBUSEUgRlVUVVJFOlxuLy8gd2VicGFjay5jb25maWcuanMgcmVwbGFjZXMgdGhlIGZyYW1lX2dyYWJiZXIgbW9kdWxlIHdpdGggVEhJUyBtb2R1bGUgd2hlbiBpdCBpcyBidWlsZGluZyBmb3IgYSBCcm93c2VyIGVudmlyb25tZW50LlxuXG5pbXBvcnQge1xuICAgIGltYWdlUmVmLFxuICAgIGdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEsXG4gICAgY29tcHV0ZUdyYXksXG59IGZyb20gJy4uL2NvbW1vbi9jdl91dGlscyc7XG5cbmNvbnN0IFRPX1JBRElBTlMgPSBNYXRoLlBJIC8gMTgwO1xuXG5mdW5jdGlvbiBhZGp1c3RDYW52YXNTaXplKGNhbnZhcywgdGFyZ2V0U2l6ZSkge1xuICAgIGlmIChjYW52YXMud2lkdGggIT09IHRhcmdldFNpemUueCkge1xuICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnV0FSTklORzogY2FudmFzLXNpemUgbmVlZHMgdG8gYmUgYWRqdXN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMud2lkdGggPSB0YXJnZXRTaXplLng7XG4gICAgfVxuICAgIGlmIChjYW52YXMuaGVpZ2h0ICE9PSB0YXJnZXRTaXplLnkpIHtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IGNhbnZhcy1zaXplIG5lZWRzIHRvIGJlIGFkanVzdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRhcmdldFNpemUueTtcbiAgICB9XG59XG5cbmNvbnN0IEZyYW1lR3JhYmJlciA9IHt9O1xuXG5GcmFtZUdyYWJiZXIuY3JlYXRlID0gZnVuY3Rpb24gKGlucHV0U3RyZWFtLCBjYW52YXMpIHtcbiAgICBjb25zdCBfdGhhdCA9IHt9O1xuICAgIGNvbnN0IF9zdHJlYW1Db25maWcgPSBpbnB1dFN0cmVhbS5nZXRDb25maWcoKTtcbiAgICBjb25zdCBfdmlkZW9TaXplID0gaW1hZ2VSZWYoaW5wdXRTdHJlYW0uZ2V0UmVhbFdpZHRoKCksIGlucHV0U3RyZWFtLmdldFJlYWxIZWlnaHQoKSk7XG4gICAgY29uc3QgX2NhbnZhc1NpemUgPSBpbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCk7XG4gICAgY29uc3QgX3NpemUgPSBpbWFnZVJlZihpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSk7XG4gICAgY29uc3QgdG9wUmlnaHQgPSBpbnB1dFN0cmVhbS5nZXRUb3BSaWdodCgpO1xuICAgIGNvbnN0IF9zeCA9IHRvcFJpZ2h0Lng7XG4gICAgY29uc3QgX3N5ID0gdG9wUmlnaHQueTtcbiAgICBsZXQgX2NhbnZhcztcbiAgICBsZXQgX2N0eCA9IG51bGw7XG4gICAgbGV0IF9kYXRhID0gbnVsbDtcblxuICAgIF9jYW52YXMgPSBjYW52YXMgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgX2NhbnZhcy53aWR0aCA9IF9jYW52YXNTaXplLng7XG4gICAgX2NhbnZhcy5oZWlnaHQgPSBfY2FudmFzU2l6ZS55O1xuICAgIF9jdHggPSBfY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgX2RhdGEgPSBuZXcgVWludDhBcnJheShfc2l6ZS54ICogX3NpemUueSk7XG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICBjb25zb2xlLmxvZygnRnJhbWVHcmFiYmVyJywgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgc2l6ZTogX3NpemUsXG4gICAgICAgICAgICB0b3BSaWdodCxcbiAgICAgICAgICAgIHZpZGVvU2l6ZTogX3ZpZGVvU2l6ZSxcbiAgICAgICAgICAgIGNhbnZhc1NpemU6IF9jYW52YXNTaXplLFxuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyB0aGUgZ2l2ZW4gYXJyYXkgYXMgZnJhbWUtYnVmZmVyXG4gICAgICovXG4gICAgX3RoYXQuYXR0YWNoRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIF9kYXRhID0gZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdXNlZCBmcmFtZS1idWZmZXJcbiAgICAgKi9cbiAgICBfdGhhdC5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBmcmFtZSBmcm9tIHRoZSBpbnB1dC1zdHJlYW0gYW5kIHB1dHMgaW50byB0aGUgZnJhbWUtYnVmZmVyLlxuICAgICAqIFRoZSBpbWFnZS1kYXRhIGlzIGNvbnZlcnRlZCB0byBncmF5LXNjYWxlIGFuZCB0aGVuIGhhbGYtc2FtcGxlZCBpZiBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIF90aGF0LmdyYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRvSGFsZlNhbXBsZSA9IF9zdHJlYW1Db25maWcuaGFsZlNhbXBsZTtcbiAgICAgICAgY29uc3QgZnJhbWUgPSBpbnB1dFN0cmVhbS5nZXRGcmFtZSgpO1xuICAgICAgICBsZXQgZHJhd2FibGUgPSBmcmFtZTtcbiAgICAgICAgbGV0IGRyYXdBbmdsZSA9IDA7XG4gICAgICAgIGxldCBjdHhEYXRhO1xuICAgICAgICBpZiAoZHJhd2FibGUpIHtcbiAgICAgICAgICAgIGFkanVzdENhbnZhc1NpemUoX2NhbnZhcywgX2NhbnZhc1NpemUpO1xuICAgICAgICAgICAgaWYgKF9zdHJlYW1Db25maWcudHlwZSA9PT0gJ0ltYWdlU3RyZWFtJykge1xuICAgICAgICAgICAgICAgIGRyYXdhYmxlID0gZnJhbWUuaW1nO1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZS50YWdzICYmIGZyYW1lLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmcmFtZS50YWdzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0FuZ2xlID0gOTAgKiBUT19SQURJQU5TO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdBbmdsZSA9IC05MCAqIFRPX1JBRElBTlM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkcmF3QW5nbGUgIT09IDApIHtcbiAgICAgICAgICAgICAgICBfY3R4LnRyYW5zbGF0ZShfY2FudmFzU2l6ZS54IC8gMiwgX2NhbnZhc1NpemUueSAvIDIpO1xuICAgICAgICAgICAgICAgIF9jdHgucm90YXRlKGRyYXdBbmdsZSk7XG4gICAgICAgICAgICAgICAgX2N0eC5kcmF3SW1hZ2UoZHJhd2FibGUsIC1fY2FudmFzU2l6ZS55IC8gMiwgLV9jYW52YXNTaXplLnggLyAyLCBfY2FudmFzU2l6ZS55LCBfY2FudmFzU2l6ZS54KTtcbiAgICAgICAgICAgICAgICBfY3R4LnJvdGF0ZSgtZHJhd0FuZ2xlKTtcbiAgICAgICAgICAgICAgICBfY3R4LnRyYW5zbGF0ZSgtX2NhbnZhc1NpemUueCAvIDIsIC1fY2FudmFzU2l6ZS55IC8gMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9jdHguZHJhd0ltYWdlKGRyYXdhYmxlLCAwLCAwLCBfY2FudmFzU2l6ZS54LCBfY2FudmFzU2l6ZS55KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4RGF0YSA9IF9jdHguZ2V0SW1hZ2VEYXRhKF9zeCwgX3N5LCBfc2l6ZS54LCBfc2l6ZS55KS5kYXRhO1xuICAgICAgICAgICAgaWYgKGRvSGFsZlNhbXBsZSkge1xuICAgICAgICAgICAgICAgIGdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEoY3R4RGF0YSwgX3NpemUsIF9kYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgX2RhdGEsIF9zdHJlYW1Db25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBfdGhhdC5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3NpemU7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhhdDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZyYW1lR3JhYmJlcjtcbiIsIi8vIE5PVEU6IChTT01FIE9GKSBUSElTIElTIEJST1dTRVIgT05MWSBDT0RFLiAgTm9kZSBkb2VzIG5vdCBoYXZlICdhdG9iJyBidWlsdCBpbiwgbm9yIFhNTEh0dHBSZXF1ZXN0LlxuLy8gSG93IGV4YWN0bHkgaXMgdGhpcyBzZXQgb2YgZnVuY3Rpb25zIHVzZWQgaW4gUXVhZ2dhPyBEbyB3ZSBuZWVkIHRoZSBicm93c2VyIHNwZWNpZmljIGNvZGU/IERvIHdlXG4vLyBuZWVkIHRvIHBvcnQgYW55IHBhcnQgb2YgdGhpcyB0aGF0IGRvZXNuJ3Qgd29yayBpbiBOb2RlIHRvIG5vZGU/XG5cbi8vIFRhZ3Mgc2NyYXBlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9leGlmLWpzL2V4aWYtanNcbmNvbnN0IEV4aWZUYWdzID0geyAweDAxMTI6ICdvcmllbnRhdGlvbicgfTtcbmV4cG9ydCBjb25zdCBBdmFpbGFibGVUYWdzID0gT2JqZWN0LmtleXMoRXhpZlRhZ3MpLm1hcCgoa2V5KSA9PiBFeGlmVGFnc1trZXldKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRUYWdzSW5PYmplY3RVUkwoc3JjLCB0YWdzID0gQXZhaWxhYmxlVGFncykge1xuICAgIGlmICgvXmJsb2I6L2kudGVzdChzcmMpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3RVUkxUb0Jsb2Ioc3JjKVxuICAgICAgICAgICAgLnRoZW4ocmVhZFRvQnVmZmVyKVxuICAgICAgICAgICAgLnRoZW4oKGJ1ZmZlcikgPT4gZmluZFRhZ3NJbkJ1ZmZlcihidWZmZXIsIHRhZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFRvQXJyYXlCdWZmZXIoZGF0YVVybCkge1xuICAgIGNvbnN0IGJhc2U2NCA9IGRhdGFVcmwucmVwbGFjZSgvXmRhdGE6KFteO10rKTtiYXNlNjQsL2dtaSwgJycpO1xuICAgIGNvbnN0IGJpbmFyeSA9IGF0b2IoYmFzZTY0KTtcbiAgICBjb25zdCBsZW4gPSBiaW5hcnkubGVuZ3RoO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihsZW4pO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2aWV3W2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIHJlYWRUb0J1ZmZlcihibG9iKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBvYmplY3RVUkxUb0Jsb2IodXJsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICBodHRwLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIGh0dHAucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgICBodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChodHRwLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUgJiYgKGh0dHAuc3RhdHVzID09PSAyMDAgfHwgaHR0cC5zdGF0dXMgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaHR0cC5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICBodHRwLnNlbmQoKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRUYWdzSW5CdWZmZXIoZmlsZSwgc2VsZWN0ZWRUYWdzID0gQXZhaWxhYmxlVGFncykge1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGZpbGUpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGZpbGUuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBleGlmVGFncyA9IHNlbGVjdGVkVGFncy5yZWR1Y2UoKHJlc3VsdCwgc2VsZWN0ZWRUYWcpID0+IHtcbiAgICAgICAgY29uc3QgZXhpZlRhZyA9IE9iamVjdC5rZXlzKEV4aWZUYWdzKS5maWx0ZXIoKHRhZykgPT4gRXhpZlRhZ3NbdGFnXSA9PT0gc2VsZWN0ZWRUYWcpWzBdO1xuICAgICAgICBpZiAoZXhpZlRhZykge1xuICAgICAgICAgICAgcmVzdWx0W2V4aWZUYWddID0gc2VsZWN0ZWRUYWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG4gICAgbGV0IG9mZnNldCA9IDI7XG4gICAgbGV0IG1hcmtlcjtcblxuICAgIGlmICgoZGF0YVZpZXcuZ2V0VWludDgoMCkgIT09IDB4RkYpIHx8IChkYXRhVmlldy5nZXRVaW50OCgxKSAhPT0gMHhEOCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCkgIT09IDB4RkYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtlciA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIDEpO1xuICAgICAgICBpZiAobWFya2VyID09PSAweEUxKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEVYSUZEYXRhKGRhdGFWaWV3LCBvZmZzZXQgKyA0LCBleGlmVGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IDIgKyBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZWFkRVhJRkRhdGEoZmlsZSwgc3RhcnQsIGV4aWZUYWdzKSB7XG4gICAgaWYgKGdldFN0cmluZ0Zyb21CdWZmZXIoZmlsZSwgc3RhcnQsIDQpICE9PSAnRXhpZicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHRpZmZPZmZzZXQgPSBzdGFydCArIDY7XG4gICAgbGV0IGJpZ0VuZDtcblxuICAgIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0KSA9PT0gMHg0OTQ5KSB7XG4gICAgICAgIGJpZ0VuZCA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZmlsZS5nZXRVaW50MTYodGlmZk9mZnNldCkgPT09IDB4NEQ0RCkge1xuICAgICAgICBiaWdFbmQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZmlsZS5nZXRVaW50MTYodGlmZk9mZnNldCArIDIsICFiaWdFbmQpICE9PSAweDAwMkEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0SUZET2Zmc2V0ID0gZmlsZS5nZXRVaW50MzIodGlmZk9mZnNldCArIDQsICFiaWdFbmQpO1xuICAgIGlmIChmaXJzdElGRE9mZnNldCA8IDB4MDAwMDAwMDgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHRhZ3MgPSByZWFkVGFncyhmaWxlLCB0aWZmT2Zmc2V0LCB0aWZmT2Zmc2V0ICsgZmlyc3RJRkRPZmZzZXQsIGV4aWZUYWdzLCBiaWdFbmQpO1xuICAgIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiByZWFkVGFncyhmaWxlLCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBzdHJpbmdzLCBiaWdFbmQpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gZmlsZS5nZXRVaW50MTYoZGlyU3RhcnQsICFiaWdFbmQpO1xuICAgIGNvbnN0IHRhZ3MgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5T2Zmc2V0ID0gZGlyU3RhcnQgKyBpICogMTIgKyAyO1xuICAgICAgICBjb25zdCB0YWcgPSBzdHJpbmdzW2ZpbGUuZ2V0VWludDE2KGVudHJ5T2Zmc2V0LCAhYmlnRW5kKV07XG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIHRhZ3NbdGFnXSA9IHJlYWRUYWdWYWx1ZShmaWxlLCBlbnRyeU9mZnNldCwgdGlmZlN0YXJ0LCBkaXJTdGFydCwgYmlnRW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFncztcbn1cblxuZnVuY3Rpb24gcmVhZFRhZ1ZhbHVlKGZpbGUsIGVudHJ5T2Zmc2V0LCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBiaWdFbmQpIHtcbiAgICBjb25zdCB0eXBlID0gZmlsZS5nZXRVaW50MTYoZW50cnlPZmZzZXQgKyAyLCAhYmlnRW5kKTtcbiAgICBjb25zdCBudW1WYWx1ZXMgPSBmaWxlLmdldFVpbnQzMihlbnRyeU9mZnNldCArIDQsICFiaWdFbmQpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGlmIChudW1WYWx1ZXMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZS5nZXRVaW50MTYoZW50cnlPZmZzZXQgKyA4LCAhYmlnRW5kKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0U3RyaW5nRnJvbUJ1ZmZlcihidWZmZXIsIHN0YXJ0LCBsZW5ndGgpIHtcbiAgICBsZXQgb3V0c3RyID0gJyc7XG4gICAgZm9yIChsZXQgbiA9IHN0YXJ0OyBuIDwgc3RhcnQgKyBsZW5ndGg7IG4rKykge1xuICAgICAgICBvdXRzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXIuZ2V0VWludDgobikpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0c3RyO1xufVxuIiwiaW1wb3J0IHsgZmluZFRhZ3NJbk9iamVjdFVSTCB9IGZyb20gJy4vZXhpZl9oZWxwZXInO1xuXG5jb25zdCBJbWFnZUxvYWRlciA9IHt9O1xuSW1hZ2VMb2FkZXIubG9hZCA9IGZ1bmN0aW9uIChkaXJlY3RvcnksIGNhbGxiYWNrLCBvZmZzZXQsIHNpemUsIHNlcXVlbmNlKSB7XG4gICAgY29uc3QgaHRtbEltYWdlc1NyY0FycmF5ID0gbmV3IEFycmF5KHNpemUpO1xuICAgIGNvbnN0IGh0bWxJbWFnZXNBcnJheSA9IG5ldyBBcnJheShodG1sSW1hZ2VzU3JjQXJyYXkubGVuZ3RoKTtcbiAgICBsZXQgaTtcbiAgICBsZXQgaW1nO1xuICAgIGxldCBudW07XG5cbiAgICBpZiAoc2VxdWVuY2UgPT09IGZhbHNlKSB7XG4gICAgICAgIGh0bWxJbWFnZXNTcmNBcnJheVswXSA9IGRpcmVjdG9yeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBudW0gPSAob2Zmc2V0ICsgaSk7XG4gICAgICAgICAgICBodG1sSW1hZ2VzU3JjQXJyYXlbaV0gPSBgJHtkaXJlY3Rvcnl9aW1hZ2UtJHsoYDAwJHtudW19YCkuc2xpY2UoLTMpfS5qcGdgO1xuICAgICAgICB9XG4gICAgfVxuICAgIGh0bWxJbWFnZXNBcnJheS5ub3RMb2FkZWQgPSBbXTtcbiAgICBodG1sSW1hZ2VzQXJyYXkuYWRkSW1hZ2UgPSBmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgaHRtbEltYWdlc0FycmF5Lm5vdExvYWRlZC5wdXNoKGltYWdlKTtcbiAgICB9O1xuICAgIGh0bWxJbWFnZXNBcnJheS5sb2FkZWQgPSBmdW5jdGlvbiAobG9hZGVkSW1nKSB7XG4gICAgICAgIGNvbnN0IG5vdGxvYWRlZEltZ3MgPSBodG1sSW1hZ2VzQXJyYXkubm90TG9hZGVkO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG5vdGxvYWRlZEltZ3MubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICAgIGlmIChub3Rsb2FkZWRJbWdzW3hdID09PSBsb2FkZWRJbWcpIHtcbiAgICAgICAgICAgICAgICBub3Rsb2FkZWRJbWdzLnNwbGljZSh4LCAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGg7IHkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWdOYW1lID0gaHRtbEltYWdlc1NyY0FycmF5W3ldLnN1YnN0cihodG1sSW1hZ2VzU3JjQXJyYXlbeV0ubGFzdEluZGV4T2YoJy8nKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2FkZWRJbWcuc3JjLmxhc3RJbmRleE9mKGltZ05hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbEltYWdlc0FycmF5W3ldID0geyBpbWc6IGxvYWRlZEltZyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vdGxvYWRlZEltZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ltYWdlcyBsb2FkZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXF1ZW5jZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBmaW5kVGFnc0luT2JqZWN0VVJMKGRpcmVjdG9yeSwgWydvcmllbnRhdGlvbiddKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigodGFncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbEltYWdlc0FycmF5WzBdLnRhZ3MgPSB0YWdzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soaHRtbEltYWdlc0FycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soaHRtbEltYWdlc0FycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGh0bWxJbWFnZXNBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaHRtbEltYWdlc0FycmF5LmFkZEltYWdlKGltZyk7XG4gICAgICAgIGFkZE9ubG9hZEhhbmRsZXIoaW1nLCBodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICBpbWcuc3JjID0gaHRtbEltYWdlc1NyY0FycmF5W2ldO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGFkZE9ubG9hZEhhbmRsZXIoaW1nLCBodG1sSW1hZ2VzQXJyYXkpIHtcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkubG9hZGVkKHRoaXMpO1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IChJbWFnZUxvYWRlcik7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cbmltcG9ydCBJbWFnZUxvYWRlciBmcm9tICcuLi9pbWFnZV9sb2FkZXInO1xuaW1wb3J0IHsgWFlTaXplLCBQb2ludCB9IGZyb20gJy4uLy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuaW1wb3J0IHsgSW5wdXRTdHJlYW1GYWN0b3J5LCBJbnB1dFN0cmVhbSwgRXZlbnRIYW5kbGVyTGlzdCB9IGZyb20gJy4vaW5wdXRfc3RyZWFtLmQnO1xuXG5jb25zdCBpbnB1dFN0cmVhbUZhY3Rvcnk6IElucHV0U3RyZWFtRmFjdG9yeSA9IHtcbiAgICBjcmVhdGVWaWRlb1N0cmVhbSh2aWRlbyk6IElucHV0U3RyZWFtIHtcbiAgICAgICAgbGV0IF9jb25maWc6IHsgc2l6ZTogbnVtYmVyOyB0eXBlOiBzdHJpbmcgfSB8IG51bGwgPSBudWxsO1xuICAgICAgICBjb25zdCBfZXZlbnROYW1lcyA9IFsnY2FucmVjb3JkJywgJ2VuZGVkJ107XG4gICAgICAgIGNvbnN0IF9ldmVudEhhbmRsZXJzOiBFdmVudEhhbmRsZXJMaXN0ID0ge307XG4gICAgICAgIGxldCBfY2FsY3VsYXRlZFdpZHRoOiBudW1iZXI7XG4gICAgICAgIGxldCBfY2FsY3VsYXRlZEhlaWdodDogbnVtYmVyO1xuICAgICAgICBjb25zdCBfdG9wUmlnaHQ6IFBvaW50ID0geyB4OiAwLCB5OiAwLCB0eXBlOiAnUG9pbnQnIH07XG4gICAgICAgIGNvbnN0IF9jYW52YXNTaXplOiBYWVNpemUgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdYWVNpemUnIH07XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdFNpemUoKTogdm9pZCB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHZpZGVvLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB2aWRlby52aWRlb0hlaWdodDtcblxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBfY2FsY3VsYXRlZFdpZHRoID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IF9jb25maWcuc2l6ZSA6IE1hdGguZmxvb3IoKHdpZHRoIC8gaGVpZ2h0KSAqIF9jb25maWcuc2l6ZSkgOiB3aWR0aDtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgX2NhbGN1bGF0ZWRIZWlnaHQgPSBfY29uZmlnPy5zaXplID8gd2lkdGggLyBoZWlnaHQgPiAxID8gTWF0aC5mbG9vcigoaGVpZ2h0IC8gd2lkdGgpICogX2NvbmZpZy5zaXplKSA6IF9jb25maWcuc2l6ZSA6IGhlaWdodDtcblxuICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IF9jYWxjdWxhdGVkV2lkdGg7XG4gICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gX2NhbGN1bGF0ZWRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtID0ge1xuICAgICAgICAgICAgZ2V0UmVhbFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlby52aWRlb1dpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVhbEhlaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW8udmlkZW9IZWlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbGN1bGF0ZWRIZWlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRXaWR0aCh3aWR0aCkge1xuICAgICAgICAgICAgICAgIF9jYWxjdWxhdGVkV2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBfY2FsY3VsYXRlZEhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldElucHV0U3RyZWFtKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBfY29uZmlnID0gY29uZmlnO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc3JjJywgKHR5cGVvZiBjb25maWcuc3JjICE9PSAndW5kZWZpbmVkJykgPyBjb25maWcuc3JjIDogJycpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZW5kZWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvLmVuZGVkO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Q29uZmlnKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGF1c2UoKSB7XG4gICAgICAgICAgICAgICAgdmlkZW8ucGF1c2UoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBsYXkoKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xuICAgICAgICAgICAgICAgIHZpZGVvLnBsYXkoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldEN1cnJlbnRUaW1lKHRpbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2NvbmZpZz8udHlwZSAhPT0gJ0xpdmVTdHJlYW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdjdXJyZW50VGltZScsIHRpbWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZiwgYm9vbCkge1xuICAgICAgICAgICAgICAgIGlmIChfZXZlbnROYW1lcy5pbmRleE9mKGV2ZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZXZlbnRIYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XS5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGYsIGJvb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgICAgICAgICBfZXZlbnROYW1lcy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBfZXZlbnRIYW5kbGVyc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0cmlnZ2VyKGV2ZW50TmFtZSwgYXJncykge1xuICAgICAgICAgICAgICAgIGxldCBqO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnY2FucmVjb3JkJykge1xuICAgICAgICAgICAgICAgICAgICBpbml0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzW2pdLmFwcGx5KGlucHV0U3RyZWFtLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldFRvcFJpZ2h0KHRvcFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnggPSB0b3BSaWdodC54O1xuICAgICAgICAgICAgICAgIF90b3BSaWdodC55ID0gdG9wUmlnaHQueTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFRvcFJpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdG9wUmlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDYW52YXNTaXplKHNpemUpIHtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS54ID0gc2l6ZS54O1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnkgPSBzaXplLnk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRDYW52YXNTaXplKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FudmFzU2l6ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEZyYW1lKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlbztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpbnB1dFN0cmVhbTtcbiAgICB9LFxuICAgIGNyZWF0ZUxpdmVTdHJlYW0odmlkZW8pOiBJbnB1dFN0cmVhbSB7XG4gICAgICAgIGlmICh2aWRlbykge1xuICAgICAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKCdhdXRvcGxheScsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhhdCA9IGlucHV0U3RyZWFtRmFjdG9yeS5jcmVhdGVWaWRlb1N0cmVhbSh2aWRlbyk7XG4gICAgICAgIHRoYXQuZW5kZWQgPSBmdW5jdGlvbiBlbmRlZCgpOiBmYWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgIH0sXG4gICAgY3JlYXRlSW1hZ2VTdHJlYW0oKTogSW5wdXRTdHJlYW0ge1xuICAgICAgICBsZXQgX2NvbmZpZzogeyBzaXplOiBudW1iZXI7IHNlcXVlbmNlOiBhbnkgfSB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICAgIGxldCBoZWlnaHQgPSAwO1xuICAgICAgICBsZXQgZnJhbWVJZHggPSAwO1xuICAgICAgICBsZXQgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgaW1nQXJyYXk6IGFueVtdIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gMTtcbiAgICAgICAgbGV0IGJhc2VVcmw6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbGN1bGF0ZWRXaWR0aDogbnVtYmVyO1xuICAgICAgICBsZXQgY2FsY3VsYXRlZEhlaWdodDogbnVtYmVyO1xuICAgICAgICBjb25zdCBfZXZlbnROYW1lcyA9IFsnY2FucmVjb3JkJywgJ2VuZGVkJ107XG4gICAgICAgIGNvbnN0IF9ldmVudEhhbmRsZXJzOiBFdmVudEhhbmRsZXJMaXN0ID0ge307XG4gICAgICAgIGNvbnN0IF90b3BSaWdodDogUG9pbnQgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdQb2ludCcgfTtcbiAgICAgICAgY29uc3QgX2NhbnZhc1NpemU6IFhZU2l6ZSA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1hZU2l6ZScgfTtcblxuICAgICAgICBmdW5jdGlvbiBsb2FkSW1hZ2VzKCk6IHZvaWQge1xuICAgICAgICAgICAgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBJbWFnZUxvYWRlci5sb2FkKGJhc2VVcmwsIChpbWdzOiBBcnJheTx7IHRhZ3M6IGFueTsgaW1nOiBIVE1MSW1hZ2VFbGVtZW50fT4pID0+IHtcbiAgICAgICAgICAgICAgICBpbWdBcnJheSA9IGltZ3M7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIGlmIChpbWdzWzBdLnRhZ3MgJiYgaW1nc1swXS50YWdzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChpbWdzWzBdLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWdzWzBdLmltZy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBpbWdzWzBdLmltZy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWdzWzBdLmltZy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ3NbMF0uaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBpbWdzWzBdLmltZy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRXaWR0aCA9IF9jb25maWc/LnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBfY29uZmlnLnNpemUgOiBNYXRoLmZsb29yKCh3aWR0aCAvIGhlaWdodCkgKiBfY29uZmlnLnNpemUpIDogd2lkdGg7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZEhlaWdodCA9IF9jb25maWc/LnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBNYXRoLmZsb29yKChoZWlnaHQgLyB3aWR0aCkgKiBfY29uZmlnLnNpemUpIDogX2NvbmZpZy5zaXplIDogaGVpZ2h0O1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBjYWxjdWxhdGVkV2lkdGg7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IGNhbGN1bGF0ZWRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgbG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmcmFtZUlkeCA9IDA7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgICAgICAgICAgICAgcHVibGlzaEV2ZW50KCdjYW5yZWNvcmQnLCBbXSk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9LCBvZmZzZXQsIHNpemUsIF9jb25maWc/LnNlcXVlbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHB1Ymxpc2hFdmVudChldmVudE5hbWU6IHN0cmluZywgYXJnczogQXJyYXk8YW55Pik6IHZvaWQge1xuICAgICAgICAgICAgbGV0IGo7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNbal0uYXBwbHkoaW5wdXRTdHJlYW0sIGFyZ3MgYXMgYW55KTsgLy8gVE9ETzogdHlwZXNjcmlwdCBjb21wbGFpbnMgdGhhdCBhbnlbXSBpcyBub3QgdmFsaWQgZm9yIGEgc2Vjb25kIGFyZyBmb3IgYXBwbHk/IVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IGFueSBjb2RlIHNoYXJlZCB3aXRoIHRoZSBmaXJzdCBJbnB1dFN0cmVhbSBhYm92ZSBzaG91bGQgYmUgc2hhcmVkIG5vdCBjb3BpZWRcbiAgICAgICAgLy8gVE9ETzogcHVibGlzaEV2ZW50IG5lZWRzIGFjY2VzcyB0byBpbnB1dFN0cmVhbSwgYnV0IGlucHV0U3RyZWFtIG5lZWRzIGFjY2VzcyB0byBwdWJsaXNoRXZlbnRcbiAgICAgICAgLy8gVE9ETzogVGhpcyBpcyB3aHkgaXQncyBhICd2YXInLCBzbyBpdCBob2lzdHMgYmFjay4gIFRoaXMgaXMgdWdseSwgYW5kIHNob3VsZCBiZSBjaGFuZ2VkLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdmFyLHZhcnMtb24tdG9wXG4gICAgICAgIHZhciBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0gPSB7XG5cbiAgICAgICAgICAgIHRyaWdnZXI6IHB1Ymxpc2hFdmVudCxcblxuICAgICAgICAgICAgZ2V0V2lkdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldFdpZHRoKG5ld1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFdpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRIZWlnaHQobmV3SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZEhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJlYWxXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRSZWFsSGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRJbnB1dFN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgX2NvbmZpZyA9IHN0cmVhbTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5zZXF1ZW5jZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IHN0cmVhbS5zcmM7XG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBzdHJlYW0uc3JjO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gc3RyZWFtLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9hZEltYWdlcygpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZW5kZWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZGVkO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0QXR0cmlidXRlKCkge30sXG5cbiAgICAgICAgICAgIGdldENvbmZpZygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbmZpZztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBhdXNlKCkge1xuICAgICAgICAgICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwbGF5KCkge1xuICAgICAgICAgICAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q3VycmVudFRpbWUodGltZSkge1xuICAgICAgICAgICAgICAgIGZyYW1lSWR4ID0gdGltZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGYpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2V2ZW50TmFtZXMuaW5kZXhPZihldmVudCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2V2ZW50SGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZXZlbnRIYW5kbGVyc1tldmVudF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfZXZlbnRIYW5kbGVyc1tldmVudF0ucHVzaChmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjbGVhckV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoX2V2ZW50SGFuZGxlcnMpLmZvckVhY2goKGluZCkgPT4gZGVsZXRlIF9ldmVudEhhbmRsZXJzW2luZF0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0VG9wUmlnaHQodG9wUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnkgPSB0b3BSaWdodC55O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0VG9wUmlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90b3BSaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldENhbnZhc1NpemUoY2FudmFzU2l6ZSkge1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBjYW52YXNTaXplLng7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IGNhbnZhc1NpemUueTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldENhbnZhc1NpemUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jYW52YXNTaXplO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0RnJhbWUoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFsb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBpbWdBcnJheT8uW2ZyYW1lSWR4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lSWR4IDwgKHNpemUgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJZHgrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJsaXNoRXZlbnQoJ2VuZGVkJywgW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlucHV0U3RyZWFtO1xuICAgIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBpbnB1dFN0cmVhbUZhY3Rvcnk7XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gXCIuLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYVwiO1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tIFwiY29tbW9uL2ltYWdlX3dyYXBwZXJcIjtcblxuZXhwb3J0IGNsYXNzIFF1YWdnYUNvbnRleHQge1xuICAgIHB1YmxpYyBjb25maWc/OiBRdWFnZ2FKU0NvbmZpZ09iamVjdDtcblxuICAgIHB1YmxpYyBpbnB1dFN0cmVhbTogYW55O1xuXG4gICAgcHVibGljIGZyYW1lZ3JhYmJlcjogYW55O1xuXG4gICAgcHVibGljIGlucHV0SW1hZ2VXcmFwcGVyPzogSW1hZ2VXcmFwcGVyO1xuXG4gICAgcHVibGljIHN0b3BwZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHB1YmxpYyBib3hTaXplOiBhbnk7XG5cbiAgICBwdWJsaWMgcmVzdWx0Q29sbGVjdG9yOiBhbnk7XG5cbiAgICBwdWJsaWMgZGVjb2RlcjogYW55O1xuXG4gICAgcHVibGljIHdvcmtlclBvb2w6IGFueVtdID0gW107XG5cbiAgICBwdWJsaWMgb25VSVRocmVhZCA9IHRydWU7XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgY2FudmFzQ29udGFpbmVyID0gbmV3IENhbnZhc0NvbnRhaW5lcigpO1xufVxuXG5leHBvcnQgY2xhc3MgQ2FudmFzSW5mbyB7XG4gICAgaW1hZ2U6IGFueTtcbiAgICBvdmVybGF5OiBhbnk7XG59XG5cbmV4cG9ydCBjbGFzcyBDYW52YXNDb250YWluZXIge1xuICAgIHB1YmxpYyByZWFkb25seSBjdHg6IENhbnZhc0luZm87XG4gICAgcHVibGljIHJlYWRvbmx5IGRvbTogQ2FudmFzSW5mbztcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmN0eCA9IG5ldyBDYW52YXNJbmZvKCk7XG4gICAgICAgIHRoaXMuZG9tID0gbmV3IENhbnZhc0luZm8oKTtcbiAgICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3UG9ydCh0YXJnZXQ/OiBFbGVtZW50IHwgc3RyaW5nKTogRWxlbWVudCB8IG51bGwge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRhcmdldCBpcyBhbHJlYWR5IGEgRE9NIGVsZW1lbnRcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdGFyZ2V0Lm5vZGVOYW1lICYmIHRhcmdldC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICAvLyBVc2UgJyNpbnRlcmFjdGl2ZS52aWV3cG9ydCcgYXMgYSBmYWxsYmFjayBzZWxlY3RvciAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpXG4gICAgY29uc3Qgc2VsZWN0b3IgPSB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IHRhcmdldCA6ICcjaW50ZXJhY3RpdmUudmlld3BvcnQnO1xuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbn1cbiIsImltcG9ydCB7IGNsb25lIH0gZnJvbSAnZ2wtdmVjMic7XG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gJy4uL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCB0eXBlIHsgSW5wdXRTdHJlYW0gfSBmcm9tICcuLi9pbnB1dC9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtLmQnO1xuaW1wb3J0IEJhcmNvZGVMb2NhdG9yIGZyb20gJy4uL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yJztcblxudHlwZSBCdWZmZXJSZXR1cm4gPSB7XG4gICAgLy8gYm94U2l6ZSBzaG91bGQgYmUgbGlrZSBbWyBudW1iZXIsIG51bWJlcl0sIC4uLl0gYnV0IGNsb25lJ3Mgc2lnbmF0dXJlIGRvZXNuJ3Qgc2VlbSB0byBhbGxvdyB0aGF0XG4gICAgYm94U2l6ZTogQXJyYXk8QXJyYXk8bnVtYmVyPj47XG4gICAgaW5wdXRJbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlcjtcbn07XG5cbi8vIFRPRE86IG5lZWQgdHlwZXNjcmlwdCBkZWYgZm9yIEJhcmNvZGVMb2NhdG9yXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0QnVmZmVycyhcbiAgICBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0sXG4gICAgaW1hZ2VXcmFwcGVyOiBJbWFnZVdyYXBwZXIgfCB1bmRlZmluZWQsXG4gICAgbG9jYXRvcjogYW55LFxuKTogQnVmZmVyUmV0dXJuIHtcbiAgICBjb25zdCBpbnB1dEltYWdlV3JhcHBlciA9IGltYWdlV3JhcHBlciB8fCBuZXcgSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgeDogaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSxcbiAgICAgICAgeTogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCksXG4gICAgICAgIHR5cGU6ICdYWVNpemUnLFxuICAgIH0pO1xuXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgaW1hZ2Ugd3JhcHBlciBzaXplICR7aW5wdXRJbWFnZVdyYXBwZXIuc2l6ZX1gKTtcbiAgICB9XG4gICAgY29uc3QgYm94U2l6ZSA9IFtcbiAgICAgICAgY2xvbmUoWzAsIDBdKSxcbiAgICAgICAgY2xvbmUoWzAsIGlucHV0SW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICBjbG9uZShbaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS54LCBpbnB1dEltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgY2xvbmUoW2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCwgMF0pLFxuICAgIF07XG4gICAgQmFyY29kZUxvY2F0b3IuaW5pdChpbnB1dEltYWdlV3JhcHBlciwgbG9jYXRvcik7XG4gICAgcmV0dXJuIHsgaW5wdXRJbWFnZVdyYXBwZXIsIGJveFNpemUgfTtcbn1cbiIsImltcG9ydCB7IFF1YWdnYUNvbnRleHQsIENhbnZhc0NvbnRhaW5lciB9IGZyb20gJ1F1YWdnYUNvbnRleHQnO1xuaW1wb3J0IHR5cGUgeyBYWVNpemUgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcbmltcG9ydCBnZXRWaWV3UG9ydCBmcm9tICcuL2dldFZpZXdQb3J0JztcblxuZnVuY3Rpb24gZmluZE9yQ3JlYXRlQ2FudmFzKHNlbGVjdG9yOiBzdHJpbmcsIGNsYXNzTmFtZTogc3RyaW5nKSB7XG4gICAgbGV0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXM7XG59XG5cbmZ1bmN0aW9uIGdldENhbnZhc0FuZENvbnRleHQoc2VsZWN0b3I6IHN0cmluZywgY2xhc3NOYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBjYW52YXMgPSBmaW5kT3JDcmVhdGVDYW52YXMoc2VsZWN0b3IsIGNsYXNzTmFtZSk7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHJldHVybiB7IGNhbnZhcywgY29udGV4dCB9O1xufVxuXG5mdW5jdGlvbiBpbml0Q2FudmFzZXMoY2FudmFzU2l6ZTogWFlTaXplKTogQ2FudmFzQ29udGFpbmVyIHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBnZXRDYW52YXNBbmRDb250ZXh0KCdjYW52YXMuaW1nQnVmZmVyJywgJ2ltZ0J1ZmZlcicpO1xuICAgICAgICBjb25zdCBvdmVybGF5ID0gZ2V0Q2FudmFzQW5kQ29udGV4dCgnY2FudmFzLmRyYXdpbmdCdWZmZXInLCAnZHJhd2luZ0J1ZmZlcicpO1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cbiAgICAgICAgaW1hZ2UuY2FudmFzLndpZHRoID0gb3ZlcmxheS5jYW52YXMud2lkdGggPSBjYW52YXNTaXplLng7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cbiAgICAgICAgaW1hZ2UuY2FudmFzLmhlaWdodCA9IG92ZXJsYXkuY2FudmFzLmhlaWdodCA9IGNhbnZhc1NpemUueTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9tOiB7XG4gICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlLmNhbnZhcyxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBvdmVybGF5LmNhbnZhcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UuY29udGV4dCxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBvdmVybGF5LmNvbnRleHQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdENhbnZhcyhjb250ZXh0OiBRdWFnZ2FDb250ZXh0KTogQ2FudmFzQ29udGFpbmVyIHwgbnVsbCB7XG4gICAgY29uc3Qgdmlld3BvcnQgPSBnZXRWaWV3UG9ydChjb250ZXh0Py5jb25maWc/LmlucHV0U3RyZWFtPy50YXJnZXQpO1xuICAgIGNvbnN0IHR5cGUgPSBjb250ZXh0Py5jb25maWc/LmlucHV0U3RyZWFtPy50eXBlO1xuICAgIGlmICghdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgY29udGFpbmVyID0gaW5pdENhbnZhc2VzKGNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpKTtcbiAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuIHsgZG9tOiB7IGltYWdlOiBudWxsLCBvdmVybGF5OiBudWxsIH0sIGN0eDogeyBpbWFnZTogbnVsbCwgb3ZlcmxheTogbnVsbCB9IH07XG5cbiAgICBjb25zdCB7IGRvbSB9ID0gY29udGFpbmVyO1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh2aWV3cG9ydCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdJbWFnZVN0cmVhbScgJiYgIXZpZXdwb3J0LmNvbnRhaW5zKGRvbS5pbWFnZSkpIHtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydC5hcHBlbmRDaGlsZChkb20uaW1hZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF2aWV3cG9ydC5jb250YWlucyhkb20ub3ZlcmxheSkpIHtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydC5hcHBlbmRDaGlsZChkb20ub3ZlcmxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cbiIsIi8qIFdvcmtlciBmdW5jdGlvbnMuIFRoZXNlIGFyZSBzdHJhaWdodCBmcm9tIHRoZSBvcmlnaW5hbCBxdWFnZ2EuanMgZmlsZS5cbiAqIE5vdCBwcmVzZW50bHkgdXNlZCwgYXMgd29ya2VyIHN1cHBvcnQgaXMgbm9uLWZ1bmN0aW9uYWwuICBLZWVwaW5nIHRoZW0gYXJvdW5kIHRlbXBvcmFyaWx5XG4gKiB0byByZWZlciB0byB1bnRpbCBpdCBpcyByZS1pbXBsZW1lbnRlZC4gV2UgbWF5IGJlIGFibGUgdG8gZml4L3VzZSBzb21lIG9mIHRoaXMuXG4gKi9cblxuaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QsIFF1YWdnYUpTUmVhZGVyQ29uZmlnIH0gZnJvbSBcIi4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhXCI7XG5cbi8vIFRPRE86IG5lZWQgYSB0eXBlc2NyaXB0IGludGVyZmFjZSBmb3IgRnJhbWVHcmFiYmVyXG5cbmludGVyZmFjZSBRV29ya2VyVGhyZWFkIHtcbiAgICBpbWFnZURhdGE6IFVpbnQ4QXJyYXk7XG4gICAgYnVzeTogYm9vbGVhbjtcbiAgICB3b3JrZXI6IFdvcmtlcjtcbn1cblxubGV0IHdvcmtlclBvb2w6IEFycmF5PFFXb3JrZXJUaHJlYWQ+ID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVXb3JrZXJzKGZyYW1lR3JhYmJlcjogYW55KSB7XG4gICAgbGV0IGF2YWlsYWJsZVdvcmtlcjogUVdvcmtlclRocmVhZDtcbiAgICBpZiAod29ya2VyUG9vbC5sZW5ndGgpIHtcbiAgICAgICAgYXZhaWxhYmxlV29ya2VyID0gd29ya2VyUG9vbC5maWx0ZXIoKHdvcmtlclRocmVhZCkgPT4gIXdvcmtlclRocmVhZC5idXN5KVswXTtcbiAgICAgICAgaWYgKGF2YWlsYWJsZVdvcmtlcikge1xuICAgICAgICAgICAgZnJhbWVHcmFiYmVyLmF0dGFjaERhdGEoYXZhaWxhYmxlV29ya2VyLmltYWdlRGF0YSk7XG4gICAgICAgICAgICBpZiAoZnJhbWVHcmFiYmVyLmdyYWIoKSkge1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVdvcmtlci5idXN5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVXb3JrZXIud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgY21kOiAncHJvY2VzcycsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YTogYXZhaWxhYmxlV29ya2VyLmltYWdlRGF0YSxcbiAgICAgICAgICAgICAgICB9LCBbYXZhaWxhYmxlV29ya2VyLmltYWdlRGF0YS5idWZmZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb25maWdGb3JXb3JrZXIoY29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgICAgIC4uLmNvbmZpZy5pbnB1dFN0cmVhbSxcbiAgICAgICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG4vLyBAdHMtaWdub3JlXG5mdW5jdGlvbiB3b3JrZXJJbnRlcmZhY2UoZmFjdG9yeSkge1xuICAgIGlmIChmYWN0b3J5KSB7XG4gICAgICAgIHZhciBRdWFnZ2EgPSBmYWN0b3J5KCkuZGVmYXVsdDtcbiAgICAgICAgaWYgKCFRdWFnZ2EpIHtcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyAnZXZlbnQnOiAnZXJyb3InLCBtZXNzYWdlOiAnUXVhZ2dhIGNvdWxkIG5vdCBiZSBjcmVhdGVkJyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbi8vIEB0cy1pZ25vcmVcbiAgICB2YXIgaW1hZ2VXcmFwcGVyO1xuXG4vLyBAdHMtaWdub3JlXG4gICAgZnVuY3Rpb24gb25Qcm9jZXNzZWQocmVzdWx0KSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgJ2V2ZW50JzogJ3Byb2Nlc3NlZCcsXG4vLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpbWFnZURhdGE6IGltYWdlV3JhcHBlci5kYXRhLFxuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4vLyBAdHMtaWdub3JlXG4gICAgICAgIH0sIFtpbWFnZVdyYXBwZXIuZGF0YS5idWZmZXJdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3b3JrZXJJbnRlcmZhY2VSZWFkeSgpIHtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAnZXZlbnQnOiAnaW5pdGlhbGl6ZWQnLFxuLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaW1hZ2VEYXRhOiBpbWFnZVdyYXBwZXIuZGF0YSxcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgfSwgW2ltYWdlV3JhcHBlci5kYXRhLmJ1ZmZlcl0pO1xuICAgIH1cblxuLy8gQHRzLWlnbm9yZVxuICAgIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuZGF0YS5jbWQgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGUuZGF0YS5jb25maWc7XG4gICAgICAgICAgICBjb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgICAgIGltYWdlV3JhcHBlciA9IG5ldyBRdWFnZ2EuSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgICAgICAgICB4OiBlLmRhdGEuc2l6ZS54LFxuICAgICAgICAgICAgICAgIHk6IGUuZGF0YS5zaXplLnksXG4gICAgICAgICAgICB9LCBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBRdWFnZ2EuaW5pdChjb25maWcsIHdvcmtlckludGVyZmFjZVJlYWR5LCBpbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgUXVhZ2dhLm9uUHJvY2Vzc2VkKG9uUHJvY2Vzc2VkKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuY21kID09PSAncHJvY2VzcycpIHtcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGltYWdlV3JhcHBlci5kYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSk7XG4gICAgICAgICAgICBRdWFnZ2Euc3RhcnQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuY21kID09PSAnc2V0UmVhZGVycycpIHtcbiAgICAgICAgICAgIFF1YWdnYS5zZXRSZWFkZXJzKGUuZGF0YS5yZWFkZXJzKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuY21kID09PSAncmVnaXN0ZXJSZWFkZXInKSB7XG4gICAgICAgICAgICBRdWFnZ2EucmVnaXN0ZXJSZWFkZXIoZS5kYXRhLm5hbWUsIGUuZGF0YS5yZWFkZXIpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVXb3JrZXJCbG9iKCkge1xuICAgIHZhciBibG9iLFxuICAgICAgICBmYWN0b3J5U291cmNlO1xuXG4gICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodHlwZW9mIF9fZmFjdG9yeVNvdXJjZV9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGZhY3RvcnlTb3VyY2UgPSBfX2ZhY3RvcnlTb3VyY2VfXzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIH1cbiAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gICAgYmxvYiA9IG5ldyBCbG9iKFsnKCcgKyB3b3JrZXJJbnRlcmZhY2UudG9TdHJpbmcoKSArICcpKCcgKyBmYWN0b3J5U291cmNlICsgJyk7J10sXG4gICAgICAgIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSk7XG5cbiAgICByZXR1cm4gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0V29ya2VyKGNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QsIGlucHV0U3RyZWFtOiBhbnksIGNiOiBGdW5jdGlvbikge1xuICAgIGNvbnN0IGJsb2JVUkwgPSBnZW5lcmF0ZVdvcmtlckJsb2IoKTtcbiAgICBjb25zdCB3b3JrZXIgPSBuZXcgV29ya2VyKGJsb2JVUkwpO1xuXG4gICAgY29uc3Qgd29ya2VyVGhyZWFkOiBRV29ya2VyVGhyZWFkID0ge1xuICAgICAgICB3b3JrZXIsXG4gICAgICAgIGltYWdlRGF0YTogbmV3IFVpbnQ4QXJyYXkoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSAqIGlucHV0U3RyZWFtLmdldEhlaWdodCgpKSxcbiAgICAgICAgYnVzeTogdHJ1ZSxcbiAgICB9O1xuXG4gICAgd29ya2VyVGhyZWFkLndvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS5kYXRhLmV2ZW50ID09PSAnaW5pdGlhbGl6ZWQnKSB7XG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JVUkwpO1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmJ1c3kgPSBmYWxzZTtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5pbWFnZURhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV29ya2VyIGluaXRpYWxpemVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYih3b3JrZXJUaHJlYWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ3Byb2Nlc3NlZCcpIHtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5pbWFnZURhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5idXN5ID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUT0RPOiBob3cgdG8gdGhyZWFkIHB1Ymxpc2hSZXN1bHQgaW50byBoZXJlP1xuICAgICAgICAgICAgLy8gcHVibGlzaFJlc3VsdChlLmRhdGEucmVzdWx0LCB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuZXZlbnQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV29ya2VyIGVycm9yOiAnICsgZS5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjbWQ6ICdpbml0JyxcbiAgICAgICAgc2l6ZTogeyB4OiBpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLCB5OiBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSB9LFxuICAgICAgICBpbWFnZURhdGE6IHdvcmtlclRocmVhZC5pbWFnZURhdGEsXG4gICAgICAgIGNvbmZpZzogY29uZmlnRm9yV29ya2VyKGNvbmZpZyksXG4gICAgfSwgW3dvcmtlclRocmVhZC5pbWFnZURhdGEuYnVmZmVyXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RXb3JrZXJQb29sKGNhcGFjaXR5OiBudW1iZXIsIGNvbmZpZz86IFF1YWdnYUpTQ29uZmlnT2JqZWN0LCBpbnB1dFN0cmVhbT86IGFueSwgY2I/OiBGdW5jdGlvbikge1xuICAgIGNvbnN0IGluY3JlYXNlQnkgPSBjYXBhY2l0eSAtIHdvcmtlclBvb2wubGVuZ3RoO1xuICAgIGlmIChpbmNyZWFzZUJ5ID09PSAwICYmIGNiKSB7XG4gICAgICAgIGNiKCk7XG4gICAgfSBlbHNlIGlmIChpbmNyZWFzZUJ5IDwgMCkge1xuICAgICAgICBjb25zdCB3b3JrZXJzVG9UZXJtaW5hdGUgPSB3b3JrZXJQb29sLnNsaWNlKGluY3JlYXNlQnkpO1xuICAgICAgICB3b3JrZXJzVG9UZXJtaW5hdGUuZm9yRWFjaChmdW5jdGlvbiAod29ya2VyVGhyZWFkKSB7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXb3JrZXIgdGVybWluYXRlZCEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdvcmtlclBvb2wgPSB3b3JrZXJQb29sLnNsaWNlKDAsIGluY3JlYXNlQnkpO1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB3b3JrZXJJbml0aWFsaXplZCA9ICh3b3JrZXJUaHJlYWQ6IFFXb3JrZXJUaHJlYWQpID0+IHtcbiAgICAgICAgICAgIHdvcmtlclBvb2wucHVzaCh3b3JrZXJUaHJlYWQpO1xuICAgICAgICAgICAgaWYgKHdvcmtlclBvb2wubGVuZ3RoID49IGNhcGFjaXR5ICYmIGNiKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluY3JlYXNlQnk7IGkrKykge1xuICAgICAgICAgICAgICAgIGluaXRXb3JrZXIoY29uZmlnLCBpbnB1dFN0cmVhbSwgd29ya2VySW5pdGlhbGl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0UmVhZGVycyhyZWFkZXJzOiBBcnJheTxRdWFnZ2FKU1JlYWRlckNvbmZpZz4pIHtcbiAgICB3b3JrZXJQb29sLmZvckVhY2goKHdvcmtlclRocmVhZCkgPT4gd29ya2VyVGhyZWFkLndvcmtlci5wb3N0TWVzc2FnZSh7IGNtZDogJ3NldFJlYWRlcnMnLCByZWFkZXJzIH0pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyUmVhZGVyKG5hbWU6IHN0cmluZywgcmVhZGVyOiBhbnkpIHtcbiAgICB3b3JrZXJQb29sLmZvckVhY2goKHdvcmtlclRocmVhZCkgPT4gd29ya2VyVGhyZWFkLndvcmtlci5wb3N0TWVzc2FnZSh7IGNtZDogJ3JlZ2lzdGVyUmVhZGVyJywgbmFtZSwgcmVhZGVyIH0pKTtcbn1cbiIsImltcG9ydCB7IElucHV0U3RyZWFtRmFjdG9yeSB9IGZyb20gJ2lucHV0L2lucHV0X3N0cmVhbS9pbnB1dF9zdHJlYW0uZCc7XG5pbXBvcnQgdHlwZSB7IElucHV0U3RyZWFtVHlwZSB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG4vLyBUT0RPOiBuZWVkIHRvIGNyZWF0ZSBhbiBJbnB1dFN0cmVhbSB0eXBlc2NyaXB0IGludGVyZmFjZSwgc28gd2UgZG9uJ3QgaGF2ZSBhbiBcImFueVwiIGluIHRoZSBuZXh0IGxpbmVcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHVwSW5wdXRTdHJlYW0odHlwZTogSW5wdXRTdHJlYW1UeXBlID0gJ0xpdmVTdHJlYW0nLCB2aWV3cG9ydDogRWxlbWVudCB8IG51bGwsIGlucHV0U3RyZWFtRmFjdG9yeTogSW5wdXRTdHJlYW1GYWN0b3J5KSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ1ZpZGVvU3RyZWFtJzoge1xuICAgICAgICAgICAgY29uc3QgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2aWRlbyxcbiAgICAgICAgICAgICAgICBpbnB1dFN0cmVhbTogaW5wdXRTdHJlYW1GYWN0b3J5LmNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnSW1hZ2VTdHJlYW0nOlxuICAgICAgICAgICAgcmV0dXJuIHsgaW5wdXRTdHJlYW06IGlucHV0U3RyZWFtRmFjdG9yeS5jcmVhdGVJbWFnZVN0cmVhbSgpIH07XG4gICAgICAgIGNhc2UgJ0xpdmVTdHJlYW0nOiB7XG4gICAgICAgICAgICBsZXQgdmlkZW86IEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh2aWV3cG9ydCkge1xuICAgICAgICAgICAgICAgIHZpZGVvID0gdmlld3BvcnQucXVlcnlTZWxlY3RvcigndmlkZW8nKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZpZGVvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnQuYXBwZW5kQ2hpbGQodmlkZW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmlkZW8sXG4gICAgICAgICAgICAgICAgaW5wdXRTdHJlYW06IGlucHV0U3RyZWFtRmFjdG9yeS5jcmVhdGVMaXZlU3RyZWFtKHZpZGVvIGFzIEhUTUxWaWRlb0VsZW1lbnQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgKiBzZXR1cElucHV0U3RyZWFtIGludmFsaWQgdHlwZSAke3R5cGV9YCk7XG4gICAgICAgICAgICByZXR1cm4geyB2aWRlbzogbnVsbCwgaW5wdXRTdHJlYW06IG51bGwgfTtcbiAgICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuaW1wb3J0IHR5cGUgeyBQb2ludCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5leHBvcnQgdHlwZSBCb3ggPSBBcnJheTxbIG51bWJlciwgbnVtYmVyIF0+O1xuXG5leHBvcnQgdHlwZSBMaW5lID0gWyBQb2ludCwgUG9pbnQgXTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVCb3goYm94OiBCb3gsIHhPZmZzZXQ6IG51bWJlciwgeU9mZnNldDogbnVtYmVyKTogdm9pZCB7XG4gICAgbGV0IGNvcm5lciA9IGJveC5sZW5ndGg7XG4gICAgd2hpbGUgKGNvcm5lci0tKSB7XG4gICAgICAgIGJveFtjb3JuZXJdWzBdICs9IHhPZmZzZXQ7XG4gICAgICAgIGJveFtjb3JuZXJdWzFdICs9IHlPZmZzZXQ7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbW92ZUxpbmUobGluZTogTGluZSwgeE9mZnNldDogbnVtYmVyLCB5T2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICBsaW5lWzBdLnggKz0geE9mZnNldDtcbiAgICBsaW5lWzBdLnkgKz0geU9mZnNldDtcbiAgICBsaW5lWzFdLnggKz0geE9mZnNldDtcbiAgICBsaW5lWzFdLnkgKz0geU9mZnNldDtcbn1cbiIsImltcG9ydCB7IGNsb25lIH0gZnJvbSAnZ2wtdmVjMic7XG5pbXBvcnQgeyBRdWFnZ2FKU1Jlc3VsdE9iamVjdCwgUXVhZ2dhSlNSZWFkZXJDb25maWcgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vY29tbW9uL2V2ZW50cyc7XG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gJy4uL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCBCYXJjb2RlRGVjb2RlciBmcm9tICcuLi9kZWNvZGVyL2JhcmNvZGVfZGVjb2Rlcic7XG5pbXBvcnQgQ2FtZXJhQWNjZXNzIGZyb20gJy4uL2lucHV0L2NhbWVyYV9hY2Nlc3MnO1xuaW1wb3J0IEZyYW1lR3JhYmJlciBmcm9tICcuLi9pbnB1dC9mcmFtZV9ncmFiYmVyLmpzJztcbmltcG9ydCBJbnB1dFN0cmVhbSBmcm9tICcuLi9pbnB1dC9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtJztcbmltcG9ydCBCYXJjb2RlTG9jYXRvciBmcm9tICcuLi9sb2NhdG9yL2JhcmNvZGVfbG9jYXRvcic7XG5pbXBvcnQgeyBRdWFnZ2FDb250ZXh0IH0gZnJvbSAnLi4vUXVhZ2dhQ29udGV4dCc7XG5pbXBvcnQgeyBCYXJjb2RlSW5mbyB9IGZyb20gJy4uL3JlYWRlci9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgX2dldFZpZXdQb3J0IGZyb20gJy4vZ2V0Vmlld1BvcnQnO1xuaW1wb3J0IF9pbml0QnVmZmVycyBmcm9tICcuL2luaXRCdWZmZXJzJztcbmltcG9ydCBfaW5pdENhbnZhcyBmcm9tICcuL2luaXRDYW52YXMnO1xuaW1wb3J0ICogYXMgUVdvcmtlcnMgZnJvbSAnLi9xd29ya2VyJztcbmltcG9ydCBzZXR1cElucHV0U3RyZWFtIGZyb20gJy4vc2V0dXBJbnB1dFN0cmVhbSc7XG5pbXBvcnQgeyBtb3ZlTGluZSwgbW92ZUJveCB9IGZyb20gJy4vdHJhbnNmb3JtJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVhZ2dhIHtcbiAgICBjb250ZXh0OiBRdWFnZ2FDb250ZXh0ID0gbmV3IFF1YWdnYUNvbnRleHQoKTtcblxuICAgIGluaXRCdWZmZXJzKGltYWdlV3JhcHBlcj86IEltYWdlV3JhcHBlcik6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlucHV0SW1hZ2VXcmFwcGVyLCBib3hTaXplIH0gPSBfaW5pdEJ1ZmZlcnMoXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0sXG4gICAgICAgICAgICBpbWFnZVdyYXBwZXIsXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlnLmxvY2F0b3IsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlciA9IGlucHV0SW1hZ2VXcmFwcGVyO1xuICAgICAgICB0aGlzLmNvbnRleHQuYm94U2l6ZSA9IGJveFNpemU7XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZURhdGEoaW1hZ2VXcmFwcGVyPzogSW1hZ2VXcmFwcGVyKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdEJ1ZmZlcnMoaW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRlY29kZXIgPSBCYXJjb2RlRGVjb2Rlci5jcmVhdGUodGhpcy5jb250ZXh0LmNvbmZpZy5kZWNvZGVyLCB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXIpO1xuICAgIH1cblxuICAgIGdldFZpZXdQb3J0KCk6IEVsZW1lbnQgfCBudWxsIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnIHx8ICF0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHRhcmdldCB9ID0gdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbTtcbiAgICAgICAgcmV0dXJuIF9nZXRWaWV3UG9ydCh0YXJnZXQpO1xuICAgIH1cblxuICAgIHJlYWR5KGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbS5wbGF5KCk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgaW5pdENhbnZhcygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gX2luaXRDYW52YXModGhpcy5jb250ZXh0KTtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGN0eCwgZG9tIH0gPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuZG9tLmltYWdlID0gZG9tLmltYWdlO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmRvbS5vdmVybGF5ID0gZG9tLm92ZXJsYXk7XG4gICAgICAgIHRoaXMuY29udGV4dC5jYW52YXNDb250YWluZXIuY3R4LmltYWdlID0gY3R4LmltYWdlO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmN0eC5vdmVybGF5ID0gY3R4Lm92ZXJsYXk7XG4gICAgfVxuXG4gICAgY2FuUmVjb3JkID0gKGNhbGxiYWNrOiAoKSA9PiB2b2lkKTogdm9pZCA9PiB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEJhcmNvZGVMb2NhdG9yLmNoZWNrSW1hZ2VDb25zdHJhaW50cyh0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0sIHRoaXMuY29udGV4dC5jb25maWc/LmxvY2F0b3IpO1xuICAgICAgICB0aGlzLmluaXRDYW52YXMoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlciA9IEZyYW1lR3JhYmJlci5jcmVhdGUoXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0sXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgUVdvcmtlcnMuYWRqdXN0V29ya2VyUG9vbChcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZyxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LmNvbmZpZz8ubnVtT2ZXb3JrZXJzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZURhdGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkeShjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBpbml0SW5wdXRTdHJlYW0oY2FsbGJhY2s6IChlcnI/OiBFcnJvcikgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcgfHwgIXRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHR5cGU6IGlucHV0VHlwZSwgY29uc3RyYWludHMgfSA9IHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW07XG4gICAgICAgIGNvbnN0IHsgdmlkZW8sIGlucHV0U3RyZWFtIH0gPSBzZXR1cElucHV0U3RyZWFtKGlucHV0VHlwZSwgdGhpcy5nZXRWaWV3UG9ydCgpLCBJbnB1dFN0cmVhbSk7XG5cbiAgICAgICAgaWYgKGlucHV0VHlwZSA9PT0gJ0xpdmVTdHJlYW0nICYmIHZpZGVvKSB7XG4gICAgICAgICAgICBDYW1lcmFBY2Nlc3MucmVxdWVzdCh2aWRlbywgY29uc3RyYWludHMpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gaW5wdXRTdHJlYW0udHJpZ2dlcignY2FucmVjb3JkJykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IGNhbGxiYWNrKGVycikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRBdHRyaWJ1dGUoJ3ByZWxvYWQnLCAnYXV0bycpO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0SW5wdXRTdHJlYW0odGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdjYW5yZWNvcmQnLCB0aGlzLmNhblJlY29yZC5iaW5kKHVuZGVmaW5lZCwgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSA9IGlucHV0U3RyZWFtO1xuICAgIH1cblxuICAgIGdldEJvdW5kaW5nQm94ZXMoKTogQXJyYXk8QXJyYXk8bnVtYmVyPj4gfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5jb25maWc/LmxvY2F0ZSA/IEJhcmNvZGVMb2NhdG9yLmxvY2F0ZSgpXG4gICAgICAgICAgICA6IFtbXG4gICAgICAgICAgICAgICAgY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbMF0pLFxuICAgICAgICAgICAgICAgIGNsb25lKHRoaXMuY29udGV4dC5ib3hTaXplWzFdKSxcbiAgICAgICAgICAgICAgICBjbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVsyXSksXG4gICAgICAgICAgICAgICAgY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbM10pLFxuICAgICAgICAgICAgXV07XG4gICAgfVxuXG4gICAgLy8gVE9ETzogbmVlZCBhIHR5cGVzY3JpcHQgdHlwZSBmb3IgcmVzdWx0IGhlcmUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgICB0cmFuc2Zvcm1SZXN1bHQocmVzdWx0OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdG9wUmlnaHQgPSB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgY29uc3QgeE9mZnNldCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgIGNvbnN0IHlPZmZzZXQgPSB0b3BSaWdodC55O1xuXG4gICAgICAgIGlmICh4T2Zmc2V0ID09PSAwICYmIHlPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQuYmFyY29kZXMpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEJhcmNvZGVJbmZvIG1heSBub3QgYmUgdGhlIHJpZ2h0IHR5cGUgaGVyZS5cbiAgICAgICAgICAgIHJlc3VsdC5iYXJjb2Rlcy5mb3JFYWNoKChiYXJjb2RlOiBCYXJjb2RlSW5mbykgPT4gdGhpcy50cmFuc2Zvcm1SZXN1bHQoYmFyY29kZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5saW5lICYmIHJlc3VsdC5saW5lLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgbW92ZUxpbmUocmVzdWx0LmxpbmUsIHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5ib3gpIHtcbiAgICAgICAgICAgIG1vdmVCb3gocmVzdWx0LmJveCwgeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmJveGVzICYmIHJlc3VsdC5ib3hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5ib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG1vdmVCb3gocmVzdWx0LmJveGVzW2ldLCB4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0LCBpbWFnZURhdGE6IEFycmF5PG51bWJlcj4pOiB2b2lkIHtcbiAgICAgICAgaWYgKCFpbWFnZURhdGEgfHwgIXRoaXMuY29udGV4dC5yZXN1bHRDb2xsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2hhdCBkYXRhIHN0cnVjdHVyZSBob2xkcyBhIFwiYmFyY29kZXNcIiByZXN1bHQsIGlmIGFueS4uLlxuICAgICAgICBpZiAocmVzdWx0LmJhcmNvZGVzKSB7XG4gICAgICAgICAgICByZXN1bHQuYmFyY29kZXMuZmlsdGVyKChiYXJjb2RlOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkgPT4gYmFyY29kZS5jb2RlUmVzdWx0KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChiYXJjb2RlOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkgPT4gdGhpcy5hZGRSZXN1bHQoYmFyY29kZSwgaW1hZ2VEYXRhKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmNvZGVSZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXN1bHRDb2xsZWN0b3IuYWRkUmVzdWx0KFxuICAgICAgICAgICAgICAgIGltYWdlRGF0YSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLFxuICAgICAgICAgICAgICAgIHJlc3VsdC5jb2RlUmVzdWx0LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgaGFzQ29kZVJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIShyZXN1bHQgJiYgKHJlc3VsdC5iYXJjb2Rlc1xuICAgICAgICAgICAgPyByZXN1bHQuYmFyY29kZXMuc29tZSgoYmFyY29kZSkgPT4gYmFyY29kZS5jb2RlUmVzdWx0KVxuICAgICAgICAgICAgOiByZXN1bHQuY29kZVJlc3VsdCkpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gICAgcHVibGlzaFJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0IHwgbnVsbCA9IG51bGwsIGltYWdlRGF0YT86IGFueSk6IHZvaWQge1xuICAgICAgICBsZXQgcmVzdWx0VG9QdWJsaXNoOiBBcnJheTxRdWFnZ2FKU1Jlc3VsdE9iamVjdD4gfCBRdWFnZ2FKU1Jlc3VsdE9iamVjdCB8IG51bGwgPSByZXN1bHQ7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiB0aGlzLmNvbnRleHQub25VSVRocmVhZCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIHRoaXMuYWRkUmVzdWx0KHJlc3VsdCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIHJlc3VsdFRvUHVibGlzaCA9IHJlc3VsdC5iYXJjb2RlcyB8fCByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBFdmVudHMucHVibGlzaCgncHJvY2Vzc2VkJywgcmVzdWx0VG9QdWJsaXNoIGFzIG5ldmVyKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29kZVJlc3VsdChyZXN1bHQgYXMgUXVhZ2dhSlNSZXN1bHRPYmplY3QpKSB7XG4gICAgICAgICAgICBFdmVudHMucHVibGlzaCgnZGV0ZWN0ZWQnLCByZXN1bHRUb1B1Ymxpc2ggYXMgbmV2ZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgbG9jYXRlQW5kRGVjb2RlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBib3hlcyA9IHRoaXMuZ2V0Qm91bmRpbmdCb3hlcygpO1xuICAgICAgICBpZiAoYm94ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZVJlc3VsdCA9IChhd2FpdCB0aGlzLmNvbnRleHQuZGVjb2Rlci5kZWNvZGVGcm9tQm91bmRpbmdCb3hlcyhib3hlcykpIHx8IHt9O1xuICAgICAgICAgICAgZGVjb2RlUmVzdWx0LmJveGVzID0gYm94ZXM7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXN1bHQoZGVjb2RlUmVzdWx0LCB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VSZXN1bHQgPSBhd2FpdCB0aGlzLmNvbnRleHQuZGVjb2Rlci5kZWNvZGVGcm9tSW1hZ2UodGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgIGlmIChpbWFnZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3VsdChpbWFnZVJlc3VsdCwgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyPy5kYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGUgPSAoKTogdm9pZCA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQub25VSVRocmVhZCkge1xuICAgICAgICAgICAgY29uc3Qgd29ya2Vyc1VwZGF0ZWQgPSBRV29ya2Vycy51cGRhdGVXb3JrZXJzKHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIpO1xuICAgICAgICAgICAgaWYgKCF3b3JrZXJzVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuYXR0YWNoRGF0YSh0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyLmdyYWIoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXdvcmtlcnNVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2F0ZUFuZERlY29kZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5hdHRhY2hEYXRhKHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyLmdyYWIoKTtcbiAgICAgICAgICAgIHRoaXMubG9jYXRlQW5kRGVjb2RlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc3RhcnRDb250aW51b3VzVXBkYXRlKCk6IHZvaWQge1xuICAgICAgICBsZXQgbmV4dDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gMTAwMCAvICh0aGlzLmNvbnRleHQuY29uZmlnPy5mcmVxdWVuY3kgfHwgNjApO1xuXG4gICAgICAgIHRoaXMuY29udGV4dC5zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgY29udGV4dCB9ID0gdGhpcztcblxuICAgICAgICBjb25zdCBuZXdGcmFtZSA9ICh0aW1lc3RhbXA6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgfHwgdGltZXN0YW1wO1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0LnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZXN0YW1wID49IG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCArPSBkZWxheTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShuZXdGcmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgbmV3RnJhbWUocGVyZm9ybWFuY2Uubm93KCkpO1xuICAgIH1cblxuICAgIHN0YXJ0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0Lm9uVUlUaHJlYWQgJiYgdGhpcy5jb250ZXh0LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnR5cGUgPT09ICdMaXZlU3RyZWFtJykge1xuICAgICAgICAgICAgdGhpcy5zdGFydENvbnRpbnVvdXNVcGRhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBzdG9wKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICB0aGlzLmNvbnRleHQuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIFFXb3JrZXJzLmFkanVzdFdvcmtlclBvb2woMCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuY29uZmlnPy5pbnB1dFN0cmVhbSAmJiB0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtLnR5cGUgPT09ICdMaXZlU3RyZWFtJykge1xuICAgICAgICAgICAgYXdhaXQgQ2FtZXJhQWNjZXNzLnJlbGVhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbS5jbGVhckV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFJlYWRlcnMocmVhZGVyczogQXJyYXk8UXVhZ2dhSlNSZWFkZXJDb25maWc+KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuZGVjb2Rlcikge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRlY29kZXIuc2V0UmVhZGVycyhyZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBRV29ya2Vycy5zZXRSZWFkZXJzKHJlYWRlcnMpO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyUmVhZGVyKG5hbWU6IHN0cmluZywgcmVhZGVyOiBRdWFnZ2FKU1JlYWRlckNvbmZpZyk6IHZvaWQge1xuICAgICAgICBCYXJjb2RlRGVjb2Rlci5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmRlY29kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgUVdvcmtlcnMucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoL21lcmdlJztcbmltcG9ydCBUeXBlRGVmcyBmcm9tICcuL2NvbW1vbi90eXBlZGVmcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQgQmFyY29kZURlY29kZXIgZnJvbSAnLi9kZWNvZGVyL2JhcmNvZGVfZGVjb2Rlcic7XG5pbXBvcnQgKiBhcyBSZWFkZXJzIGZyb20gJy4vcmVhZGVyL2luZGV4JztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi9jb21tb24vZXZlbnRzJztcbmltcG9ydCBDYW1lcmFBY2Nlc3MgZnJvbSAnLi9pbnB1dC9jYW1lcmFfYWNjZXNzJztcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBSZXN1bHRDb2xsZWN0b3IgZnJvbSAnLi9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvcic7XG5pbXBvcnQgQ29uZmlnIGZyb20gJy4vY29uZmlnL2NvbmZpZyc7XG5cbmltcG9ydCBRdWFnZ2EgZnJvbSAnLi9xdWFnZ2EvcXVhZ2dhJztcblxuY29uc3QgaW5zdGFuY2UgPSBuZXcgUXVhZ2dhKCk7XG5jb25zdCBfY29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG5cbmNvbnN0IFF1YWdnYUpTU3RhdGljSW50ZXJmYWNlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIChjb25maWcsIGNiLCBpbWFnZVdyYXBwZXIsIHF1YWdnYUluc3RhbmNlID0gaW5zdGFuY2UpIHtcbiAgICAgICAgbGV0IHByb21pc2U7XG4gICAgICAgIGlmICghY2IpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY2IgPSAoZXJyKSA9PiB7IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZSgpOyB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcgPSBtZXJnZSh7fSwgQ29uZmlnLCBjb25maWcpO1xuICAgICAgICAvLyBUT0RPICMxNzk6IHBlbmRpbmcgcmVzdHJ1Y3R1cmUgaW4gSXNzdWUgIzE3OSwgd2UgYXJlIHRlbXAgZGlzYWJsaW5nIHdvcmtlcnNcbiAgICAgICAgaWYgKHF1YWdnYUluc3RhbmNlLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA+IDApIHtcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmNvbnRleHQuY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltYWdlV3JhcHBlcikge1xuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5vblVJVGhyZWFkID0gZmFsc2U7XG4gICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5pbml0aWFsaXplRGF0YShpbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmluaXRJbnB1dFN0cmVhbShjYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSxcbiAgICBzdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2Uuc3RhcnQoKTtcbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnN0b3AoKTtcbiAgICB9LFxuICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9jb250ZXh0LnN0b3BwZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgb25EZXRlY3RlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2sgfHwgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGNhbGxiYWNrICE9PSAnb2JqZWN0JyB8fCAhY2FsbGJhY2suY2FsbGJhY2spKSkge1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2Eub25EZXRlY3RlZCBjYWxsZWQgd2l0aCBpbnZhbGlkIGNhbGxiYWNrLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEV2ZW50cy5zdWJzY3JpYmUoJ2RldGVjdGVkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb2ZmRGV0ZWN0ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBFdmVudHMudW5zdWJzY3JpYmUoJ2RldGVjdGVkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb25Qcm9jZXNzZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrIHx8ICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ29iamVjdCcgfHwgIWNhbGxiYWNrLmNhbGxiYWNrKSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLm9uUHJvY2Vzc2VkIGNhbGxlZCB3aXRoIGludmFsaWQgY2FsbGJhY2ssIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRzLnN1YnNjcmliZSgncHJvY2Vzc2VkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb2ZmUHJvY2Vzc2VkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgRXZlbnRzLnVuc3Vic2NyaWJlKCdwcm9jZXNzZWQnLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBzZXRSZWFkZXJzOiBmdW5jdGlvbiAocmVhZGVycykge1xuICAgICAgICBpZiAoIXJlYWRlcnMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnNldFJlYWRlcnMgY2FsbGVkIHdpdGggbm8gcmVhZGVycywgaWdub3JpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5zZXRSZWFkZXJzKHJlYWRlcnMpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJSZWFkZXI6IGZ1bmN0aW9uIChuYW1lLCByZWFkZXIpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5yZWdpc3RlclJlYWRlciBjYWxsZWQgd2l0aCBubyBuYW1lLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5yZWdpc3RlclJlYWRlciBjYWxsZWQgd2l0aCBubyByZWFkZXIsIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyUmVzdWx0Q29sbGVjdG9yOiBmdW5jdGlvbiAocmVzdWx0Q29sbGVjdG9yKSB7XG4gICAgICAgIGlmIChyZXN1bHRDb2xsZWN0b3IgJiYgdHlwZW9mIHJlc3VsdENvbGxlY3Rvci5hZGRSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF9jb250ZXh0LnJlc3VsdENvbGxlY3RvciA9IHJlc3VsdENvbGxlY3RvcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IGNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIF9jb250ZXh0LmNhbnZhc0NvbnRhaW5lcjtcbiAgICB9LFxuICAgIGRlY29kZVNpbmdsZTogZnVuY3Rpb24gKGNvbmZpZywgcmVzdWx0Q2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcXVhZ2dhSW5zdGFuY2UgPSBuZXcgUXVhZ2dhKCk7XG4gICAgICAgIGNvbmZpZyA9IG1lcmdlKHtcbiAgICAgICAgICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0ltYWdlU3RyZWFtJyxcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2l6ZTogODAwLFxuICAgICAgICAgICAgICAgIHNyYzogY29uZmlnLnNyYyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudW1PZldvcmtlcnM6IChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnKSA/IDAgOiAxLFxuICAgICAgICAgICAgbG9jYXRvcjoge1xuICAgICAgICAgICAgICAgIGhhbGZTYW1wbGU6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgY29uZmlnKTtcbiAgICAgICAgLy8gVE9ETyAjMTc1OiByZXN0cnVjdHVyZSB3b3JrZXIgc3VwcG9ydCBzbyB0aGF0IGl0IHdpbGwgd29yayB3aXRoIHR5cGVzY3JpcHQgdXNpbmcgd29ya2VyLWxvYWRlclxuICAgICAgICAvLyBodHRwczovL3dlYnBhY2suanMub3JnL2xvYWRlcnMvd29ya2VyLWxvYWRlci9cbiAgICAgICAgaWYgKGNvbmZpZy5udW1PZldvcmtlcnMgPiAwKSB7XG4gICAgICAgICAgICBjb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyB3b3JrZXJzIHJlcXVpcmUgV29ya2VyIGFuZCBCbG9iIHN1cHBvcnQgcHJlc2VudGx5LCBzbyBpZiBubyBCbG9iIG9yIFdvcmtlciB0aGVuIHNldFxuICAgICAgICAvLyB3b3JrZXJzIHRvIDAuXG4gICAgICAgIGlmIChjb25maWcubnVtT2ZXb3JrZXJzID4gMCAmJiAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCcqIG5vIFdvcmtlciBhbmQvb3IgQmxvYiBzdXBwb3J0IC0gZm9yY2luZyBudW1PZldvcmtlcnMgdG8gMCcpO1xuICAgICAgICAgICAgY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KGNvbmZpZywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBFdmVudHMub25jZSgncHJvY2Vzc2VkJywgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2Uuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Q2FsbGJhY2suY2FsbChudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2Uuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9LCBudWxsLCBxdWFnZ2FJbnN0YW5jZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBhZGQgdGhlIHVzdWFsbHkgZXhwZWN0ZWQgXCJkZWZhdWx0XCIgZm9yIHVzZSB3aXRoIHJlcXVpcmUsIGJ1aWxkIHN0ZXAgd29uJ3QgYWxsb3cgdXMgdG9cbiAgICAvLyB3cml0ZSB0byBtb2R1bGUuZXhwb3J0cyBzbyBkbyBpdCBoZXJlLlxuICAgIGdldCBkZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2U7XG4gICAgfSxcbiAgICBSZWFkZXJzLFxuICAgIENhbWVyYUFjY2VzcyxcbiAgICBJbWFnZURlYnVnLFxuICAgIEltYWdlV3JhcHBlcixcbiAgICBSZXN1bHRDb2xsZWN0b3IsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZTtcbi8vIGV4cG9ydCBCYXJjb2RlUmVhZGVyIGFuZCBvdGhlciB1dGlsaXRpZXMgZm9yIGV4dGVybmFsIHBsdWdpbnNcbmV4cG9ydCB7XG4gICAgQmFyY29kZURlY29kZXIsXG4gICAgUmVhZGVycyxcbiAgICBDYW1lcmFBY2Nlc3MsXG4gICAgSW1hZ2VEZWJ1ZyxcbiAgICBJbWFnZVdyYXBwZXIsXG4gICAgUmVzdWx0Q29sbGVjdG9yLFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n\n//# sourceURL=webpack://test/./src/quagga.min.js?");

/***/ }),

/***/ "./dist/setting.json":
/*!***************************!*\
  !*** ./dist/setting.json ***!
  \***************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"inputStream\":{\"//\":\"スキャンしない範囲\",\"type\":\"LiveStream\",\"target\":\"barcord-scan-area\",\"decodeBarCodeRate\":5,\"successTimeout\":500,\"codeRepetition\":true,\"tryVertical\":true,\"frameRate\":30,\"width\":320,\"height\":640,\"facingMode\":\"environment\",\"frequency\":10,\"area\":{\"top\":\"0%\",\"right\":\"0%\",\"left\":\"0%\",\"bottom\":\"0%\"}},\"//\":\"自動停止時間(秒設定)\",\"decoder\":{\"//\":\"複数検知 精度向上のため無効\",\"readers\":\"code_128_reader\",\"multiple\":false},\"locate\":true,\"locator\":{\"//\":\"バーコード読み取りサイズ(x-small,small,medium,large,x-large)\",\"halfSample\":true,\"patchSize\":\"medium\"},\"debug\":false,\"codeCheckCount\":3,\"scanBoxLineColor\":\"green\",\"scanBoxLineWidth\":2,\"successBoxLineColor\":\"yellow\",\"successBoxLineWidth\":2,\"successLineColor\":\"red\",\"successLineWidth\":5,\"successEntryAudioSource\":\"/medias/scan_entry_succes.mp3\",\"successExitAudioSource\":\"/medias/scan_exit_succes.mp3\",\"scanTimeOut\":180,\"API\":{\"humanResource\":{\"url\":\"http://127.0.0.1:8000/api/resource/barcode/\"},\"record\":{\"url\":\"http://127.0.0.1:8000/api/record/\"}}}');\n\n//# sourceURL=webpack://test/./dist/setting.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;